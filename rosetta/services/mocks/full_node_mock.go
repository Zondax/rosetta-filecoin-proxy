// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package api

import (
	"context"
	"encoding/json"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-bitfield"
	"github.com/filecoin-project/go-f3/certs"
	"github.com/filecoin-project/go-f3/gpbft"
	"github.com/filecoin-project/go-f3/manifest"
	"github.com/filecoin-project/go-jsonrpc"
	"github.com/filecoin-project/go-jsonrpc/auth"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/builtin/v8/paych"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/go-state-types/dline"
	network0 "github.com/filecoin-project/go-state-types/network"
	"github.com/filecoin-project/lotus/api"
	apitypes "github.com/filecoin-project/lotus/api/types"
	"github.com/filecoin-project/lotus/chain/actors/builtin/miner"
	"github.com/filecoin-project/lotus/chain/actors/builtin/verifreg"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/filecoin-project/lotus/chain/types/ethtypes"
	"github.com/filecoin-project/lotus/journal/alerting"
	"github.com/filecoin-project/lotus/node/modules/dtypes"
	"github.com/google/uuid"
	blocks "github.com/ipfs/go-block-format"
	"github.com/ipfs/go-cid"
	"github.com/libp2p/go-libp2p/core/metrics"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	mock "github.com/stretchr/testify/mock"
)

// NewFullNode creates a new instance of FullNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFullNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *FullNode {
	mock := &FullNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// FullNode is an autogenerated mock type for the FullNode type
type FullNode struct {
	mock.Mock
}

type FullNode_Expecter struct {
	mock *mock.Mock
}

func (_m *FullNode) EXPECT() *FullNode_Expecter {
	return &FullNode_Expecter{mock: &_m.Mock}
}

// AuthNew provides a mock function for the type FullNode
func (_mock *FullNode) AuthNew(ctx context.Context, perms []auth.Permission) ([]byte, error) {
	ret := _mock.Called(ctx, perms)

	if len(ret) == 0 {
		panic("no return value specified for AuthNew")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []auth.Permission) ([]byte, error)); ok {
		return returnFunc(ctx, perms)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []auth.Permission) []byte); ok {
		r0 = returnFunc(ctx, perms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []auth.Permission) error); ok {
		r1 = returnFunc(ctx, perms)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_AuthNew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthNew'
type FullNode_AuthNew_Call struct {
	*mock.Call
}

// AuthNew is a helper method to define mock.On call
//   - ctx
//   - perms
func (_e *FullNode_Expecter) AuthNew(ctx interface{}, perms interface{}) *FullNode_AuthNew_Call {
	return &FullNode_AuthNew_Call{Call: _e.mock.On("AuthNew", ctx, perms)}
}

func (_c *FullNode_AuthNew_Call) Run(run func(ctx context.Context, perms []auth.Permission)) *FullNode_AuthNew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]auth.Permission))
	})
	return _c
}

func (_c *FullNode_AuthNew_Call) Return(bytes []byte, err error) *FullNode_AuthNew_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *FullNode_AuthNew_Call) RunAndReturn(run func(ctx context.Context, perms []auth.Permission) ([]byte, error)) *FullNode_AuthNew_Call {
	_c.Call.Return(run)
	return _c
}

// AuthVerify provides a mock function for the type FullNode
func (_mock *FullNode) AuthVerify(ctx context.Context, token string) ([]auth.Permission, error) {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for AuthVerify")
	}

	var r0 []auth.Permission
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]auth.Permission, error)); ok {
		return returnFunc(ctx, token)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []auth.Permission); ok {
		r0 = returnFunc(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]auth.Permission)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_AuthVerify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthVerify'
type FullNode_AuthVerify_Call struct {
	*mock.Call
}

// AuthVerify is a helper method to define mock.On call
//   - ctx
//   - token
func (_e *FullNode_Expecter) AuthVerify(ctx interface{}, token interface{}) *FullNode_AuthVerify_Call {
	return &FullNode_AuthVerify_Call{Call: _e.mock.On("AuthVerify", ctx, token)}
}

func (_c *FullNode_AuthVerify_Call) Run(run func(ctx context.Context, token string)) *FullNode_AuthVerify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_AuthVerify_Call) Return(permissions []auth.Permission, err error) *FullNode_AuthVerify_Call {
	_c.Call.Return(permissions, err)
	return _c
}

func (_c *FullNode_AuthVerify_Call) RunAndReturn(run func(ctx context.Context, token string) ([]auth.Permission, error)) *FullNode_AuthVerify_Call {
	_c.Call.Return(run)
	return _c
}

// ChainBlockstoreInfo provides a mock function for the type FullNode
func (_mock *FullNode) ChainBlockstoreInfo(context1 context.Context) (map[string]interface{}, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ChainBlockstoreInfo")
	}

	var r0 map[string]interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[string]interface{}, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainBlockstoreInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainBlockstoreInfo'
type FullNode_ChainBlockstoreInfo_Call struct {
	*mock.Call
}

// ChainBlockstoreInfo is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ChainBlockstoreInfo(context1 interface{}) *FullNode_ChainBlockstoreInfo_Call {
	return &FullNode_ChainBlockstoreInfo_Call{Call: _e.mock.On("ChainBlockstoreInfo", context1)}
}

func (_c *FullNode_ChainBlockstoreInfo_Call) Run(run func(context1 context.Context)) *FullNode_ChainBlockstoreInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ChainBlockstoreInfo_Call) Return(stringToIfaceVal map[string]interface{}, err error) *FullNode_ChainBlockstoreInfo_Call {
	_c.Call.Return(stringToIfaceVal, err)
	return _c
}

func (_c *FullNode_ChainBlockstoreInfo_Call) RunAndReturn(run func(context1 context.Context) (map[string]interface{}, error)) *FullNode_ChainBlockstoreInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ChainCheckBlockstore provides a mock function for the type FullNode
func (_mock *FullNode) ChainCheckBlockstore(context1 context.Context) error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ChainCheckBlockstore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainCheckBlockstore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainCheckBlockstore'
type FullNode_ChainCheckBlockstore_Call struct {
	*mock.Call
}

// ChainCheckBlockstore is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ChainCheckBlockstore(context1 interface{}) *FullNode_ChainCheckBlockstore_Call {
	return &FullNode_ChainCheckBlockstore_Call{Call: _e.mock.On("ChainCheckBlockstore", context1)}
}

func (_c *FullNode_ChainCheckBlockstore_Call) Run(run func(context1 context.Context)) *FullNode_ChainCheckBlockstore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ChainCheckBlockstore_Call) Return(err error) *FullNode_ChainCheckBlockstore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainCheckBlockstore_Call) RunAndReturn(run func(context1 context.Context) error) *FullNode_ChainCheckBlockstore_Call {
	_c.Call.Return(run)
	return _c
}

// ChainDeleteObj provides a mock function for the type FullNode
func (_mock *FullNode) ChainDeleteObj(context1 context.Context, cid1 cid.Cid) error {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainDeleteObj")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainDeleteObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainDeleteObj'
type FullNode_ChainDeleteObj_Call struct {
	*mock.Call
}

// ChainDeleteObj is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainDeleteObj(context1 interface{}, cid1 interface{}) *FullNode_ChainDeleteObj_Call {
	return &FullNode_ChainDeleteObj_Call{Call: _e.mock.On("ChainDeleteObj", context1, cid1)}
}

func (_c *FullNode_ChainDeleteObj_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainDeleteObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainDeleteObj_Call) Return(err error) *FullNode_ChainDeleteObj_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainDeleteObj_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) error) *FullNode_ChainDeleteObj_Call {
	_c.Call.Return(run)
	return _c
}

// ChainExport provides a mock function for the type FullNode
func (_mock *FullNode) ChainExport(ctx context.Context, nroots abi.ChainEpoch, oldmsgskip bool, tsk types.TipSetKey) (<-chan []byte, error) {
	ret := _mock.Called(ctx, nroots, oldmsgskip, tsk)

	if len(ret) == 0 {
		panic("no return value specified for ChainExport")
	}

	var r0 <-chan []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) (<-chan []byte, error)); ok {
		return returnFunc(ctx, nroots, oldmsgskip, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) <-chan []byte); ok {
		r0 = returnFunc(ctx, nroots, oldmsgskip, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, nroots, oldmsgskip, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainExport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainExport'
type FullNode_ChainExport_Call struct {
	*mock.Call
}

// ChainExport is a helper method to define mock.On call
//   - ctx
//   - nroots
//   - oldmsgskip
//   - tsk
func (_e *FullNode_Expecter) ChainExport(ctx interface{}, nroots interface{}, oldmsgskip interface{}, tsk interface{}) *FullNode_ChainExport_Call {
	return &FullNode_ChainExport_Call{Call: _e.mock.On("ChainExport", ctx, nroots, oldmsgskip, tsk)}
}

func (_c *FullNode_ChainExport_Call) Run(run func(ctx context.Context, nroots abi.ChainEpoch, oldmsgskip bool, tsk types.TipSetKey)) *FullNode_ChainExport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(bool), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainExport_Call) Return(bytesCh <-chan []byte, err error) *FullNode_ChainExport_Call {
	_c.Call.Return(bytesCh, err)
	return _c
}

func (_c *FullNode_ChainExport_Call) RunAndReturn(run func(ctx context.Context, nroots abi.ChainEpoch, oldmsgskip bool, tsk types.TipSetKey) (<-chan []byte, error)) *FullNode_ChainExport_Call {
	_c.Call.Return(run)
	return _c
}

// ChainExportRangeInternal provides a mock function for the type FullNode
func (_mock *FullNode) ChainExportRangeInternal(ctx context.Context, head types.TipSetKey, tail types.TipSetKey, cfg api.ChainExportConfig) error {
	ret := _mock.Called(ctx, head, tail, cfg)

	if len(ret) == 0 {
		panic("no return value specified for ChainExportRangeInternal")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey, api.ChainExportConfig) error); ok {
		r0 = returnFunc(ctx, head, tail, cfg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainExportRangeInternal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainExportRangeInternal'
type FullNode_ChainExportRangeInternal_Call struct {
	*mock.Call
}

// ChainExportRangeInternal is a helper method to define mock.On call
//   - ctx
//   - head
//   - tail
//   - cfg
func (_e *FullNode_Expecter) ChainExportRangeInternal(ctx interface{}, head interface{}, tail interface{}, cfg interface{}) *FullNode_ChainExportRangeInternal_Call {
	return &FullNode_ChainExportRangeInternal_Call{Call: _e.mock.On("ChainExportRangeInternal", ctx, head, tail, cfg)}
}

func (_c *FullNode_ChainExportRangeInternal_Call) Run(run func(ctx context.Context, head types.TipSetKey, tail types.TipSetKey, cfg api.ChainExportConfig)) *FullNode_ChainExportRangeInternal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey), args[2].(types.TipSetKey), args[3].(api.ChainExportConfig))
	})
	return _c
}

func (_c *FullNode_ChainExportRangeInternal_Call) Return(err error) *FullNode_ChainExportRangeInternal_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainExportRangeInternal_Call) RunAndReturn(run func(ctx context.Context, head types.TipSetKey, tail types.TipSetKey, cfg api.ChainExportConfig) error) *FullNode_ChainExportRangeInternal_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetBlock provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetBlock(context1 context.Context, cid1 cid.Cid) (*types.BlockHeader, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetBlock")
	}

	var r0 *types.BlockHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (*types.BlockHeader, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.BlockHeader); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetBlock'
type FullNode_ChainGetBlock_Call struct {
	*mock.Call
}

// ChainGetBlock is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainGetBlock(context1 interface{}, cid1 interface{}) *FullNode_ChainGetBlock_Call {
	return &FullNode_ChainGetBlock_Call{Call: _e.mock.On("ChainGetBlock", context1, cid1)}
}

func (_c *FullNode_ChainGetBlock_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainGetBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetBlock_Call) Return(blockHeader *types.BlockHeader, err error) *FullNode_ChainGetBlock_Call {
	_c.Call.Return(blockHeader, err)
	return _c
}

func (_c *FullNode_ChainGetBlock_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) (*types.BlockHeader, error)) *FullNode_ChainGetBlock_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetBlockMessages provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetBlockMessages(ctx context.Context, blockCid cid.Cid) (*api.BlockMessages, error) {
	ret := _mock.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetBlockMessages")
	}

	var r0 *api.BlockMessages
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (*api.BlockMessages, error)); ok {
		return returnFunc(ctx, blockCid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.BlockMessages); ok {
		r0 = returnFunc(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BlockMessages)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetBlockMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetBlockMessages'
type FullNode_ChainGetBlockMessages_Call struct {
	*mock.Call
}

// ChainGetBlockMessages is a helper method to define mock.On call
//   - ctx
//   - blockCid
func (_e *FullNode_Expecter) ChainGetBlockMessages(ctx interface{}, blockCid interface{}) *FullNode_ChainGetBlockMessages_Call {
	return &FullNode_ChainGetBlockMessages_Call{Call: _e.mock.On("ChainGetBlockMessages", ctx, blockCid)}
}

func (_c *FullNode_ChainGetBlockMessages_Call) Run(run func(ctx context.Context, blockCid cid.Cid)) *FullNode_ChainGetBlockMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetBlockMessages_Call) Return(blockMessages *api.BlockMessages, err error) *FullNode_ChainGetBlockMessages_Call {
	_c.Call.Return(blockMessages, err)
	return _c
}

func (_c *FullNode_ChainGetBlockMessages_Call) RunAndReturn(run func(ctx context.Context, blockCid cid.Cid) (*api.BlockMessages, error)) *FullNode_ChainGetBlockMessages_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetEvents provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetEvents(context1 context.Context, cid1 cid.Cid) ([]types.Event, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetEvents")
	}

	var r0 []types.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]types.Event, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) []types.Event); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetEvents'
type FullNode_ChainGetEvents_Call struct {
	*mock.Call
}

// ChainGetEvents is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainGetEvents(context1 interface{}, cid1 interface{}) *FullNode_ChainGetEvents_Call {
	return &FullNode_ChainGetEvents_Call{Call: _e.mock.On("ChainGetEvents", context1, cid1)}
}

func (_c *FullNode_ChainGetEvents_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainGetEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetEvents_Call) Return(events []types.Event, err error) *FullNode_ChainGetEvents_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *FullNode_ChainGetEvents_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) ([]types.Event, error)) *FullNode_ChainGetEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetGenesis provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetGenesis(context1 context.Context) (*types.TipSet, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetGenesis")
	}

	var r0 *types.TipSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*types.TipSet, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetGenesis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetGenesis'
type FullNode_ChainGetGenesis_Call struct {
	*mock.Call
}

// ChainGetGenesis is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ChainGetGenesis(context1 interface{}) *FullNode_ChainGetGenesis_Call {
	return &FullNode_ChainGetGenesis_Call{Call: _e.mock.On("ChainGetGenesis", context1)}
}

func (_c *FullNode_ChainGetGenesis_Call) Run(run func(context1 context.Context)) *FullNode_ChainGetGenesis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ChainGetGenesis_Call) Return(tipSet *types.TipSet, err error) *FullNode_ChainGetGenesis_Call {
	_c.Call.Return(tipSet, err)
	return _c
}

func (_c *FullNode_ChainGetGenesis_Call) RunAndReturn(run func(context1 context.Context) (*types.TipSet, error)) *FullNode_ChainGetGenesis_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetMessage provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetMessage(context1 context.Context, cid1 cid.Cid) (*types.Message, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetMessage")
	}

	var r0 *types.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (*types.Message, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.Message); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetMessage'
type FullNode_ChainGetMessage_Call struct {
	*mock.Call
}

// ChainGetMessage is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainGetMessage(context1 interface{}, cid1 interface{}) *FullNode_ChainGetMessage_Call {
	return &FullNode_ChainGetMessage_Call{Call: _e.mock.On("ChainGetMessage", context1, cid1)}
}

func (_c *FullNode_ChainGetMessage_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainGetMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetMessage_Call) Return(message *types.Message, err error) *FullNode_ChainGetMessage_Call {
	_c.Call.Return(message, err)
	return _c
}

func (_c *FullNode_ChainGetMessage_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) (*types.Message, error)) *FullNode_ChainGetMessage_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetMessagesInTipset provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetMessagesInTipset(ctx context.Context, tsk types.TipSetKey) ([]api.Message, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetMessagesInTipset")
	}

	var r0 []api.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]api.Message, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []api.Message); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetMessagesInTipset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetMessagesInTipset'
type FullNode_ChainGetMessagesInTipset_Call struct {
	*mock.Call
}

// ChainGetMessagesInTipset is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) ChainGetMessagesInTipset(ctx interface{}, tsk interface{}) *FullNode_ChainGetMessagesInTipset_Call {
	return &FullNode_ChainGetMessagesInTipset_Call{Call: _e.mock.On("ChainGetMessagesInTipset", ctx, tsk)}
}

func (_c *FullNode_ChainGetMessagesInTipset_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_ChainGetMessagesInTipset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainGetMessagesInTipset_Call) Return(messages []api.Message, err error) *FullNode_ChainGetMessagesInTipset_Call {
	_c.Call.Return(messages, err)
	return _c
}

func (_c *FullNode_ChainGetMessagesInTipset_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) ([]api.Message, error)) *FullNode_ChainGetMessagesInTipset_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetNode provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetNode(ctx context.Context, p string) (*api.IpldObject, error) {
	ret := _mock.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetNode")
	}

	var r0 *api.IpldObject
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*api.IpldObject, error)); ok {
		return returnFunc(ctx, p)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *api.IpldObject); ok {
		r0 = returnFunc(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.IpldObject)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetNode'
type FullNode_ChainGetNode_Call struct {
	*mock.Call
}

// ChainGetNode is a helper method to define mock.On call
//   - ctx
//   - p
func (_e *FullNode_Expecter) ChainGetNode(ctx interface{}, p interface{}) *FullNode_ChainGetNode_Call {
	return &FullNode_ChainGetNode_Call{Call: _e.mock.On("ChainGetNode", ctx, p)}
}

func (_c *FullNode_ChainGetNode_Call) Run(run func(ctx context.Context, p string)) *FullNode_ChainGetNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_ChainGetNode_Call) Return(ipldObject *api.IpldObject, err error) *FullNode_ChainGetNode_Call {
	_c.Call.Return(ipldObject, err)
	return _c
}

func (_c *FullNode_ChainGetNode_Call) RunAndReturn(run func(ctx context.Context, p string) (*api.IpldObject, error)) *FullNode_ChainGetNode_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetParentMessages provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetParentMessages(ctx context.Context, blockCid cid.Cid) ([]api.Message, error) {
	ret := _mock.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetParentMessages")
	}

	var r0 []api.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]api.Message, error)); ok {
		return returnFunc(ctx, blockCid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.Message); ok {
		r0 = returnFunc(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetParentMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetParentMessages'
type FullNode_ChainGetParentMessages_Call struct {
	*mock.Call
}

// ChainGetParentMessages is a helper method to define mock.On call
//   - ctx
//   - blockCid
func (_e *FullNode_Expecter) ChainGetParentMessages(ctx interface{}, blockCid interface{}) *FullNode_ChainGetParentMessages_Call {
	return &FullNode_ChainGetParentMessages_Call{Call: _e.mock.On("ChainGetParentMessages", ctx, blockCid)}
}

func (_c *FullNode_ChainGetParentMessages_Call) Run(run func(ctx context.Context, blockCid cid.Cid)) *FullNode_ChainGetParentMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetParentMessages_Call) Return(messages []api.Message, err error) *FullNode_ChainGetParentMessages_Call {
	_c.Call.Return(messages, err)
	return _c
}

func (_c *FullNode_ChainGetParentMessages_Call) RunAndReturn(run func(ctx context.Context, blockCid cid.Cid) ([]api.Message, error)) *FullNode_ChainGetParentMessages_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetParentReceipts provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetParentReceipts(ctx context.Context, blockCid cid.Cid) ([]*types.MessageReceipt, error) {
	ret := _mock.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetParentReceipts")
	}

	var r0 []*types.MessageReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]*types.MessageReceipt, error)); ok {
		return returnFunc(ctx, blockCid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) []*types.MessageReceipt); ok {
		r0 = returnFunc(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.MessageReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetParentReceipts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetParentReceipts'
type FullNode_ChainGetParentReceipts_Call struct {
	*mock.Call
}

// ChainGetParentReceipts is a helper method to define mock.On call
//   - ctx
//   - blockCid
func (_e *FullNode_Expecter) ChainGetParentReceipts(ctx interface{}, blockCid interface{}) *FullNode_ChainGetParentReceipts_Call {
	return &FullNode_ChainGetParentReceipts_Call{Call: _e.mock.On("ChainGetParentReceipts", ctx, blockCid)}
}

func (_c *FullNode_ChainGetParentReceipts_Call) Run(run func(ctx context.Context, blockCid cid.Cid)) *FullNode_ChainGetParentReceipts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainGetParentReceipts_Call) Return(messageReceipts []*types.MessageReceipt, err error) *FullNode_ChainGetParentReceipts_Call {
	_c.Call.Return(messageReceipts, err)
	return _c
}

func (_c *FullNode_ChainGetParentReceipts_Call) RunAndReturn(run func(ctx context.Context, blockCid cid.Cid) ([]*types.MessageReceipt, error)) *FullNode_ChainGetParentReceipts_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetPath provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetPath(ctx context.Context, from types.TipSetKey, to types.TipSetKey) ([]*api.HeadChange, error) {
	ret := _mock.Called(ctx, from, to)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetPath")
	}

	var r0 []*api.HeadChange
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey) ([]*api.HeadChange, error)); ok {
		return returnFunc(ctx, from, to)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey) []*api.HeadChange); ok {
		r0 = returnFunc(ctx, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.HeadChange)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, from, to)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetPath'
type FullNode_ChainGetPath_Call struct {
	*mock.Call
}

// ChainGetPath is a helper method to define mock.On call
//   - ctx
//   - from
//   - to
func (_e *FullNode_Expecter) ChainGetPath(ctx interface{}, from interface{}, to interface{}) *FullNode_ChainGetPath_Call {
	return &FullNode_ChainGetPath_Call{Call: _e.mock.On("ChainGetPath", ctx, from, to)}
}

func (_c *FullNode_ChainGetPath_Call) Run(run func(ctx context.Context, from types.TipSetKey, to types.TipSetKey)) *FullNode_ChainGetPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainGetPath_Call) Return(headChanges []*api.HeadChange, err error) *FullNode_ChainGetPath_Call {
	_c.Call.Return(headChanges, err)
	return _c
}

func (_c *FullNode_ChainGetPath_Call) RunAndReturn(run func(ctx context.Context, from types.TipSetKey, to types.TipSetKey) ([]*api.HeadChange, error)) *FullNode_ChainGetPath_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetTipSet provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetTipSet(context1 context.Context, tipSetKey types.TipSetKey) (*types.TipSet, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSet")
	}

	var r0 *types.TipSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (*types.TipSet, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) *types.TipSet); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetTipSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetTipSet'
type FullNode_ChainGetTipSet_Call struct {
	*mock.Call
}

// ChainGetTipSet is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) ChainGetTipSet(context1 interface{}, tipSetKey interface{}) *FullNode_ChainGetTipSet_Call {
	return &FullNode_ChainGetTipSet_Call{Call: _e.mock.On("ChainGetTipSet", context1, tipSetKey)}
}

func (_c *FullNode_ChainGetTipSet_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_ChainGetTipSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainGetTipSet_Call) Return(tipSet *types.TipSet, err error) *FullNode_ChainGetTipSet_Call {
	_c.Call.Return(tipSet, err)
	return _c
}

func (_c *FullNode_ChainGetTipSet_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (*types.TipSet, error)) *FullNode_ChainGetTipSet_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetTipSetAfterHeight provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetTipSetAfterHeight(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*types.TipSet, error) {
	ret := _mock.Called(context1, chainEpoch, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSetAfterHeight")
	}

	var r0 *types.TipSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (*types.TipSet, error)); ok {
		return returnFunc(context1, chainEpoch, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) *types.TipSet); ok {
		r0 = returnFunc(context1, chainEpoch, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, chainEpoch, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetTipSetAfterHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetTipSetAfterHeight'
type FullNode_ChainGetTipSetAfterHeight_Call struct {
	*mock.Call
}

// ChainGetTipSetAfterHeight is a helper method to define mock.On call
//   - context1
//   - chainEpoch
//   - tipSetKey
func (_e *FullNode_Expecter) ChainGetTipSetAfterHeight(context1 interface{}, chainEpoch interface{}, tipSetKey interface{}) *FullNode_ChainGetTipSetAfterHeight_Call {
	return &FullNode_ChainGetTipSetAfterHeight_Call{Call: _e.mock.On("ChainGetTipSetAfterHeight", context1, chainEpoch, tipSetKey)}
}

func (_c *FullNode_ChainGetTipSetAfterHeight_Call) Run(run func(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey)) *FullNode_ChainGetTipSetAfterHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainGetTipSetAfterHeight_Call) Return(tipSet *types.TipSet, err error) *FullNode_ChainGetTipSetAfterHeight_Call {
	_c.Call.Return(tipSet, err)
	return _c
}

func (_c *FullNode_ChainGetTipSetAfterHeight_Call) RunAndReturn(run func(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*types.TipSet, error)) *FullNode_ChainGetTipSetAfterHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetTipSetByHeight provides a mock function for the type FullNode
func (_mock *FullNode) ChainGetTipSetByHeight(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*types.TipSet, error) {
	ret := _mock.Called(context1, chainEpoch, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSetByHeight")
	}

	var r0 *types.TipSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (*types.TipSet, error)); ok {
		return returnFunc(context1, chainEpoch, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) *types.TipSet); ok {
		r0 = returnFunc(context1, chainEpoch, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, chainEpoch, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainGetTipSetByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetTipSetByHeight'
type FullNode_ChainGetTipSetByHeight_Call struct {
	*mock.Call
}

// ChainGetTipSetByHeight is a helper method to define mock.On call
//   - context1
//   - chainEpoch
//   - tipSetKey
func (_e *FullNode_Expecter) ChainGetTipSetByHeight(context1 interface{}, chainEpoch interface{}, tipSetKey interface{}) *FullNode_ChainGetTipSetByHeight_Call {
	return &FullNode_ChainGetTipSetByHeight_Call{Call: _e.mock.On("ChainGetTipSetByHeight", context1, chainEpoch, tipSetKey)}
}

func (_c *FullNode_ChainGetTipSetByHeight_Call) Run(run func(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey)) *FullNode_ChainGetTipSetByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainGetTipSetByHeight_Call) Return(tipSet *types.TipSet, err error) *FullNode_ChainGetTipSetByHeight_Call {
	_c.Call.Return(tipSet, err)
	return _c
}

func (_c *FullNode_ChainGetTipSetByHeight_Call) RunAndReturn(run func(context1 context.Context, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*types.TipSet, error)) *FullNode_ChainGetTipSetByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHasObj provides a mock function for the type FullNode
func (_mock *FullNode) ChainHasObj(context1 context.Context, cid1 cid.Cid) (bool, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainHasObj")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (bool, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) bool); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainHasObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHasObj'
type FullNode_ChainHasObj_Call struct {
	*mock.Call
}

// ChainHasObj is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainHasObj(context1 interface{}, cid1 interface{}) *FullNode_ChainHasObj_Call {
	return &FullNode_ChainHasObj_Call{Call: _e.mock.On("ChainHasObj", context1, cid1)}
}

func (_c *FullNode_ChainHasObj_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainHasObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainHasObj_Call) Return(b bool, err error) *FullNode_ChainHasObj_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_ChainHasObj_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) (bool, error)) *FullNode_ChainHasObj_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHead provides a mock function for the type FullNode
func (_mock *FullNode) ChainHead(context1 context.Context) (*types.TipSet, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ChainHead")
	}

	var r0 *types.TipSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*types.TipSet, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainHead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHead'
type FullNode_ChainHead_Call struct {
	*mock.Call
}

// ChainHead is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ChainHead(context1 interface{}) *FullNode_ChainHead_Call {
	return &FullNode_ChainHead_Call{Call: _e.mock.On("ChainHead", context1)}
}

func (_c *FullNode_ChainHead_Call) Run(run func(context1 context.Context)) *FullNode_ChainHead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ChainHead_Call) Return(tipSet *types.TipSet, err error) *FullNode_ChainHead_Call {
	_c.Call.Return(tipSet, err)
	return _c
}

func (_c *FullNode_ChainHead_Call) RunAndReturn(run func(context1 context.Context) (*types.TipSet, error)) *FullNode_ChainHead_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHotGC provides a mock function for the type FullNode
func (_mock *FullNode) ChainHotGC(ctx context.Context, opts api.HotGCOpts) error {
	ret := _mock.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ChainHotGC")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.HotGCOpts) error); ok {
		r0 = returnFunc(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainHotGC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHotGC'
type FullNode_ChainHotGC_Call struct {
	*mock.Call
}

// ChainHotGC is a helper method to define mock.On call
//   - ctx
//   - opts
func (_e *FullNode_Expecter) ChainHotGC(ctx interface{}, opts interface{}) *FullNode_ChainHotGC_Call {
	return &FullNode_ChainHotGC_Call{Call: _e.mock.On("ChainHotGC", ctx, opts)}
}

func (_c *FullNode_ChainHotGC_Call) Run(run func(ctx context.Context, opts api.HotGCOpts)) *FullNode_ChainHotGC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(api.HotGCOpts))
	})
	return _c
}

func (_c *FullNode_ChainHotGC_Call) Return(err error) *FullNode_ChainHotGC_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainHotGC_Call) RunAndReturn(run func(ctx context.Context, opts api.HotGCOpts) error) *FullNode_ChainHotGC_Call {
	_c.Call.Return(run)
	return _c
}

// ChainNotify provides a mock function for the type FullNode
func (_mock *FullNode) ChainNotify(context1 context.Context) (<-chan []*api.HeadChange, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ChainNotify")
	}

	var r0 <-chan []*api.HeadChange
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan []*api.HeadChange, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan []*api.HeadChange); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []*api.HeadChange)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainNotify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainNotify'
type FullNode_ChainNotify_Call struct {
	*mock.Call
}

// ChainNotify is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ChainNotify(context1 interface{}) *FullNode_ChainNotify_Call {
	return &FullNode_ChainNotify_Call{Call: _e.mock.On("ChainNotify", context1)}
}

func (_c *FullNode_ChainNotify_Call) Run(run func(context1 context.Context)) *FullNode_ChainNotify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ChainNotify_Call) Return(headChangesCh <-chan []*api.HeadChange, err error) *FullNode_ChainNotify_Call {
	_c.Call.Return(headChangesCh, err)
	return _c
}

func (_c *FullNode_ChainNotify_Call) RunAndReturn(run func(context1 context.Context) (<-chan []*api.HeadChange, error)) *FullNode_ChainNotify_Call {
	_c.Call.Return(run)
	return _c
}

// ChainPrune provides a mock function for the type FullNode
func (_mock *FullNode) ChainPrune(ctx context.Context, opts api.PruneOpts) error {
	ret := _mock.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ChainPrune")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.PruneOpts) error); ok {
		r0 = returnFunc(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainPrune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainPrune'
type FullNode_ChainPrune_Call struct {
	*mock.Call
}

// ChainPrune is a helper method to define mock.On call
//   - ctx
//   - opts
func (_e *FullNode_Expecter) ChainPrune(ctx interface{}, opts interface{}) *FullNode_ChainPrune_Call {
	return &FullNode_ChainPrune_Call{Call: _e.mock.On("ChainPrune", ctx, opts)}
}

func (_c *FullNode_ChainPrune_Call) Run(run func(ctx context.Context, opts api.PruneOpts)) *FullNode_ChainPrune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(api.PruneOpts))
	})
	return _c
}

func (_c *FullNode_ChainPrune_Call) Return(err error) *FullNode_ChainPrune_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainPrune_Call) RunAndReturn(run func(ctx context.Context, opts api.PruneOpts) error) *FullNode_ChainPrune_Call {
	_c.Call.Return(run)
	return _c
}

// ChainPutObj provides a mock function for the type FullNode
func (_mock *FullNode) ChainPutObj(context1 context.Context, block blocks.Block) error {
	ret := _mock.Called(context1, block)

	if len(ret) == 0 {
		panic("no return value specified for ChainPutObj")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, blocks.Block) error); ok {
		r0 = returnFunc(context1, block)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainPutObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainPutObj'
type FullNode_ChainPutObj_Call struct {
	*mock.Call
}

// ChainPutObj is a helper method to define mock.On call
//   - context1
//   - block
func (_e *FullNode_Expecter) ChainPutObj(context1 interface{}, block interface{}) *FullNode_ChainPutObj_Call {
	return &FullNode_ChainPutObj_Call{Call: _e.mock.On("ChainPutObj", context1, block)}
}

func (_c *FullNode_ChainPutObj_Call) Run(run func(context1 context.Context, block blocks.Block)) *FullNode_ChainPutObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(blocks.Block))
	})
	return _c
}

func (_c *FullNode_ChainPutObj_Call) Return(err error) *FullNode_ChainPutObj_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainPutObj_Call) RunAndReturn(run func(context1 context.Context, block blocks.Block) error) *FullNode_ChainPutObj_Call {
	_c.Call.Return(run)
	return _c
}

// ChainReadObj provides a mock function for the type FullNode
func (_mock *FullNode) ChainReadObj(context1 context.Context, cid1 cid.Cid) ([]byte, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for ChainReadObj")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]byte, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) []byte); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainReadObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainReadObj'
type FullNode_ChainReadObj_Call struct {
	*mock.Call
}

// ChainReadObj is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) ChainReadObj(context1 interface{}, cid1 interface{}) *FullNode_ChainReadObj_Call {
	return &FullNode_ChainReadObj_Call{Call: _e.mock.On("ChainReadObj", context1, cid1)}
}

func (_c *FullNode_ChainReadObj_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_ChainReadObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainReadObj_Call) Return(bytes []byte, err error) *FullNode_ChainReadObj_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *FullNode_ChainReadObj_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) ([]byte, error)) *FullNode_ChainReadObj_Call {
	_c.Call.Return(run)
	return _c
}

// ChainSetHead provides a mock function for the type FullNode
func (_mock *FullNode) ChainSetHead(context1 context.Context, tipSetKey types.TipSetKey) error {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for ChainSetHead")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) error); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_ChainSetHead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainSetHead'
type FullNode_ChainSetHead_Call struct {
	*mock.Call
}

// ChainSetHead is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) ChainSetHead(context1 interface{}, tipSetKey interface{}) *FullNode_ChainSetHead_Call {
	return &FullNode_ChainSetHead_Call{Call: _e.mock.On("ChainSetHead", context1, tipSetKey)}
}

func (_c *FullNode_ChainSetHead_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_ChainSetHead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainSetHead_Call) Return(err error) *FullNode_ChainSetHead_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_ChainSetHead_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) error) *FullNode_ChainSetHead_Call {
	_c.Call.Return(run)
	return _c
}

// ChainStatObj provides a mock function for the type FullNode
func (_mock *FullNode) ChainStatObj(ctx context.Context, obj cid.Cid, base cid.Cid) (api.ObjStat, error) {
	ret := _mock.Called(ctx, obj, base)

	if len(ret) == 0 {
		panic("no return value specified for ChainStatObj")
	}

	var r0 api.ObjStat
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) (api.ObjStat, error)); ok {
		return returnFunc(ctx, obj, base)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) api.ObjStat); ok {
		r0 = returnFunc(ctx, obj, base)
	} else {
		r0 = ret.Get(0).(api.ObjStat)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = returnFunc(ctx, obj, base)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainStatObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainStatObj'
type FullNode_ChainStatObj_Call struct {
	*mock.Call
}

// ChainStatObj is a helper method to define mock.On call
//   - ctx
//   - obj
//   - base
func (_e *FullNode_Expecter) ChainStatObj(ctx interface{}, obj interface{}, base interface{}) *FullNode_ChainStatObj_Call {
	return &FullNode_ChainStatObj_Call{Call: _e.mock.On("ChainStatObj", ctx, obj, base)}
}

func (_c *FullNode_ChainStatObj_Call) Run(run func(ctx context.Context, obj cid.Cid, base cid.Cid)) *FullNode_ChainStatObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_ChainStatObj_Call) Return(objStat api.ObjStat, err error) *FullNode_ChainStatObj_Call {
	_c.Call.Return(objStat, err)
	return _c
}

func (_c *FullNode_ChainStatObj_Call) RunAndReturn(run func(ctx context.Context, obj cid.Cid, base cid.Cid) (api.ObjStat, error)) *FullNode_ChainStatObj_Call {
	_c.Call.Return(run)
	return _c
}

// ChainTipSetWeight provides a mock function for the type FullNode
func (_mock *FullNode) ChainTipSetWeight(context1 context.Context, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for ChainTipSetWeight")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainTipSetWeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainTipSetWeight'
type FullNode_ChainTipSetWeight_Call struct {
	*mock.Call
}

// ChainTipSetWeight is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) ChainTipSetWeight(context1 interface{}, tipSetKey interface{}) *FullNode_ChainTipSetWeight_Call {
	return &FullNode_ChainTipSetWeight_Call{Call: _e.mock.On("ChainTipSetWeight", context1, tipSetKey)}
}

func (_c *FullNode_ChainTipSetWeight_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_ChainTipSetWeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_ChainTipSetWeight_Call) Return(v types.BigInt, err error) *FullNode_ChainTipSetWeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_ChainTipSetWeight_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_ChainTipSetWeight_Call {
	_c.Call.Return(run)
	return _c
}

// ChainValidateIndex provides a mock function for the type FullNode
func (_mock *FullNode) ChainValidateIndex(ctx context.Context, epoch abi.ChainEpoch, backfill bool) (*types.IndexValidation, error) {
	ret := _mock.Called(ctx, epoch, backfill)

	if len(ret) == 0 {
		panic("no return value specified for ChainValidateIndex")
	}

	var r0 *types.IndexValidation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool) (*types.IndexValidation, error)); ok {
		return returnFunc(ctx, epoch, backfill)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool) *types.IndexValidation); ok {
		r0 = returnFunc(ctx, epoch, backfill)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.IndexValidation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, bool) error); ok {
		r1 = returnFunc(ctx, epoch, backfill)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ChainValidateIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainValidateIndex'
type FullNode_ChainValidateIndex_Call struct {
	*mock.Call
}

// ChainValidateIndex is a helper method to define mock.On call
//   - ctx
//   - epoch
//   - backfill
func (_e *FullNode_Expecter) ChainValidateIndex(ctx interface{}, epoch interface{}, backfill interface{}) *FullNode_ChainValidateIndex_Call {
	return &FullNode_ChainValidateIndex_Call{Call: _e.mock.On("ChainValidateIndex", ctx, epoch, backfill)}
}

func (_c *FullNode_ChainValidateIndex_Call) Run(run func(ctx context.Context, epoch abi.ChainEpoch, backfill bool)) *FullNode_ChainValidateIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(bool))
	})
	return _c
}

func (_c *FullNode_ChainValidateIndex_Call) Return(indexValidation *types.IndexValidation, err error) *FullNode_ChainValidateIndex_Call {
	_c.Call.Return(indexValidation, err)
	return _c
}

func (_c *FullNode_ChainValidateIndex_Call) RunAndReturn(run func(ctx context.Context, epoch abi.ChainEpoch, backfill bool) (*types.IndexValidation, error)) *FullNode_ChainValidateIndex_Call {
	_c.Call.Return(run)
	return _c
}

// Closing provides a mock function for the type FullNode
func (_mock *FullNode) Closing(context1 context.Context) (<-chan struct{}, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Closing")
	}

	var r0 <-chan struct{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan struct{}, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan struct{}); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_Closing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Closing'
type FullNode_Closing_Call struct {
	*mock.Call
}

// Closing is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) Closing(context1 interface{}) *FullNode_Closing_Call {
	return &FullNode_Closing_Call{Call: _e.mock.On("Closing", context1)}
}

func (_c *FullNode_Closing_Call) Run(run func(context1 context.Context)) *FullNode_Closing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Closing_Call) Return(valCh <-chan struct{}, err error) *FullNode_Closing_Call {
	_c.Call.Return(valCh, err)
	return _c
}

func (_c *FullNode_Closing_Call) RunAndReturn(run func(context1 context.Context) (<-chan struct{}, error)) *FullNode_Closing_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBackup provides a mock function for the type FullNode
func (_mock *FullNode) CreateBackup(ctx context.Context, fpath string) error {
	ret := _mock.Called(ctx, fpath)

	if len(ret) == 0 {
		panic("no return value specified for CreateBackup")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, fpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_CreateBackup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackup'
type FullNode_CreateBackup_Call struct {
	*mock.Call
}

// CreateBackup is a helper method to define mock.On call
//   - ctx
//   - fpath
func (_e *FullNode_Expecter) CreateBackup(ctx interface{}, fpath interface{}) *FullNode_CreateBackup_Call {
	return &FullNode_CreateBackup_Call{Call: _e.mock.On("CreateBackup", ctx, fpath)}
}

func (_c *FullNode_CreateBackup_Call) Run(run func(ctx context.Context, fpath string)) *FullNode_CreateBackup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_CreateBackup_Call) Return(err error) *FullNode_CreateBackup_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_CreateBackup_Call) RunAndReturn(run func(ctx context.Context, fpath string) error) *FullNode_CreateBackup_Call {
	_c.Call.Return(run)
	return _c
}

// Discover provides a mock function for the type FullNode
func (_mock *FullNode) Discover(ctx context.Context) (apitypes.OpenRPCDocument, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Discover")
	}

	var r0 apitypes.OpenRPCDocument
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (apitypes.OpenRPCDocument, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) apitypes.OpenRPCDocument); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(apitypes.OpenRPCDocument)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_Discover_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Discover'
type FullNode_Discover_Call struct {
	*mock.Call
}

// Discover is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) Discover(ctx interface{}) *FullNode_Discover_Call {
	return &FullNode_Discover_Call{Call: _e.mock.On("Discover", ctx)}
}

func (_c *FullNode_Discover_Call) Run(run func(ctx context.Context)) *FullNode_Discover_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Discover_Call) Return(openRPCDocument apitypes.OpenRPCDocument, err error) *FullNode_Discover_Call {
	_c.Call.Return(openRPCDocument, err)
	return _c
}

func (_c *FullNode_Discover_Call) RunAndReturn(run func(ctx context.Context) (apitypes.OpenRPCDocument, error)) *FullNode_Discover_Call {
	_c.Call.Return(run)
	return _c
}

// EthAccounts provides a mock function for the type FullNode
func (_mock *FullNode) EthAccounts(ctx context.Context) ([]ethtypes.EthAddress, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthAccounts")
	}

	var r0 []ethtypes.EthAddress
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]ethtypes.EthAddress, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []ethtypes.EthAddress); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ethtypes.EthAddress)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthAccounts'
type FullNode_EthAccounts_Call struct {
	*mock.Call
}

// EthAccounts is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthAccounts(ctx interface{}) *FullNode_EthAccounts_Call {
	return &FullNode_EthAccounts_Call{Call: _e.mock.On("EthAccounts", ctx)}
}

func (_c *FullNode_EthAccounts_Call) Run(run func(ctx context.Context)) *FullNode_EthAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthAccounts_Call) Return(ethAddresss []ethtypes.EthAddress, err error) *FullNode_EthAccounts_Call {
	_c.Call.Return(ethAddresss, err)
	return _c
}

func (_c *FullNode_EthAccounts_Call) RunAndReturn(run func(ctx context.Context) ([]ethtypes.EthAddress, error)) *FullNode_EthAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// EthAddressToFilecoinAddress provides a mock function for the type FullNode
func (_mock *FullNode) EthAddressToFilecoinAddress(ctx context.Context, ethAddress ethtypes.EthAddress) (address.Address, error) {
	ret := _mock.Called(ctx, ethAddress)

	if len(ret) == 0 {
		panic("no return value specified for EthAddressToFilecoinAddress")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress) (address.Address, error)); ok {
		return returnFunc(ctx, ethAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress) address.Address); ok {
		r0 = returnFunc(ctx, ethAddress)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress) error); ok {
		r1 = returnFunc(ctx, ethAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthAddressToFilecoinAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthAddressToFilecoinAddress'
type FullNode_EthAddressToFilecoinAddress_Call struct {
	*mock.Call
}

// EthAddressToFilecoinAddress is a helper method to define mock.On call
//   - ctx
//   - ethAddress
func (_e *FullNode_Expecter) EthAddressToFilecoinAddress(ctx interface{}, ethAddress interface{}) *FullNode_EthAddressToFilecoinAddress_Call {
	return &FullNode_EthAddressToFilecoinAddress_Call{Call: _e.mock.On("EthAddressToFilecoinAddress", ctx, ethAddress)}
}

func (_c *FullNode_EthAddressToFilecoinAddress_Call) Run(run func(ctx context.Context, ethAddress ethtypes.EthAddress)) *FullNode_EthAddressToFilecoinAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthAddress))
	})
	return _c
}

func (_c *FullNode_EthAddressToFilecoinAddress_Call) Return(address1 address.Address, err error) *FullNode_EthAddressToFilecoinAddress_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_EthAddressToFilecoinAddress_Call) RunAndReturn(run func(ctx context.Context, ethAddress ethtypes.EthAddress) (address.Address, error)) *FullNode_EthAddressToFilecoinAddress_Call {
	_c.Call.Return(run)
	return _c
}

// EthBlockNumber provides a mock function for the type FullNode
func (_mock *FullNode) EthBlockNumber(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthBlockNumber")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthBlockNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthBlockNumber'
type FullNode_EthBlockNumber_Call struct {
	*mock.Call
}

// EthBlockNumber is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthBlockNumber(ctx interface{}) *FullNode_EthBlockNumber_Call {
	return &FullNode_EthBlockNumber_Call{Call: _e.mock.On("EthBlockNumber", ctx)}
}

func (_c *FullNode_EthBlockNumber_Call) Run(run func(ctx context.Context)) *FullNode_EthBlockNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthBlockNumber_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthBlockNumber_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthBlockNumber_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthUint64, error)) *FullNode_EthBlockNumber_Call {
	_c.Call.Return(run)
	return _c
}

// EthCall provides a mock function for the type FullNode
func (_mock *FullNode) EthCall(ctx context.Context, tx ethtypes.EthCall, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _mock.Called(ctx, tx, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthCall")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return returnFunc(ctx, tx, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = returnFunc(ctx, tx, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, tx, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthCall'
type FullNode_EthCall_Call struct {
	*mock.Call
}

// EthCall is a helper method to define mock.On call
//   - ctx
//   - tx
//   - blkParam
func (_e *FullNode_Expecter) EthCall(ctx interface{}, tx interface{}, blkParam interface{}) *FullNode_EthCall_Call {
	return &FullNode_EthCall_Call{Call: _e.mock.On("EthCall", ctx, tx, blkParam)}
}

func (_c *FullNode_EthCall_Call) Run(run func(ctx context.Context, tx ethtypes.EthCall, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthCall), args[2].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthCall_Call) Return(ethBytes ethtypes.EthBytes, err error) *FullNode_EthCall_Call {
	_c.Call.Return(ethBytes, err)
	return _c
}

func (_c *FullNode_EthCall_Call) RunAndReturn(run func(ctx context.Context, tx ethtypes.EthCall, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)) *FullNode_EthCall_Call {
	_c.Call.Return(run)
	return _c
}

// EthChainId provides a mock function for the type FullNode
func (_mock *FullNode) EthChainId(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthChainId")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthChainId'
type FullNode_EthChainId_Call struct {
	*mock.Call
}

// EthChainId is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthChainId(ctx interface{}) *FullNode_EthChainId_Call {
	return &FullNode_EthChainId_Call{Call: _e.mock.On("EthChainId", ctx)}
}

func (_c *FullNode_EthChainId_Call) Run(run func(ctx context.Context)) *FullNode_EthChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthChainId_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthChainId_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthChainId_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthUint64, error)) *FullNode_EthChainId_Call {
	_c.Call.Return(run)
	return _c
}

// EthEstimateGas provides a mock function for the type FullNode
func (_mock *FullNode) EthEstimateGas(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for EthEstimateGas")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx, p)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx, p)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = returnFunc(ctx, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthEstimateGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthEstimateGas'
type FullNode_EthEstimateGas_Call struct {
	*mock.Call
}

// EthEstimateGas is a helper method to define mock.On call
//   - ctx
//   - p
func (_e *FullNode_Expecter) EthEstimateGas(ctx interface{}, p interface{}) *FullNode_EthEstimateGas_Call {
	return &FullNode_EthEstimateGas_Call{Call: _e.mock.On("EthEstimateGas", ctx, p)}
}

func (_c *FullNode_EthEstimateGas_Call) Run(run func(ctx context.Context, p jsonrpc.RawParams)) *FullNode_EthEstimateGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jsonrpc.RawParams))
	})
	return _c
}

func (_c *FullNode_EthEstimateGas_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthEstimateGas_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthEstimateGas_Call) RunAndReturn(run func(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthUint64, error)) *FullNode_EthEstimateGas_Call {
	_c.Call.Return(run)
	return _c
}

// EthFeeHistory provides a mock function for the type FullNode
func (_mock *FullNode) EthFeeHistory(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthFeeHistory, error) {
	ret := _mock.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for EthFeeHistory")
	}

	var r0 ethtypes.EthFeeHistory
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthFeeHistory, error)); ok {
		return returnFunc(ctx, p)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthFeeHistory); ok {
		r0 = returnFunc(ctx, p)
	} else {
		r0 = ret.Get(0).(ethtypes.EthFeeHistory)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = returnFunc(ctx, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthFeeHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthFeeHistory'
type FullNode_EthFeeHistory_Call struct {
	*mock.Call
}

// EthFeeHistory is a helper method to define mock.On call
//   - ctx
//   - p
func (_e *FullNode_Expecter) EthFeeHistory(ctx interface{}, p interface{}) *FullNode_EthFeeHistory_Call {
	return &FullNode_EthFeeHistory_Call{Call: _e.mock.On("EthFeeHistory", ctx, p)}
}

func (_c *FullNode_EthFeeHistory_Call) Run(run func(ctx context.Context, p jsonrpc.RawParams)) *FullNode_EthFeeHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jsonrpc.RawParams))
	})
	return _c
}

func (_c *FullNode_EthFeeHistory_Call) Return(ethFeeHistory ethtypes.EthFeeHistory, err error) *FullNode_EthFeeHistory_Call {
	_c.Call.Return(ethFeeHistory, err)
	return _c
}

func (_c *FullNode_EthFeeHistory_Call) RunAndReturn(run func(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthFeeHistory, error)) *FullNode_EthFeeHistory_Call {
	_c.Call.Return(run)
	return _c
}

// EthGasPrice provides a mock function for the type FullNode
func (_mock *FullNode) EthGasPrice(ctx context.Context) (ethtypes.EthBigInt, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthGasPrice")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthBigInt, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthBigInt); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGasPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGasPrice'
type FullNode_EthGasPrice_Call struct {
	*mock.Call
}

// EthGasPrice is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthGasPrice(ctx interface{}) *FullNode_EthGasPrice_Call {
	return &FullNode_EthGasPrice_Call{Call: _e.mock.On("EthGasPrice", ctx)}
}

func (_c *FullNode_EthGasPrice_Call) Run(run func(ctx context.Context)) *FullNode_EthGasPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthGasPrice_Call) Return(ethBigInt ethtypes.EthBigInt, err error) *FullNode_EthGasPrice_Call {
	_c.Call.Return(ethBigInt, err)
	return _c
}

func (_c *FullNode_EthGasPrice_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthBigInt, error)) *FullNode_EthGasPrice_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBalance provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBalance(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBigInt, error) {
	ret := _mock.Called(ctx, address1, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBalance")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBigInt, error)); ok {
		return returnFunc(ctx, address1, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthBigInt); ok {
		r0 = returnFunc(ctx, address1, blkParam)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, address1, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBalance'
type FullNode_EthGetBalance_Call struct {
	*mock.Call
}

// EthGetBalance is a helper method to define mock.On call
//   - ctx
//   - address1
//   - blkParam
func (_e *FullNode_Expecter) EthGetBalance(ctx interface{}, address1 interface{}, blkParam interface{}) *FullNode_EthGetBalance_Call {
	return &FullNode_EthGetBalance_Call{Call: _e.mock.On("EthGetBalance", ctx, address1, blkParam)}
}

func (_c *FullNode_EthGetBalance_Call) Run(run func(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthGetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthAddress), args[2].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthGetBalance_Call) Return(ethBigInt ethtypes.EthBigInt, err error) *FullNode_EthGetBalance_Call {
	_c.Call.Return(ethBigInt, err)
	return _c
}

func (_c *FullNode_EthGetBalance_Call) RunAndReturn(run func(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBigInt, error)) *FullNode_EthGetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockByHash provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockByHash(ctx context.Context, blkHash ethtypes.EthHash, fullTxInfo bool) (ethtypes.EthBlock, error) {
	ret := _mock.Called(ctx, blkHash, fullTxInfo)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockByHash")
	}

	var r0 ethtypes.EthBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, bool) (ethtypes.EthBlock, error)); ok {
		return returnFunc(ctx, blkHash, fullTxInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, bool) ethtypes.EthBlock); ok {
		r0 = returnFunc(ctx, blkHash, fullTxInfo)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBlock)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, bool) error); ok {
		r1 = returnFunc(ctx, blkHash, fullTxInfo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockByHash'
type FullNode_EthGetBlockByHash_Call struct {
	*mock.Call
}

// EthGetBlockByHash is a helper method to define mock.On call
//   - ctx
//   - blkHash
//   - fullTxInfo
func (_e *FullNode_Expecter) EthGetBlockByHash(ctx interface{}, blkHash interface{}, fullTxInfo interface{}) *FullNode_EthGetBlockByHash_Call {
	return &FullNode_EthGetBlockByHash_Call{Call: _e.mock.On("EthGetBlockByHash", ctx, blkHash, fullTxInfo)}
}

func (_c *FullNode_EthGetBlockByHash_Call) Run(run func(ctx context.Context, blkHash ethtypes.EthHash, fullTxInfo bool)) *FullNode_EthGetBlockByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthHash), args[2].(bool))
	})
	return _c
}

func (_c *FullNode_EthGetBlockByHash_Call) Return(ethBlock ethtypes.EthBlock, err error) *FullNode_EthGetBlockByHash_Call {
	_c.Call.Return(ethBlock, err)
	return _c
}

func (_c *FullNode_EthGetBlockByHash_Call) RunAndReturn(run func(ctx context.Context, blkHash ethtypes.EthHash, fullTxInfo bool) (ethtypes.EthBlock, error)) *FullNode_EthGetBlockByHash_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockByNumber provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockByNumber(ctx context.Context, blkNum string, fullTxInfo bool) (ethtypes.EthBlock, error) {
	ret := _mock.Called(ctx, blkNum, fullTxInfo)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockByNumber")
	}

	var r0 ethtypes.EthBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) (ethtypes.EthBlock, error)); ok {
		return returnFunc(ctx, blkNum, fullTxInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) ethtypes.EthBlock); ok {
		r0 = returnFunc(ctx, blkNum, fullTxInfo)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBlock)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = returnFunc(ctx, blkNum, fullTxInfo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockByNumber'
type FullNode_EthGetBlockByNumber_Call struct {
	*mock.Call
}

// EthGetBlockByNumber is a helper method to define mock.On call
//   - ctx
//   - blkNum
//   - fullTxInfo
func (_e *FullNode_Expecter) EthGetBlockByNumber(ctx interface{}, blkNum interface{}, fullTxInfo interface{}) *FullNode_EthGetBlockByNumber_Call {
	return &FullNode_EthGetBlockByNumber_Call{Call: _e.mock.On("EthGetBlockByNumber", ctx, blkNum, fullTxInfo)}
}

func (_c *FullNode_EthGetBlockByNumber_Call) Run(run func(ctx context.Context, blkNum string, fullTxInfo bool)) *FullNode_EthGetBlockByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *FullNode_EthGetBlockByNumber_Call) Return(ethBlock ethtypes.EthBlock, err error) *FullNode_EthGetBlockByNumber_Call {
	_c.Call.Return(ethBlock, err)
	return _c
}

func (_c *FullNode_EthGetBlockByNumber_Call) RunAndReturn(run func(ctx context.Context, blkNum string, fullTxInfo bool) (ethtypes.EthBlock, error)) *FullNode_EthGetBlockByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockReceipts provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockReceipts(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash) ([]*api.EthTxReceipt, error) {
	ret := _mock.Called(ctx, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockReceipts")
	}

	var r0 []*api.EthTxReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash) ([]*api.EthTxReceipt, error)); ok {
		return returnFunc(ctx, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash) []*api.EthTxReceipt); ok {
		r0 = returnFunc(ctx, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.EthTxReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockReceipts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockReceipts'
type FullNode_EthGetBlockReceipts_Call struct {
	*mock.Call
}

// EthGetBlockReceipts is a helper method to define mock.On call
//   - ctx
//   - blkParam
func (_e *FullNode_Expecter) EthGetBlockReceipts(ctx interface{}, blkParam interface{}) *FullNode_EthGetBlockReceipts_Call {
	return &FullNode_EthGetBlockReceipts_Call{Call: _e.mock.On("EthGetBlockReceipts", ctx, blkParam)}
}

func (_c *FullNode_EthGetBlockReceipts_Call) Run(run func(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthGetBlockReceipts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthGetBlockReceipts_Call) Return(ethTxReceipts []*api.EthTxReceipt, err error) *FullNode_EthGetBlockReceipts_Call {
	_c.Call.Return(ethTxReceipts, err)
	return _c
}

func (_c *FullNode_EthGetBlockReceipts_Call) RunAndReturn(run func(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash) ([]*api.EthTxReceipt, error)) *FullNode_EthGetBlockReceipts_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockReceiptsLimited provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockReceiptsLimited(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash, limit abi.ChainEpoch) ([]*api.EthTxReceipt, error) {
	ret := _mock.Called(ctx, blkParam, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockReceiptsLimited")
	}

	var r0 []*api.EthTxReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) ([]*api.EthTxReceipt, error)); ok {
		return returnFunc(ctx, blkParam, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) []*api.EthTxReceipt); ok {
		r0 = returnFunc(ctx, blkParam, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.EthTxReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) error); ok {
		r1 = returnFunc(ctx, blkParam, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockReceiptsLimited_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockReceiptsLimited'
type FullNode_EthGetBlockReceiptsLimited_Call struct {
	*mock.Call
}

// EthGetBlockReceiptsLimited is a helper method to define mock.On call
//   - ctx
//   - blkParam
//   - limit
func (_e *FullNode_Expecter) EthGetBlockReceiptsLimited(ctx interface{}, blkParam interface{}, limit interface{}) *FullNode_EthGetBlockReceiptsLimited_Call {
	return &FullNode_EthGetBlockReceiptsLimited_Call{Call: _e.mock.On("EthGetBlockReceiptsLimited", ctx, blkParam, limit)}
}

func (_c *FullNode_EthGetBlockReceiptsLimited_Call) Run(run func(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash, limit abi.ChainEpoch)) *FullNode_EthGetBlockReceiptsLimited_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthBlockNumberOrHash), args[2].(abi.ChainEpoch))
	})
	return _c
}

func (_c *FullNode_EthGetBlockReceiptsLimited_Call) Return(ethTxReceipts []*api.EthTxReceipt, err error) *FullNode_EthGetBlockReceiptsLimited_Call {
	_c.Call.Return(ethTxReceipts, err)
	return _c
}

func (_c *FullNode_EthGetBlockReceiptsLimited_Call) RunAndReturn(run func(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash, limit abi.ChainEpoch) ([]*api.EthTxReceipt, error)) *FullNode_EthGetBlockReceiptsLimited_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockTransactionCountByHash provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockTransactionCountByHash(ctx context.Context, blkHash ethtypes.EthHash) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx, blkHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockTransactionCountByHash")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx, blkHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx, blkHash)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash) error); ok {
		r1 = returnFunc(ctx, blkHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockTransactionCountByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockTransactionCountByHash'
type FullNode_EthGetBlockTransactionCountByHash_Call struct {
	*mock.Call
}

// EthGetBlockTransactionCountByHash is a helper method to define mock.On call
//   - ctx
//   - blkHash
func (_e *FullNode_Expecter) EthGetBlockTransactionCountByHash(ctx interface{}, blkHash interface{}) *FullNode_EthGetBlockTransactionCountByHash_Call {
	return &FullNode_EthGetBlockTransactionCountByHash_Call{Call: _e.mock.On("EthGetBlockTransactionCountByHash", ctx, blkHash)}
}

func (_c *FullNode_EthGetBlockTransactionCountByHash_Call) Run(run func(ctx context.Context, blkHash ethtypes.EthHash)) *FullNode_EthGetBlockTransactionCountByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthHash))
	})
	return _c
}

func (_c *FullNode_EthGetBlockTransactionCountByHash_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthGetBlockTransactionCountByHash_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthGetBlockTransactionCountByHash_Call) RunAndReturn(run func(ctx context.Context, blkHash ethtypes.EthHash) (ethtypes.EthUint64, error)) *FullNode_EthGetBlockTransactionCountByHash_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetBlockTransactionCountByNumber provides a mock function for the type FullNode
func (_mock *FullNode) EthGetBlockTransactionCountByNumber(ctx context.Context, blkNum ethtypes.EthUint64) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx, blkNum)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockTransactionCountByNumber")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthUint64) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx, blkNum)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthUint64) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx, blkNum)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthUint64) error); ok {
		r1 = returnFunc(ctx, blkNum)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetBlockTransactionCountByNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetBlockTransactionCountByNumber'
type FullNode_EthGetBlockTransactionCountByNumber_Call struct {
	*mock.Call
}

// EthGetBlockTransactionCountByNumber is a helper method to define mock.On call
//   - ctx
//   - blkNum
func (_e *FullNode_Expecter) EthGetBlockTransactionCountByNumber(ctx interface{}, blkNum interface{}) *FullNode_EthGetBlockTransactionCountByNumber_Call {
	return &FullNode_EthGetBlockTransactionCountByNumber_Call{Call: _e.mock.On("EthGetBlockTransactionCountByNumber", ctx, blkNum)}
}

func (_c *FullNode_EthGetBlockTransactionCountByNumber_Call) Run(run func(ctx context.Context, blkNum ethtypes.EthUint64)) *FullNode_EthGetBlockTransactionCountByNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthUint64))
	})
	return _c
}

func (_c *FullNode_EthGetBlockTransactionCountByNumber_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthGetBlockTransactionCountByNumber_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthGetBlockTransactionCountByNumber_Call) RunAndReturn(run func(ctx context.Context, blkNum ethtypes.EthUint64) (ethtypes.EthUint64, error)) *FullNode_EthGetBlockTransactionCountByNumber_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetCode provides a mock function for the type FullNode
func (_mock *FullNode) EthGetCode(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _mock.Called(ctx, address1, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetCode")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return returnFunc(ctx, address1, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = returnFunc(ctx, address1, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, address1, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetCode'
type FullNode_EthGetCode_Call struct {
	*mock.Call
}

// EthGetCode is a helper method to define mock.On call
//   - ctx
//   - address1
//   - blkParam
func (_e *FullNode_Expecter) EthGetCode(ctx interface{}, address1 interface{}, blkParam interface{}) *FullNode_EthGetCode_Call {
	return &FullNode_EthGetCode_Call{Call: _e.mock.On("EthGetCode", ctx, address1, blkParam)}
}

func (_c *FullNode_EthGetCode_Call) Run(run func(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthGetCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthAddress), args[2].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthGetCode_Call) Return(ethBytes ethtypes.EthBytes, err error) *FullNode_EthGetCode_Call {
	_c.Call.Return(ethBytes, err)
	return _c
}

func (_c *FullNode_EthGetCode_Call) RunAndReturn(run func(ctx context.Context, address1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)) *FullNode_EthGetCode_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetFilterChanges provides a mock function for the type FullNode
func (_mock *FullNode) EthGetFilterChanges(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthGetFilterChanges")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) *ethtypes.EthFilterResult); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetFilterChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetFilterChanges'
type FullNode_EthGetFilterChanges_Call struct {
	*mock.Call
}

// EthGetFilterChanges is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *FullNode_Expecter) EthGetFilterChanges(ctx interface{}, id interface{}) *FullNode_EthGetFilterChanges_Call {
	return &FullNode_EthGetFilterChanges_Call{Call: _e.mock.On("EthGetFilterChanges", ctx, id)}
}

func (_c *FullNode_EthGetFilterChanges_Call) Run(run func(ctx context.Context, id ethtypes.EthFilterID)) *FullNode_EthGetFilterChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthFilterID))
	})
	return _c
}

func (_c *FullNode_EthGetFilterChanges_Call) Return(ethFilterResult *ethtypes.EthFilterResult, err error) *FullNode_EthGetFilterChanges_Call {
	_c.Call.Return(ethFilterResult, err)
	return _c
}

func (_c *FullNode_EthGetFilterChanges_Call) RunAndReturn(run func(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)) *FullNode_EthGetFilterChanges_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetFilterLogs provides a mock function for the type FullNode
func (_mock *FullNode) EthGetFilterLogs(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthGetFilterLogs")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) *ethtypes.EthFilterResult); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetFilterLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetFilterLogs'
type FullNode_EthGetFilterLogs_Call struct {
	*mock.Call
}

// EthGetFilterLogs is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *FullNode_Expecter) EthGetFilterLogs(ctx interface{}, id interface{}) *FullNode_EthGetFilterLogs_Call {
	return &FullNode_EthGetFilterLogs_Call{Call: _e.mock.On("EthGetFilterLogs", ctx, id)}
}

func (_c *FullNode_EthGetFilterLogs_Call) Run(run func(ctx context.Context, id ethtypes.EthFilterID)) *FullNode_EthGetFilterLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthFilterID))
	})
	return _c
}

func (_c *FullNode_EthGetFilterLogs_Call) Return(ethFilterResult *ethtypes.EthFilterResult, err error) *FullNode_EthGetFilterLogs_Call {
	_c.Call.Return(ethFilterResult, err)
	return _c
}

func (_c *FullNode_EthGetFilterLogs_Call) RunAndReturn(run func(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)) *FullNode_EthGetFilterLogs_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetLogs provides a mock function for the type FullNode
func (_mock *FullNode) EthGetLogs(ctx context.Context, filter *ethtypes.EthFilterSpec) (*ethtypes.EthFilterResult, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthGetLogs")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) (*ethtypes.EthFilterResult, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) *ethtypes.EthFilterResult); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ethtypes.EthFilterSpec) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetLogs'
type FullNode_EthGetLogs_Call struct {
	*mock.Call
}

// EthGetLogs is a helper method to define mock.On call
//   - ctx
//   - filter
func (_e *FullNode_Expecter) EthGetLogs(ctx interface{}, filter interface{}) *FullNode_EthGetLogs_Call {
	return &FullNode_EthGetLogs_Call{Call: _e.mock.On("EthGetLogs", ctx, filter)}
}

func (_c *FullNode_EthGetLogs_Call) Run(run func(ctx context.Context, filter *ethtypes.EthFilterSpec)) *FullNode_EthGetLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ethtypes.EthFilterSpec))
	})
	return _c
}

func (_c *FullNode_EthGetLogs_Call) Return(ethFilterResult *ethtypes.EthFilterResult, err error) *FullNode_EthGetLogs_Call {
	_c.Call.Return(ethFilterResult, err)
	return _c
}

func (_c *FullNode_EthGetLogs_Call) RunAndReturn(run func(ctx context.Context, filter *ethtypes.EthFilterSpec) (*ethtypes.EthFilterResult, error)) *FullNode_EthGetLogs_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetMessageCidByTransactionHash provides a mock function for the type FullNode
func (_mock *FullNode) EthGetMessageCidByTransactionHash(ctx context.Context, txHash *ethtypes.EthHash) (*cid.Cid, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetMessageCidByTransactionHash")
	}

	var r0 *cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) (*cid.Cid, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) *cid.Cid); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cid.Cid)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetMessageCidByTransactionHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetMessageCidByTransactionHash'
type FullNode_EthGetMessageCidByTransactionHash_Call struct {
	*mock.Call
}

// EthGetMessageCidByTransactionHash is a helper method to define mock.On call
//   - ctx
//   - txHash
func (_e *FullNode_Expecter) EthGetMessageCidByTransactionHash(ctx interface{}, txHash interface{}) *FullNode_EthGetMessageCidByTransactionHash_Call {
	return &FullNode_EthGetMessageCidByTransactionHash_Call{Call: _e.mock.On("EthGetMessageCidByTransactionHash", ctx, txHash)}
}

func (_c *FullNode_EthGetMessageCidByTransactionHash_Call) Run(run func(ctx context.Context, txHash *ethtypes.EthHash)) *FullNode_EthGetMessageCidByTransactionHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ethtypes.EthHash))
	})
	return _c
}

func (_c *FullNode_EthGetMessageCidByTransactionHash_Call) Return(cid1 *cid.Cid, err error) *FullNode_EthGetMessageCidByTransactionHash_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_EthGetMessageCidByTransactionHash_Call) RunAndReturn(run func(ctx context.Context, txHash *ethtypes.EthHash) (*cid.Cid, error)) *FullNode_EthGetMessageCidByTransactionHash_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetStorageAt provides a mock function for the type FullNode
func (_mock *FullNode) EthGetStorageAt(ctx context.Context, address1 ethtypes.EthAddress, position ethtypes.EthBytes, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _mock.Called(ctx, address1, position, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetStorageAt")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return returnFunc(ctx, address1, position, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = returnFunc(ctx, address1, position, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, address1, position, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetStorageAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetStorageAt'
type FullNode_EthGetStorageAt_Call struct {
	*mock.Call
}

// EthGetStorageAt is a helper method to define mock.On call
//   - ctx
//   - address1
//   - position
//   - blkParam
func (_e *FullNode_Expecter) EthGetStorageAt(ctx interface{}, address1 interface{}, position interface{}, blkParam interface{}) *FullNode_EthGetStorageAt_Call {
	return &FullNode_EthGetStorageAt_Call{Call: _e.mock.On("EthGetStorageAt", ctx, address1, position, blkParam)}
}

func (_c *FullNode_EthGetStorageAt_Call) Run(run func(ctx context.Context, address1 ethtypes.EthAddress, position ethtypes.EthBytes, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthGetStorageAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthAddress), args[2].(ethtypes.EthBytes), args[3].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthGetStorageAt_Call) Return(ethBytes ethtypes.EthBytes, err error) *FullNode_EthGetStorageAt_Call {
	_c.Call.Return(ethBytes, err)
	return _c
}

func (_c *FullNode_EthGetStorageAt_Call) RunAndReturn(run func(ctx context.Context, address1 ethtypes.EthAddress, position ethtypes.EthBytes, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)) *FullNode_EthGetStorageAt_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionByBlockHashAndIndex provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionByBlockHashAndIndex(ctx context.Context, blkHash ethtypes.EthHash, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error) {
	ret := _mock.Called(ctx, blkHash, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByBlockHashAndIndex")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) (*ethtypes.EthTx, error)); ok {
		return returnFunc(ctx, blkHash, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) *ethtypes.EthTx); ok {
		r0 = returnFunc(ctx, blkHash, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) error); ok {
		r1 = returnFunc(ctx, blkHash, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionByBlockHashAndIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionByBlockHashAndIndex'
type FullNode_EthGetTransactionByBlockHashAndIndex_Call struct {
	*mock.Call
}

// EthGetTransactionByBlockHashAndIndex is a helper method to define mock.On call
//   - ctx
//   - blkHash
//   - txIndex
func (_e *FullNode_Expecter) EthGetTransactionByBlockHashAndIndex(ctx interface{}, blkHash interface{}, txIndex interface{}) *FullNode_EthGetTransactionByBlockHashAndIndex_Call {
	return &FullNode_EthGetTransactionByBlockHashAndIndex_Call{Call: _e.mock.On("EthGetTransactionByBlockHashAndIndex", ctx, blkHash, txIndex)}
}

func (_c *FullNode_EthGetTransactionByBlockHashAndIndex_Call) Run(run func(ctx context.Context, blkHash ethtypes.EthHash, txIndex ethtypes.EthUint64)) *FullNode_EthGetTransactionByBlockHashAndIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthHash), args[2].(ethtypes.EthUint64))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionByBlockHashAndIndex_Call) Return(ethTx *ethtypes.EthTx, err error) *FullNode_EthGetTransactionByBlockHashAndIndex_Call {
	_c.Call.Return(ethTx, err)
	return _c
}

func (_c *FullNode_EthGetTransactionByBlockHashAndIndex_Call) RunAndReturn(run func(ctx context.Context, blkHash ethtypes.EthHash, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error)) *FullNode_EthGetTransactionByBlockHashAndIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionByBlockNumberAndIndex provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionByBlockNumberAndIndex(ctx context.Context, blkNum string, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error) {
	ret := _mock.Called(ctx, blkNum, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByBlockNumberAndIndex")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ethtypes.EthUint64) (*ethtypes.EthTx, error)); ok {
		return returnFunc(ctx, blkNum, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ethtypes.EthUint64) *ethtypes.EthTx); ok {
		r0 = returnFunc(ctx, blkNum, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ethtypes.EthUint64) error); ok {
		r1 = returnFunc(ctx, blkNum, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionByBlockNumberAndIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionByBlockNumberAndIndex'
type FullNode_EthGetTransactionByBlockNumberAndIndex_Call struct {
	*mock.Call
}

// EthGetTransactionByBlockNumberAndIndex is a helper method to define mock.On call
//   - ctx
//   - blkNum
//   - txIndex
func (_e *FullNode_Expecter) EthGetTransactionByBlockNumberAndIndex(ctx interface{}, blkNum interface{}, txIndex interface{}) *FullNode_EthGetTransactionByBlockNumberAndIndex_Call {
	return &FullNode_EthGetTransactionByBlockNumberAndIndex_Call{Call: _e.mock.On("EthGetTransactionByBlockNumberAndIndex", ctx, blkNum, txIndex)}
}

func (_c *FullNode_EthGetTransactionByBlockNumberAndIndex_Call) Run(run func(ctx context.Context, blkNum string, txIndex ethtypes.EthUint64)) *FullNode_EthGetTransactionByBlockNumberAndIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ethtypes.EthUint64))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionByBlockNumberAndIndex_Call) Return(ethTx *ethtypes.EthTx, err error) *FullNode_EthGetTransactionByBlockNumberAndIndex_Call {
	_c.Call.Return(ethTx, err)
	return _c
}

func (_c *FullNode_EthGetTransactionByBlockNumberAndIndex_Call) RunAndReturn(run func(ctx context.Context, blkNum string, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error)) *FullNode_EthGetTransactionByBlockNumberAndIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionByHash provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionByHash(ctx context.Context, txHash *ethtypes.EthHash) (*ethtypes.EthTx, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByHash")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) (*ethtypes.EthTx, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) *ethtypes.EthTx); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionByHash'
type FullNode_EthGetTransactionByHash_Call struct {
	*mock.Call
}

// EthGetTransactionByHash is a helper method to define mock.On call
//   - ctx
//   - txHash
func (_e *FullNode_Expecter) EthGetTransactionByHash(ctx interface{}, txHash interface{}) *FullNode_EthGetTransactionByHash_Call {
	return &FullNode_EthGetTransactionByHash_Call{Call: _e.mock.On("EthGetTransactionByHash", ctx, txHash)}
}

func (_c *FullNode_EthGetTransactionByHash_Call) Run(run func(ctx context.Context, txHash *ethtypes.EthHash)) *FullNode_EthGetTransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ethtypes.EthHash))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionByHash_Call) Return(ethTx *ethtypes.EthTx, err error) *FullNode_EthGetTransactionByHash_Call {
	_c.Call.Return(ethTx, err)
	return _c
}

func (_c *FullNode_EthGetTransactionByHash_Call) RunAndReturn(run func(ctx context.Context, txHash *ethtypes.EthHash) (*ethtypes.EthTx, error)) *FullNode_EthGetTransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionByHashLimited provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionByHashLimited(ctx context.Context, txHash *ethtypes.EthHash, limit abi.ChainEpoch) (*ethtypes.EthTx, error) {
	ret := _mock.Called(ctx, txHash, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByHashLimited")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) (*ethtypes.EthTx, error)); ok {
		return returnFunc(ctx, txHash, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) *ethtypes.EthTx); ok {
		r0 = returnFunc(ctx, txHash, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) error); ok {
		r1 = returnFunc(ctx, txHash, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionByHashLimited_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionByHashLimited'
type FullNode_EthGetTransactionByHashLimited_Call struct {
	*mock.Call
}

// EthGetTransactionByHashLimited is a helper method to define mock.On call
//   - ctx
//   - txHash
//   - limit
func (_e *FullNode_Expecter) EthGetTransactionByHashLimited(ctx interface{}, txHash interface{}, limit interface{}) *FullNode_EthGetTransactionByHashLimited_Call {
	return &FullNode_EthGetTransactionByHashLimited_Call{Call: _e.mock.On("EthGetTransactionByHashLimited", ctx, txHash, limit)}
}

func (_c *FullNode_EthGetTransactionByHashLimited_Call) Run(run func(ctx context.Context, txHash *ethtypes.EthHash, limit abi.ChainEpoch)) *FullNode_EthGetTransactionByHashLimited_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ethtypes.EthHash), args[2].(abi.ChainEpoch))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionByHashLimited_Call) Return(ethTx *ethtypes.EthTx, err error) *FullNode_EthGetTransactionByHashLimited_Call {
	_c.Call.Return(ethTx, err)
	return _c
}

func (_c *FullNode_EthGetTransactionByHashLimited_Call) RunAndReturn(run func(ctx context.Context, txHash *ethtypes.EthHash, limit abi.ChainEpoch) (*ethtypes.EthTx, error)) *FullNode_EthGetTransactionByHashLimited_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionCount provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionCount(ctx context.Context, sender ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx, sender, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionCount")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx, sender, blkParam)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx, sender, blkParam)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = returnFunc(ctx, sender, blkParam)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionCount'
type FullNode_EthGetTransactionCount_Call struct {
	*mock.Call
}

// EthGetTransactionCount is a helper method to define mock.On call
//   - ctx
//   - sender
//   - blkParam
func (_e *FullNode_Expecter) EthGetTransactionCount(ctx interface{}, sender interface{}, blkParam interface{}) *FullNode_EthGetTransactionCount_Call {
	return &FullNode_EthGetTransactionCount_Call{Call: _e.mock.On("EthGetTransactionCount", ctx, sender, blkParam)}
}

func (_c *FullNode_EthGetTransactionCount_Call) Run(run func(ctx context.Context, sender ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash)) *FullNode_EthGetTransactionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthAddress), args[2].(ethtypes.EthBlockNumberOrHash))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionCount_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthGetTransactionCount_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthGetTransactionCount_Call) RunAndReturn(run func(ctx context.Context, sender ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthUint64, error)) *FullNode_EthGetTransactionCount_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionHashByCid provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionHashByCid(ctx context.Context, cid1 cid.Cid) (*ethtypes.EthHash, error) {
	ret := _mock.Called(ctx, cid1)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionHashByCid")
	}

	var r0 *ethtypes.EthHash
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (*ethtypes.EthHash, error)); ok {
		return returnFunc(ctx, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) *ethtypes.EthHash); ok {
		r0 = returnFunc(ctx, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthHash)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionHashByCid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionHashByCid'
type FullNode_EthGetTransactionHashByCid_Call struct {
	*mock.Call
}

// EthGetTransactionHashByCid is a helper method to define mock.On call
//   - ctx
//   - cid1
func (_e *FullNode_Expecter) EthGetTransactionHashByCid(ctx interface{}, cid1 interface{}) *FullNode_EthGetTransactionHashByCid_Call {
	return &FullNode_EthGetTransactionHashByCid_Call{Call: _e.mock.On("EthGetTransactionHashByCid", ctx, cid1)}
}

func (_c *FullNode_EthGetTransactionHashByCid_Call) Run(run func(ctx context.Context, cid1 cid.Cid)) *FullNode_EthGetTransactionHashByCid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionHashByCid_Call) Return(ethHash *ethtypes.EthHash, err error) *FullNode_EthGetTransactionHashByCid_Call {
	_c.Call.Return(ethHash, err)
	return _c
}

func (_c *FullNode_EthGetTransactionHashByCid_Call) RunAndReturn(run func(ctx context.Context, cid1 cid.Cid) (*ethtypes.EthHash, error)) *FullNode_EthGetTransactionHashByCid_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionReceipt provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionReceipt(ctx context.Context, txHash ethtypes.EthHash) (*api.EthTxReceipt, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionReceipt")
	}

	var r0 *api.EthTxReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) (*api.EthTxReceipt, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) *api.EthTxReceipt); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.EthTxReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionReceipt'
type FullNode_EthGetTransactionReceipt_Call struct {
	*mock.Call
}

// EthGetTransactionReceipt is a helper method to define mock.On call
//   - ctx
//   - txHash
func (_e *FullNode_Expecter) EthGetTransactionReceipt(ctx interface{}, txHash interface{}) *FullNode_EthGetTransactionReceipt_Call {
	return &FullNode_EthGetTransactionReceipt_Call{Call: _e.mock.On("EthGetTransactionReceipt", ctx, txHash)}
}

func (_c *FullNode_EthGetTransactionReceipt_Call) Run(run func(ctx context.Context, txHash ethtypes.EthHash)) *FullNode_EthGetTransactionReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthHash))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionReceipt_Call) Return(ethTxReceipt *api.EthTxReceipt, err error) *FullNode_EthGetTransactionReceipt_Call {
	_c.Call.Return(ethTxReceipt, err)
	return _c
}

func (_c *FullNode_EthGetTransactionReceipt_Call) RunAndReturn(run func(ctx context.Context, txHash ethtypes.EthHash) (*api.EthTxReceipt, error)) *FullNode_EthGetTransactionReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// EthGetTransactionReceiptLimited provides a mock function for the type FullNode
func (_mock *FullNode) EthGetTransactionReceiptLimited(ctx context.Context, txHash ethtypes.EthHash, limit abi.ChainEpoch) (*api.EthTxReceipt, error) {
	ret := _mock.Called(ctx, txHash, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionReceiptLimited")
	}

	var r0 *api.EthTxReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) (*api.EthTxReceipt, error)); ok {
		return returnFunc(ctx, txHash, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) *api.EthTxReceipt); ok {
		r0 = returnFunc(ctx, txHash, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.EthTxReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) error); ok {
		r1 = returnFunc(ctx, txHash, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthGetTransactionReceiptLimited_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthGetTransactionReceiptLimited'
type FullNode_EthGetTransactionReceiptLimited_Call struct {
	*mock.Call
}

// EthGetTransactionReceiptLimited is a helper method to define mock.On call
//   - ctx
//   - txHash
//   - limit
func (_e *FullNode_Expecter) EthGetTransactionReceiptLimited(ctx interface{}, txHash interface{}, limit interface{}) *FullNode_EthGetTransactionReceiptLimited_Call {
	return &FullNode_EthGetTransactionReceiptLimited_Call{Call: _e.mock.On("EthGetTransactionReceiptLimited", ctx, txHash, limit)}
}

func (_c *FullNode_EthGetTransactionReceiptLimited_Call) Run(run func(ctx context.Context, txHash ethtypes.EthHash, limit abi.ChainEpoch)) *FullNode_EthGetTransactionReceiptLimited_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthHash), args[2].(abi.ChainEpoch))
	})
	return _c
}

func (_c *FullNode_EthGetTransactionReceiptLimited_Call) Return(ethTxReceipt *api.EthTxReceipt, err error) *FullNode_EthGetTransactionReceiptLimited_Call {
	_c.Call.Return(ethTxReceipt, err)
	return _c
}

func (_c *FullNode_EthGetTransactionReceiptLimited_Call) RunAndReturn(run func(ctx context.Context, txHash ethtypes.EthHash, limit abi.ChainEpoch) (*api.EthTxReceipt, error)) *FullNode_EthGetTransactionReceiptLimited_Call {
	_c.Call.Return(run)
	return _c
}

// EthMaxPriorityFeePerGas provides a mock function for the type FullNode
func (_mock *FullNode) EthMaxPriorityFeePerGas(ctx context.Context) (ethtypes.EthBigInt, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthMaxPriorityFeePerGas")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthBigInt, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthBigInt); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthMaxPriorityFeePerGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthMaxPriorityFeePerGas'
type FullNode_EthMaxPriorityFeePerGas_Call struct {
	*mock.Call
}

// EthMaxPriorityFeePerGas is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthMaxPriorityFeePerGas(ctx interface{}) *FullNode_EthMaxPriorityFeePerGas_Call {
	return &FullNode_EthMaxPriorityFeePerGas_Call{Call: _e.mock.On("EthMaxPriorityFeePerGas", ctx)}
}

func (_c *FullNode_EthMaxPriorityFeePerGas_Call) Run(run func(ctx context.Context)) *FullNode_EthMaxPriorityFeePerGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthMaxPriorityFeePerGas_Call) Return(ethBigInt ethtypes.EthBigInt, err error) *FullNode_EthMaxPriorityFeePerGas_Call {
	_c.Call.Return(ethBigInt, err)
	return _c
}

func (_c *FullNode_EthMaxPriorityFeePerGas_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthBigInt, error)) *FullNode_EthMaxPriorityFeePerGas_Call {
	_c.Call.Return(run)
	return _c
}

// EthNewBlockFilter provides a mock function for the type FullNode
func (_mock *FullNode) EthNewBlockFilter(ctx context.Context) (ethtypes.EthFilterID, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthNewBlockFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthFilterID, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthFilterID); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthNewBlockFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthNewBlockFilter'
type FullNode_EthNewBlockFilter_Call struct {
	*mock.Call
}

// EthNewBlockFilter is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthNewBlockFilter(ctx interface{}) *FullNode_EthNewBlockFilter_Call {
	return &FullNode_EthNewBlockFilter_Call{Call: _e.mock.On("EthNewBlockFilter", ctx)}
}

func (_c *FullNode_EthNewBlockFilter_Call) Run(run func(ctx context.Context)) *FullNode_EthNewBlockFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthNewBlockFilter_Call) Return(ethFilterID ethtypes.EthFilterID, err error) *FullNode_EthNewBlockFilter_Call {
	_c.Call.Return(ethFilterID, err)
	return _c
}

func (_c *FullNode_EthNewBlockFilter_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthFilterID, error)) *FullNode_EthNewBlockFilter_Call {
	_c.Call.Return(run)
	return _c
}

// EthNewFilter provides a mock function for the type FullNode
func (_mock *FullNode) EthNewFilter(ctx context.Context, filter *ethtypes.EthFilterSpec) (ethtypes.EthFilterID, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthNewFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) (ethtypes.EthFilterID, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) ethtypes.EthFilterID); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ethtypes.EthFilterSpec) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthNewFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthNewFilter'
type FullNode_EthNewFilter_Call struct {
	*mock.Call
}

// EthNewFilter is a helper method to define mock.On call
//   - ctx
//   - filter
func (_e *FullNode_Expecter) EthNewFilter(ctx interface{}, filter interface{}) *FullNode_EthNewFilter_Call {
	return &FullNode_EthNewFilter_Call{Call: _e.mock.On("EthNewFilter", ctx, filter)}
}

func (_c *FullNode_EthNewFilter_Call) Run(run func(ctx context.Context, filter *ethtypes.EthFilterSpec)) *FullNode_EthNewFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ethtypes.EthFilterSpec))
	})
	return _c
}

func (_c *FullNode_EthNewFilter_Call) Return(ethFilterID ethtypes.EthFilterID, err error) *FullNode_EthNewFilter_Call {
	_c.Call.Return(ethFilterID, err)
	return _c
}

func (_c *FullNode_EthNewFilter_Call) RunAndReturn(run func(ctx context.Context, filter *ethtypes.EthFilterSpec) (ethtypes.EthFilterID, error)) *FullNode_EthNewFilter_Call {
	_c.Call.Return(run)
	return _c
}

// EthNewPendingTransactionFilter provides a mock function for the type FullNode
func (_mock *FullNode) EthNewPendingTransactionFilter(ctx context.Context) (ethtypes.EthFilterID, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthNewPendingTransactionFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthFilterID, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthFilterID); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthNewPendingTransactionFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthNewPendingTransactionFilter'
type FullNode_EthNewPendingTransactionFilter_Call struct {
	*mock.Call
}

// EthNewPendingTransactionFilter is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthNewPendingTransactionFilter(ctx interface{}) *FullNode_EthNewPendingTransactionFilter_Call {
	return &FullNode_EthNewPendingTransactionFilter_Call{Call: _e.mock.On("EthNewPendingTransactionFilter", ctx)}
}

func (_c *FullNode_EthNewPendingTransactionFilter_Call) Run(run func(ctx context.Context)) *FullNode_EthNewPendingTransactionFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthNewPendingTransactionFilter_Call) Return(ethFilterID ethtypes.EthFilterID, err error) *FullNode_EthNewPendingTransactionFilter_Call {
	_c.Call.Return(ethFilterID, err)
	return _c
}

func (_c *FullNode_EthNewPendingTransactionFilter_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthFilterID, error)) *FullNode_EthNewPendingTransactionFilter_Call {
	_c.Call.Return(run)
	return _c
}

// EthProtocolVersion provides a mock function for the type FullNode
func (_mock *FullNode) EthProtocolVersion(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthProtocolVersion")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthProtocolVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthProtocolVersion'
type FullNode_EthProtocolVersion_Call struct {
	*mock.Call
}

// EthProtocolVersion is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthProtocolVersion(ctx interface{}) *FullNode_EthProtocolVersion_Call {
	return &FullNode_EthProtocolVersion_Call{Call: _e.mock.On("EthProtocolVersion", ctx)}
}

func (_c *FullNode_EthProtocolVersion_Call) Run(run func(ctx context.Context)) *FullNode_EthProtocolVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthProtocolVersion_Call) Return(ethUint64 ethtypes.EthUint64, err error) *FullNode_EthProtocolVersion_Call {
	_c.Call.Return(ethUint64, err)
	return _c
}

func (_c *FullNode_EthProtocolVersion_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthUint64, error)) *FullNode_EthProtocolVersion_Call {
	_c.Call.Return(run)
	return _c
}

// EthSendRawTransaction provides a mock function for the type FullNode
func (_mock *FullNode) EthSendRawTransaction(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error) {
	ret := _mock.Called(ctx, rawTx)

	if len(ret) == 0 {
		panic("no return value specified for EthSendRawTransaction")
	}

	var r0 ethtypes.EthHash
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) (ethtypes.EthHash, error)); ok {
		return returnFunc(ctx, rawTx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) ethtypes.EthHash); ok {
		r0 = returnFunc(ctx, rawTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthHash)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthBytes) error); ok {
		r1 = returnFunc(ctx, rawTx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthSendRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthSendRawTransaction'
type FullNode_EthSendRawTransaction_Call struct {
	*mock.Call
}

// EthSendRawTransaction is a helper method to define mock.On call
//   - ctx
//   - rawTx
func (_e *FullNode_Expecter) EthSendRawTransaction(ctx interface{}, rawTx interface{}) *FullNode_EthSendRawTransaction_Call {
	return &FullNode_EthSendRawTransaction_Call{Call: _e.mock.On("EthSendRawTransaction", ctx, rawTx)}
}

func (_c *FullNode_EthSendRawTransaction_Call) Run(run func(ctx context.Context, rawTx ethtypes.EthBytes)) *FullNode_EthSendRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthBytes))
	})
	return _c
}

func (_c *FullNode_EthSendRawTransaction_Call) Return(ethHash ethtypes.EthHash, err error) *FullNode_EthSendRawTransaction_Call {
	_c.Call.Return(ethHash, err)
	return _c
}

func (_c *FullNode_EthSendRawTransaction_Call) RunAndReturn(run func(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error)) *FullNode_EthSendRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// EthSendRawTransactionUntrusted provides a mock function for the type FullNode
func (_mock *FullNode) EthSendRawTransactionUntrusted(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error) {
	ret := _mock.Called(ctx, rawTx)

	if len(ret) == 0 {
		panic("no return value specified for EthSendRawTransactionUntrusted")
	}

	var r0 ethtypes.EthHash
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) (ethtypes.EthHash, error)); ok {
		return returnFunc(ctx, rawTx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) ethtypes.EthHash); ok {
		r0 = returnFunc(ctx, rawTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthHash)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthBytes) error); ok {
		r1 = returnFunc(ctx, rawTx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthSendRawTransactionUntrusted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthSendRawTransactionUntrusted'
type FullNode_EthSendRawTransactionUntrusted_Call struct {
	*mock.Call
}

// EthSendRawTransactionUntrusted is a helper method to define mock.On call
//   - ctx
//   - rawTx
func (_e *FullNode_Expecter) EthSendRawTransactionUntrusted(ctx interface{}, rawTx interface{}) *FullNode_EthSendRawTransactionUntrusted_Call {
	return &FullNode_EthSendRawTransactionUntrusted_Call{Call: _e.mock.On("EthSendRawTransactionUntrusted", ctx, rawTx)}
}

func (_c *FullNode_EthSendRawTransactionUntrusted_Call) Run(run func(ctx context.Context, rawTx ethtypes.EthBytes)) *FullNode_EthSendRawTransactionUntrusted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthBytes))
	})
	return _c
}

func (_c *FullNode_EthSendRawTransactionUntrusted_Call) Return(ethHash ethtypes.EthHash, err error) *FullNode_EthSendRawTransactionUntrusted_Call {
	_c.Call.Return(ethHash, err)
	return _c
}

func (_c *FullNode_EthSendRawTransactionUntrusted_Call) RunAndReturn(run func(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error)) *FullNode_EthSendRawTransactionUntrusted_Call {
	_c.Call.Return(run)
	return _c
}

// EthSubscribe provides a mock function for the type FullNode
func (_mock *FullNode) EthSubscribe(ctx context.Context, params jsonrpc.RawParams) (ethtypes.EthSubscriptionID, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for EthSubscribe")
	}

	var r0 ethtypes.EthSubscriptionID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthSubscriptionID, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthSubscriptionID); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthSubscriptionID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthSubscribe'
type FullNode_EthSubscribe_Call struct {
	*mock.Call
}

// EthSubscribe is a helper method to define mock.On call
//   - ctx
//   - params
func (_e *FullNode_Expecter) EthSubscribe(ctx interface{}, params interface{}) *FullNode_EthSubscribe_Call {
	return &FullNode_EthSubscribe_Call{Call: _e.mock.On("EthSubscribe", ctx, params)}
}

func (_c *FullNode_EthSubscribe_Call) Run(run func(ctx context.Context, params jsonrpc.RawParams)) *FullNode_EthSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jsonrpc.RawParams))
	})
	return _c
}

func (_c *FullNode_EthSubscribe_Call) Return(ethSubscriptionID ethtypes.EthSubscriptionID, err error) *FullNode_EthSubscribe_Call {
	_c.Call.Return(ethSubscriptionID, err)
	return _c
}

func (_c *FullNode_EthSubscribe_Call) RunAndReturn(run func(ctx context.Context, params jsonrpc.RawParams) (ethtypes.EthSubscriptionID, error)) *FullNode_EthSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// EthSyncing provides a mock function for the type FullNode
func (_mock *FullNode) EthSyncing(ctx context.Context) (ethtypes.EthSyncingResult, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthSyncing")
	}

	var r0 ethtypes.EthSyncingResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (ethtypes.EthSyncingResult, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) ethtypes.EthSyncingResult); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthSyncingResult)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthSyncing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthSyncing'
type FullNode_EthSyncing_Call struct {
	*mock.Call
}

// EthSyncing is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) EthSyncing(ctx interface{}) *FullNode_EthSyncing_Call {
	return &FullNode_EthSyncing_Call{Call: _e.mock.On("EthSyncing", ctx)}
}

func (_c *FullNode_EthSyncing_Call) Run(run func(ctx context.Context)) *FullNode_EthSyncing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_EthSyncing_Call) Return(ethSyncingResult ethtypes.EthSyncingResult, err error) *FullNode_EthSyncing_Call {
	_c.Call.Return(ethSyncingResult, err)
	return _c
}

func (_c *FullNode_EthSyncing_Call) RunAndReturn(run func(ctx context.Context) (ethtypes.EthSyncingResult, error)) *FullNode_EthSyncing_Call {
	_c.Call.Return(run)
	return _c
}

// EthTraceBlock provides a mock function for the type FullNode
func (_mock *FullNode) EthTraceBlock(ctx context.Context, blkNum string) ([]*ethtypes.EthTraceBlock, error) {
	ret := _mock.Called(ctx, blkNum)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceBlock")
	}

	var r0 []*ethtypes.EthTraceBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*ethtypes.EthTraceBlock, error)); ok {
		return returnFunc(ctx, blkNum)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*ethtypes.EthTraceBlock); ok {
		r0 = returnFunc(ctx, blkNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceBlock)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, blkNum)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthTraceBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthTraceBlock'
type FullNode_EthTraceBlock_Call struct {
	*mock.Call
}

// EthTraceBlock is a helper method to define mock.On call
//   - ctx
//   - blkNum
func (_e *FullNode_Expecter) EthTraceBlock(ctx interface{}, blkNum interface{}) *FullNode_EthTraceBlock_Call {
	return &FullNode_EthTraceBlock_Call{Call: _e.mock.On("EthTraceBlock", ctx, blkNum)}
}

func (_c *FullNode_EthTraceBlock_Call) Run(run func(ctx context.Context, blkNum string)) *FullNode_EthTraceBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_EthTraceBlock_Call) Return(ethTraceBlocks []*ethtypes.EthTraceBlock, err error) *FullNode_EthTraceBlock_Call {
	_c.Call.Return(ethTraceBlocks, err)
	return _c
}

func (_c *FullNode_EthTraceBlock_Call) RunAndReturn(run func(ctx context.Context, blkNum string) ([]*ethtypes.EthTraceBlock, error)) *FullNode_EthTraceBlock_Call {
	_c.Call.Return(run)
	return _c
}

// EthTraceFilter provides a mock function for the type FullNode
func (_mock *FullNode) EthTraceFilter(ctx context.Context, filter ethtypes.EthTraceFilterCriteria) ([]*ethtypes.EthTraceFilterResult, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceFilter")
	}

	var r0 []*ethtypes.EthTraceFilterResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthTraceFilterCriteria) ([]*ethtypes.EthTraceFilterResult, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthTraceFilterCriteria) []*ethtypes.EthTraceFilterResult); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceFilterResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthTraceFilterCriteria) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthTraceFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthTraceFilter'
type FullNode_EthTraceFilter_Call struct {
	*mock.Call
}

// EthTraceFilter is a helper method to define mock.On call
//   - ctx
//   - filter
func (_e *FullNode_Expecter) EthTraceFilter(ctx interface{}, filter interface{}) *FullNode_EthTraceFilter_Call {
	return &FullNode_EthTraceFilter_Call{Call: _e.mock.On("EthTraceFilter", ctx, filter)}
}

func (_c *FullNode_EthTraceFilter_Call) Run(run func(ctx context.Context, filter ethtypes.EthTraceFilterCriteria)) *FullNode_EthTraceFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthTraceFilterCriteria))
	})
	return _c
}

func (_c *FullNode_EthTraceFilter_Call) Return(ethTraceFilterResults []*ethtypes.EthTraceFilterResult, err error) *FullNode_EthTraceFilter_Call {
	_c.Call.Return(ethTraceFilterResults, err)
	return _c
}

func (_c *FullNode_EthTraceFilter_Call) RunAndReturn(run func(ctx context.Context, filter ethtypes.EthTraceFilterCriteria) ([]*ethtypes.EthTraceFilterResult, error)) *FullNode_EthTraceFilter_Call {
	_c.Call.Return(run)
	return _c
}

// EthTraceReplayBlockTransactions provides a mock function for the type FullNode
func (_mock *FullNode) EthTraceReplayBlockTransactions(ctx context.Context, blkNum string, traceTypes []string) ([]*ethtypes.EthTraceReplayBlockTransaction, error) {
	ret := _mock.Called(ctx, blkNum, traceTypes)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceReplayBlockTransactions")
	}

	var r0 []*ethtypes.EthTraceReplayBlockTransaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) ([]*ethtypes.EthTraceReplayBlockTransaction, error)); ok {
		return returnFunc(ctx, blkNum, traceTypes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) []*ethtypes.EthTraceReplayBlockTransaction); ok {
		r0 = returnFunc(ctx, blkNum, traceTypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceReplayBlockTransaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = returnFunc(ctx, blkNum, traceTypes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthTraceReplayBlockTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthTraceReplayBlockTransactions'
type FullNode_EthTraceReplayBlockTransactions_Call struct {
	*mock.Call
}

// EthTraceReplayBlockTransactions is a helper method to define mock.On call
//   - ctx
//   - blkNum
//   - traceTypes
func (_e *FullNode_Expecter) EthTraceReplayBlockTransactions(ctx interface{}, blkNum interface{}, traceTypes interface{}) *FullNode_EthTraceReplayBlockTransactions_Call {
	return &FullNode_EthTraceReplayBlockTransactions_Call{Call: _e.mock.On("EthTraceReplayBlockTransactions", ctx, blkNum, traceTypes)}
}

func (_c *FullNode_EthTraceReplayBlockTransactions_Call) Run(run func(ctx context.Context, blkNum string, traceTypes []string)) *FullNode_EthTraceReplayBlockTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *FullNode_EthTraceReplayBlockTransactions_Call) Return(ethTraceReplayBlockTransactions []*ethtypes.EthTraceReplayBlockTransaction, err error) *FullNode_EthTraceReplayBlockTransactions_Call {
	_c.Call.Return(ethTraceReplayBlockTransactions, err)
	return _c
}

func (_c *FullNode_EthTraceReplayBlockTransactions_Call) RunAndReturn(run func(ctx context.Context, blkNum string, traceTypes []string) ([]*ethtypes.EthTraceReplayBlockTransaction, error)) *FullNode_EthTraceReplayBlockTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// EthTraceTransaction provides a mock function for the type FullNode
func (_mock *FullNode) EthTraceTransaction(ctx context.Context, txHash string) ([]*ethtypes.EthTraceTransaction, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceTransaction")
	}

	var r0 []*ethtypes.EthTraceTransaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*ethtypes.EthTraceTransaction, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*ethtypes.EthTraceTransaction); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceTransaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthTraceTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthTraceTransaction'
type FullNode_EthTraceTransaction_Call struct {
	*mock.Call
}

// EthTraceTransaction is a helper method to define mock.On call
//   - ctx
//   - txHash
func (_e *FullNode_Expecter) EthTraceTransaction(ctx interface{}, txHash interface{}) *FullNode_EthTraceTransaction_Call {
	return &FullNode_EthTraceTransaction_Call{Call: _e.mock.On("EthTraceTransaction", ctx, txHash)}
}

func (_c *FullNode_EthTraceTransaction_Call) Run(run func(ctx context.Context, txHash string)) *FullNode_EthTraceTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_EthTraceTransaction_Call) Return(ethTraceTransactions []*ethtypes.EthTraceTransaction, err error) *FullNode_EthTraceTransaction_Call {
	_c.Call.Return(ethTraceTransactions, err)
	return _c
}

func (_c *FullNode_EthTraceTransaction_Call) RunAndReturn(run func(ctx context.Context, txHash string) ([]*ethtypes.EthTraceTransaction, error)) *FullNode_EthTraceTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// EthUninstallFilter provides a mock function for the type FullNode
func (_mock *FullNode) EthUninstallFilter(ctx context.Context, id ethtypes.EthFilterID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthUninstallFilter")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthUninstallFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthUninstallFilter'
type FullNode_EthUninstallFilter_Call struct {
	*mock.Call
}

// EthUninstallFilter is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *FullNode_Expecter) EthUninstallFilter(ctx interface{}, id interface{}) *FullNode_EthUninstallFilter_Call {
	return &FullNode_EthUninstallFilter_Call{Call: _e.mock.On("EthUninstallFilter", ctx, id)}
}

func (_c *FullNode_EthUninstallFilter_Call) Run(run func(ctx context.Context, id ethtypes.EthFilterID)) *FullNode_EthUninstallFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthFilterID))
	})
	return _c
}

func (_c *FullNode_EthUninstallFilter_Call) Return(b bool, err error) *FullNode_EthUninstallFilter_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_EthUninstallFilter_Call) RunAndReturn(run func(ctx context.Context, id ethtypes.EthFilterID) (bool, error)) *FullNode_EthUninstallFilter_Call {
	_c.Call.Return(run)
	return _c
}

// EthUnsubscribe provides a mock function for the type FullNode
func (_mock *FullNode) EthUnsubscribe(ctx context.Context, id ethtypes.EthSubscriptionID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthUnsubscribe")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthSubscriptionID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethtypes.EthSubscriptionID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethtypes.EthSubscriptionID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_EthUnsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthUnsubscribe'
type FullNode_EthUnsubscribe_Call struct {
	*mock.Call
}

// EthUnsubscribe is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *FullNode_Expecter) EthUnsubscribe(ctx interface{}, id interface{}) *FullNode_EthUnsubscribe_Call {
	return &FullNode_EthUnsubscribe_Call{Call: _e.mock.On("EthUnsubscribe", ctx, id)}
}

func (_c *FullNode_EthUnsubscribe_Call) Run(run func(ctx context.Context, id ethtypes.EthSubscriptionID)) *FullNode_EthUnsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ethtypes.EthSubscriptionID))
	})
	return _c
}

func (_c *FullNode_EthUnsubscribe_Call) Return(b bool, err error) *FullNode_EthUnsubscribe_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_EthUnsubscribe_Call) RunAndReturn(run func(ctx context.Context, id ethtypes.EthSubscriptionID) (bool, error)) *FullNode_EthUnsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetCertificate provides a mock function for the type FullNode
func (_mock *FullNode) F3GetCertificate(ctx context.Context, instance uint64) (*certs.FinalityCertificate, error) {
	ret := _mock.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for F3GetCertificate")
	}

	var r0 *certs.FinalityCertificate
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64) (*certs.FinalityCertificate, error)); ok {
		return returnFunc(ctx, instance)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64) *certs.FinalityCertificate); ok {
		r0 = returnFunc(ctx, instance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*certs.FinalityCertificate)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = returnFunc(ctx, instance)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetCertificate'
type FullNode_F3GetCertificate_Call struct {
	*mock.Call
}

// F3GetCertificate is a helper method to define mock.On call
//   - ctx
//   - instance
func (_e *FullNode_Expecter) F3GetCertificate(ctx interface{}, instance interface{}) *FullNode_F3GetCertificate_Call {
	return &FullNode_F3GetCertificate_Call{Call: _e.mock.On("F3GetCertificate", ctx, instance)}
}

func (_c *FullNode_F3GetCertificate_Call) Run(run func(ctx context.Context, instance uint64)) *FullNode_F3GetCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *FullNode_F3GetCertificate_Call) Return(finalityCertificate *certs.FinalityCertificate, err error) *FullNode_F3GetCertificate_Call {
	_c.Call.Return(finalityCertificate, err)
	return _c
}

func (_c *FullNode_F3GetCertificate_Call) RunAndReturn(run func(ctx context.Context, instance uint64) (*certs.FinalityCertificate, error)) *FullNode_F3GetCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetECPowerTable provides a mock function for the type FullNode
func (_mock *FullNode) F3GetECPowerTable(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for F3GetECPowerTable")
	}

	var r0 gpbft.PowerEntries
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (gpbft.PowerEntries, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) gpbft.PowerEntries); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gpbft.PowerEntries)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetECPowerTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetECPowerTable'
type FullNode_F3GetECPowerTable_Call struct {
	*mock.Call
}

// F3GetECPowerTable is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) F3GetECPowerTable(ctx interface{}, tsk interface{}) *FullNode_F3GetECPowerTable_Call {
	return &FullNode_F3GetECPowerTable_Call{Call: _e.mock.On("F3GetECPowerTable", ctx, tsk)}
}

func (_c *FullNode_F3GetECPowerTable_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_F3GetECPowerTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_F3GetECPowerTable_Call) Return(powerEntries gpbft.PowerEntries, err error) *FullNode_F3GetECPowerTable_Call {
	_c.Call.Return(powerEntries, err)
	return _c
}

func (_c *FullNode_F3GetECPowerTable_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error)) *FullNode_F3GetECPowerTable_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetF3PowerTable provides a mock function for the type FullNode
func (_mock *FullNode) F3GetF3PowerTable(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for F3GetF3PowerTable")
	}

	var r0 gpbft.PowerEntries
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (gpbft.PowerEntries, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) gpbft.PowerEntries); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gpbft.PowerEntries)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetF3PowerTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetF3PowerTable'
type FullNode_F3GetF3PowerTable_Call struct {
	*mock.Call
}

// F3GetF3PowerTable is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) F3GetF3PowerTable(ctx interface{}, tsk interface{}) *FullNode_F3GetF3PowerTable_Call {
	return &FullNode_F3GetF3PowerTable_Call{Call: _e.mock.On("F3GetF3PowerTable", ctx, tsk)}
}

func (_c *FullNode_F3GetF3PowerTable_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_F3GetF3PowerTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_F3GetF3PowerTable_Call) Return(powerEntries gpbft.PowerEntries, err error) *FullNode_F3GetF3PowerTable_Call {
	_c.Call.Return(powerEntries, err)
	return _c
}

func (_c *FullNode_F3GetF3PowerTable_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error)) *FullNode_F3GetF3PowerTable_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetLatestCertificate provides a mock function for the type FullNode
func (_mock *FullNode) F3GetLatestCertificate(ctx context.Context) (*certs.FinalityCertificate, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetLatestCertificate")
	}

	var r0 *certs.FinalityCertificate
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*certs.FinalityCertificate, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *certs.FinalityCertificate); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*certs.FinalityCertificate)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetLatestCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetLatestCertificate'
type FullNode_F3GetLatestCertificate_Call struct {
	*mock.Call
}

// F3GetLatestCertificate is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) F3GetLatestCertificate(ctx interface{}) *FullNode_F3GetLatestCertificate_Call {
	return &FullNode_F3GetLatestCertificate_Call{Call: _e.mock.On("F3GetLatestCertificate", ctx)}
}

func (_c *FullNode_F3GetLatestCertificate_Call) Run(run func(ctx context.Context)) *FullNode_F3GetLatestCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_F3GetLatestCertificate_Call) Return(finalityCertificate *certs.FinalityCertificate, err error) *FullNode_F3GetLatestCertificate_Call {
	_c.Call.Return(finalityCertificate, err)
	return _c
}

func (_c *FullNode_F3GetLatestCertificate_Call) RunAndReturn(run func(ctx context.Context) (*certs.FinalityCertificate, error)) *FullNode_F3GetLatestCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetManifest provides a mock function for the type FullNode
func (_mock *FullNode) F3GetManifest(ctx context.Context) (*manifest.Manifest, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetManifest")
	}

	var r0 *manifest.Manifest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*manifest.Manifest, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *manifest.Manifest); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*manifest.Manifest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetManifest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetManifest'
type FullNode_F3GetManifest_Call struct {
	*mock.Call
}

// F3GetManifest is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) F3GetManifest(ctx interface{}) *FullNode_F3GetManifest_Call {
	return &FullNode_F3GetManifest_Call{Call: _e.mock.On("F3GetManifest", ctx)}
}

func (_c *FullNode_F3GetManifest_Call) Run(run func(ctx context.Context)) *FullNode_F3GetManifest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_F3GetManifest_Call) Return(manifest1 *manifest.Manifest, err error) *FullNode_F3GetManifest_Call {
	_c.Call.Return(manifest1, err)
	return _c
}

func (_c *FullNode_F3GetManifest_Call) RunAndReturn(run func(ctx context.Context) (*manifest.Manifest, error)) *FullNode_F3GetManifest_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetOrRenewParticipationTicket provides a mock function for the type FullNode
func (_mock *FullNode) F3GetOrRenewParticipationTicket(ctx context.Context, minerID address.Address, previous api.F3ParticipationTicket, instances uint64) (api.F3ParticipationTicket, error) {
	ret := _mock.Called(ctx, minerID, previous, instances)

	if len(ret) == 0 {
		panic("no return value specified for F3GetOrRenewParticipationTicket")
	}

	var r0 api.F3ParticipationTicket
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) (api.F3ParticipationTicket, error)); ok {
		return returnFunc(ctx, minerID, previous, instances)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) api.F3ParticipationTicket); ok {
		r0 = returnFunc(ctx, minerID, previous, instances)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(api.F3ParticipationTicket)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) error); ok {
		r1 = returnFunc(ctx, minerID, previous, instances)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetOrRenewParticipationTicket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetOrRenewParticipationTicket'
type FullNode_F3GetOrRenewParticipationTicket_Call struct {
	*mock.Call
}

// F3GetOrRenewParticipationTicket is a helper method to define mock.On call
//   - ctx
//   - minerID
//   - previous
//   - instances
func (_e *FullNode_Expecter) F3GetOrRenewParticipationTicket(ctx interface{}, minerID interface{}, previous interface{}, instances interface{}) *FullNode_F3GetOrRenewParticipationTicket_Call {
	return &FullNode_F3GetOrRenewParticipationTicket_Call{Call: _e.mock.On("F3GetOrRenewParticipationTicket", ctx, minerID, previous, instances)}
}

func (_c *FullNode_F3GetOrRenewParticipationTicket_Call) Run(run func(ctx context.Context, minerID address.Address, previous api.F3ParticipationTicket, instances uint64)) *FullNode_F3GetOrRenewParticipationTicket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(api.F3ParticipationTicket), args[3].(uint64))
	})
	return _c
}

func (_c *FullNode_F3GetOrRenewParticipationTicket_Call) Return(f3ParticipationTicket api.F3ParticipationTicket, err error) *FullNode_F3GetOrRenewParticipationTicket_Call {
	_c.Call.Return(f3ParticipationTicket, err)
	return _c
}

func (_c *FullNode_F3GetOrRenewParticipationTicket_Call) RunAndReturn(run func(ctx context.Context, minerID address.Address, previous api.F3ParticipationTicket, instances uint64) (api.F3ParticipationTicket, error)) *FullNode_F3GetOrRenewParticipationTicket_Call {
	_c.Call.Return(run)
	return _c
}

// F3GetProgress provides a mock function for the type FullNode
func (_mock *FullNode) F3GetProgress(ctx context.Context) (gpbft.InstanceProgress, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetProgress")
	}

	var r0 gpbft.InstanceProgress
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (gpbft.InstanceProgress, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) gpbft.InstanceProgress); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(gpbft.InstanceProgress)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3GetProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3GetProgress'
type FullNode_F3GetProgress_Call struct {
	*mock.Call
}

// F3GetProgress is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) F3GetProgress(ctx interface{}) *FullNode_F3GetProgress_Call {
	return &FullNode_F3GetProgress_Call{Call: _e.mock.On("F3GetProgress", ctx)}
}

func (_c *FullNode_F3GetProgress_Call) Run(run func(ctx context.Context)) *FullNode_F3GetProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_F3GetProgress_Call) Return(instanceProgress gpbft.InstanceProgress, err error) *FullNode_F3GetProgress_Call {
	_c.Call.Return(instanceProgress, err)
	return _c
}

func (_c *FullNode_F3GetProgress_Call) RunAndReturn(run func(ctx context.Context) (gpbft.InstanceProgress, error)) *FullNode_F3GetProgress_Call {
	_c.Call.Return(run)
	return _c
}

// F3IsRunning provides a mock function for the type FullNode
func (_mock *FullNode) F3IsRunning(ctx context.Context) (bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3IsRunning")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3IsRunning'
type FullNode_F3IsRunning_Call struct {
	*mock.Call
}

// F3IsRunning is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) F3IsRunning(ctx interface{}) *FullNode_F3IsRunning_Call {
	return &FullNode_F3IsRunning_Call{Call: _e.mock.On("F3IsRunning", ctx)}
}

func (_c *FullNode_F3IsRunning_Call) Run(run func(ctx context.Context)) *FullNode_F3IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_F3IsRunning_Call) Return(b bool, err error) *FullNode_F3IsRunning_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_F3IsRunning_Call) RunAndReturn(run func(ctx context.Context) (bool, error)) *FullNode_F3IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// F3ListParticipants provides a mock function for the type FullNode
func (_mock *FullNode) F3ListParticipants(ctx context.Context) ([]api.F3Participant, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3ListParticipants")
	}

	var r0 []api.F3Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]api.F3Participant, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []api.F3Participant); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.F3Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3ListParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3ListParticipants'
type FullNode_F3ListParticipants_Call struct {
	*mock.Call
}

// F3ListParticipants is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) F3ListParticipants(ctx interface{}) *FullNode_F3ListParticipants_Call {
	return &FullNode_F3ListParticipants_Call{Call: _e.mock.On("F3ListParticipants", ctx)}
}

func (_c *FullNode_F3ListParticipants_Call) Run(run func(ctx context.Context)) *FullNode_F3ListParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_F3ListParticipants_Call) Return(f3Participants []api.F3Participant, err error) *FullNode_F3ListParticipants_Call {
	_c.Call.Return(f3Participants, err)
	return _c
}

func (_c *FullNode_F3ListParticipants_Call) RunAndReturn(run func(ctx context.Context) ([]api.F3Participant, error)) *FullNode_F3ListParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// F3Participate provides a mock function for the type FullNode
func (_mock *FullNode) F3Participate(ctx context.Context, ticket api.F3ParticipationTicket) (api.F3ParticipationLease, error) {
	ret := _mock.Called(ctx, ticket)

	if len(ret) == 0 {
		panic("no return value specified for F3Participate")
	}

	var r0 api.F3ParticipationLease
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.F3ParticipationTicket) (api.F3ParticipationLease, error)); ok {
		return returnFunc(ctx, ticket)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.F3ParticipationTicket) api.F3ParticipationLease); ok {
		r0 = returnFunc(ctx, ticket)
	} else {
		r0 = ret.Get(0).(api.F3ParticipationLease)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, api.F3ParticipationTicket) error); ok {
		r1 = returnFunc(ctx, ticket)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_F3Participate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F3Participate'
type FullNode_F3Participate_Call struct {
	*mock.Call
}

// F3Participate is a helper method to define mock.On call
//   - ctx
//   - ticket
func (_e *FullNode_Expecter) F3Participate(ctx interface{}, ticket interface{}) *FullNode_F3Participate_Call {
	return &FullNode_F3Participate_Call{Call: _e.mock.On("F3Participate", ctx, ticket)}
}

func (_c *FullNode_F3Participate_Call) Run(run func(ctx context.Context, ticket api.F3ParticipationTicket)) *FullNode_F3Participate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(api.F3ParticipationTicket))
	})
	return _c
}

func (_c *FullNode_F3Participate_Call) Return(f3ParticipationLease api.F3ParticipationLease, err error) *FullNode_F3Participate_Call {
	_c.Call.Return(f3ParticipationLease, err)
	return _c
}

func (_c *FullNode_F3Participate_Call) RunAndReturn(run func(ctx context.Context, ticket api.F3ParticipationTicket) (api.F3ParticipationLease, error)) *FullNode_F3Participate_Call {
	_c.Call.Return(run)
	return _c
}

// FilecoinAddressToEthAddress provides a mock function for the type FullNode
func (_mock *FullNode) FilecoinAddressToEthAddress(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthAddress, error) {
	ret := _mock.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for FilecoinAddressToEthAddress")
	}

	var r0 ethtypes.EthAddress
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthAddress, error)); ok {
		return returnFunc(ctx, p)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthAddress); ok {
		r0 = returnFunc(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthAddress)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = returnFunc(ctx, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_FilecoinAddressToEthAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilecoinAddressToEthAddress'
type FullNode_FilecoinAddressToEthAddress_Call struct {
	*mock.Call
}

// FilecoinAddressToEthAddress is a helper method to define mock.On call
//   - ctx
//   - p
func (_e *FullNode_Expecter) FilecoinAddressToEthAddress(ctx interface{}, p interface{}) *FullNode_FilecoinAddressToEthAddress_Call {
	return &FullNode_FilecoinAddressToEthAddress_Call{Call: _e.mock.On("FilecoinAddressToEthAddress", ctx, p)}
}

func (_c *FullNode_FilecoinAddressToEthAddress_Call) Run(run func(ctx context.Context, p jsonrpc.RawParams)) *FullNode_FilecoinAddressToEthAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jsonrpc.RawParams))
	})
	return _c
}

func (_c *FullNode_FilecoinAddressToEthAddress_Call) Return(ethAddress ethtypes.EthAddress, err error) *FullNode_FilecoinAddressToEthAddress_Call {
	_c.Call.Return(ethAddress, err)
	return _c
}

func (_c *FullNode_FilecoinAddressToEthAddress_Call) RunAndReturn(run func(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthAddress, error)) *FullNode_FilecoinAddressToEthAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GasEstimateFeeCap provides a mock function for the type FullNode
func (_mock *FullNode) GasEstimateFeeCap(context1 context.Context, message *types.Message, n int64, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, message, n, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateFeeCap")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, int64, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, message, n, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, int64, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, message, n, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Message, int64, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, message, n, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_GasEstimateFeeCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GasEstimateFeeCap'
type FullNode_GasEstimateFeeCap_Call struct {
	*mock.Call
}

// GasEstimateFeeCap is a helper method to define mock.On call
//   - context1
//   - message
//   - n
//   - tipSetKey
func (_e *FullNode_Expecter) GasEstimateFeeCap(context1 interface{}, message interface{}, n interface{}, tipSetKey interface{}) *FullNode_GasEstimateFeeCap_Call {
	return &FullNode_GasEstimateFeeCap_Call{Call: _e.mock.On("GasEstimateFeeCap", context1, message, n, tipSetKey)}
}

func (_c *FullNode_GasEstimateFeeCap_Call) Run(run func(context1 context.Context, message *types.Message, n int64, tipSetKey types.TipSetKey)) *FullNode_GasEstimateFeeCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Message), args[2].(int64), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_GasEstimateFeeCap_Call) Return(v types.BigInt, err error) *FullNode_GasEstimateFeeCap_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_GasEstimateFeeCap_Call) RunAndReturn(run func(context1 context.Context, message *types.Message, n int64, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_GasEstimateFeeCap_Call {
	_c.Call.Return(run)
	return _c
}

// GasEstimateGasLimit provides a mock function for the type FullNode
func (_mock *FullNode) GasEstimateGasLimit(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey) (int64, error) {
	ret := _mock.Called(context1, message, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateGasLimit")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) (int64, error)); ok {
		return returnFunc(context1, message, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) int64); ok {
		r0 = returnFunc(context1, message, tipSetKey)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, message, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_GasEstimateGasLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GasEstimateGasLimit'
type FullNode_GasEstimateGasLimit_Call struct {
	*mock.Call
}

// GasEstimateGasLimit is a helper method to define mock.On call
//   - context1
//   - message
//   - tipSetKey
func (_e *FullNode_Expecter) GasEstimateGasLimit(context1 interface{}, message interface{}, tipSetKey interface{}) *FullNode_GasEstimateGasLimit_Call {
	return &FullNode_GasEstimateGasLimit_Call{Call: _e.mock.On("GasEstimateGasLimit", context1, message, tipSetKey)}
}

func (_c *FullNode_GasEstimateGasLimit_Call) Run(run func(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey)) *FullNode_GasEstimateGasLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Message), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_GasEstimateGasLimit_Call) Return(n int64, err error) *FullNode_GasEstimateGasLimit_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *FullNode_GasEstimateGasLimit_Call) RunAndReturn(run func(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey) (int64, error)) *FullNode_GasEstimateGasLimit_Call {
	_c.Call.Return(run)
	return _c
}

// GasEstimateGasPremium provides a mock function for the type FullNode
func (_mock *FullNode) GasEstimateGasPremium(context1 context.Context, nblocksincl uint64, sender address.Address, gaslimit int64, tsk types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, nblocksincl, sender, gaslimit, tsk)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateGasPremium")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, nblocksincl, sender, gaslimit, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, nblocksincl, sender, gaslimit, tsk)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, nblocksincl, sender, gaslimit, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_GasEstimateGasPremium_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GasEstimateGasPremium'
type FullNode_GasEstimateGasPremium_Call struct {
	*mock.Call
}

// GasEstimateGasPremium is a helper method to define mock.On call
//   - context1
//   - nblocksincl
//   - sender
//   - gaslimit
//   - tsk
func (_e *FullNode_Expecter) GasEstimateGasPremium(context1 interface{}, nblocksincl interface{}, sender interface{}, gaslimit interface{}, tsk interface{}) *FullNode_GasEstimateGasPremium_Call {
	return &FullNode_GasEstimateGasPremium_Call{Call: _e.mock.On("GasEstimateGasPremium", context1, nblocksincl, sender, gaslimit, tsk)}
}

func (_c *FullNode_GasEstimateGasPremium_Call) Run(run func(context1 context.Context, nblocksincl uint64, sender address.Address, gaslimit int64, tsk types.TipSetKey)) *FullNode_GasEstimateGasPremium_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(address.Address), args[3].(int64), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_GasEstimateGasPremium_Call) Return(v types.BigInt, err error) *FullNode_GasEstimateGasPremium_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_GasEstimateGasPremium_Call) RunAndReturn(run func(context1 context.Context, nblocksincl uint64, sender address.Address, gaslimit int64, tsk types.TipSetKey) (types.BigInt, error)) *FullNode_GasEstimateGasPremium_Call {
	_c.Call.Return(run)
	return _c
}

// GasEstimateMessageGas provides a mock function for the type FullNode
func (_mock *FullNode) GasEstimateMessageGas(context1 context.Context, message *types.Message, messageSendSpec *api.MessageSendSpec, tipSetKey types.TipSetKey) (*types.Message, error) {
	ret := _mock.Called(context1, message, messageSendSpec, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateMessageGas")
	}

	var r0 *types.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) (*types.Message, error)); ok {
		return returnFunc(context1, message, messageSendSpec, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) *types.Message); ok {
		r0 = returnFunc(context1, message, messageSendSpec, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, message, messageSendSpec, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_GasEstimateMessageGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GasEstimateMessageGas'
type FullNode_GasEstimateMessageGas_Call struct {
	*mock.Call
}

// GasEstimateMessageGas is a helper method to define mock.On call
//   - context1
//   - message
//   - messageSendSpec
//   - tipSetKey
func (_e *FullNode_Expecter) GasEstimateMessageGas(context1 interface{}, message interface{}, messageSendSpec interface{}, tipSetKey interface{}) *FullNode_GasEstimateMessageGas_Call {
	return &FullNode_GasEstimateMessageGas_Call{Call: _e.mock.On("GasEstimateMessageGas", context1, message, messageSendSpec, tipSetKey)}
}

func (_c *FullNode_GasEstimateMessageGas_Call) Run(run func(context1 context.Context, message *types.Message, messageSendSpec *api.MessageSendSpec, tipSetKey types.TipSetKey)) *FullNode_GasEstimateMessageGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Message), args[2].(*api.MessageSendSpec), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_GasEstimateMessageGas_Call) Return(message1 *types.Message, err error) *FullNode_GasEstimateMessageGas_Call {
	_c.Call.Return(message1, err)
	return _c
}

func (_c *FullNode_GasEstimateMessageGas_Call) RunAndReturn(run func(context1 context.Context, message *types.Message, messageSendSpec *api.MessageSendSpec, tipSetKey types.TipSetKey) (*types.Message, error)) *FullNode_GasEstimateMessageGas_Call {
	_c.Call.Return(run)
	return _c
}

// GetActorEventsRaw provides a mock function for the type FullNode
func (_mock *FullNode) GetActorEventsRaw(ctx context.Context, filter *types.ActorEventFilter) ([]*types.ActorEvent, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetActorEventsRaw")
	}

	var r0 []*types.ActorEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) ([]*types.ActorEvent, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) []*types.ActorEvent); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.ActorEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.ActorEventFilter) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_GetActorEventsRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActorEventsRaw'
type FullNode_GetActorEventsRaw_Call struct {
	*mock.Call
}

// GetActorEventsRaw is a helper method to define mock.On call
//   - ctx
//   - filter
func (_e *FullNode_Expecter) GetActorEventsRaw(ctx interface{}, filter interface{}) *FullNode_GetActorEventsRaw_Call {
	return &FullNode_GetActorEventsRaw_Call{Call: _e.mock.On("GetActorEventsRaw", ctx, filter)}
}

func (_c *FullNode_GetActorEventsRaw_Call) Run(run func(ctx context.Context, filter *types.ActorEventFilter)) *FullNode_GetActorEventsRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.ActorEventFilter))
	})
	return _c
}

func (_c *FullNode_GetActorEventsRaw_Call) Return(actorEvents []*types.ActorEvent, err error) *FullNode_GetActorEventsRaw_Call {
	_c.Call.Return(actorEvents, err)
	return _c
}

func (_c *FullNode_GetActorEventsRaw_Call) RunAndReturn(run func(ctx context.Context, filter *types.ActorEventFilter) ([]*types.ActorEvent, error)) *FullNode_GetActorEventsRaw_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type FullNode
func (_mock *FullNode) ID(context1 context.Context) (peer.ID, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 peer.ID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (peer.ID, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) peer.ID); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type FullNode_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) ID(context1 interface{}) *FullNode_ID_Call {
	return &FullNode_ID_Call{Call: _e.mock.On("ID", context1)}
}

func (_c *FullNode_ID_Call) Run(run func(context1 context.Context)) *FullNode_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_ID_Call) Return(iD peer.ID, err error) *FullNode_ID_Call {
	_c.Call.Return(iD, err)
	return _c
}

func (_c *FullNode_ID_Call) RunAndReturn(run func(context1 context.Context) (peer.ID, error)) *FullNode_ID_Call {
	_c.Call.Return(run)
	return _c
}

// LogAlerts provides a mock function for the type FullNode
func (_mock *FullNode) LogAlerts(ctx context.Context) ([]alerting.Alert, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LogAlerts")
	}

	var r0 []alerting.Alert
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]alerting.Alert, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []alerting.Alert); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]alerting.Alert)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_LogAlerts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogAlerts'
type FullNode_LogAlerts_Call struct {
	*mock.Call
}

// LogAlerts is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) LogAlerts(ctx interface{}) *FullNode_LogAlerts_Call {
	return &FullNode_LogAlerts_Call{Call: _e.mock.On("LogAlerts", ctx)}
}

func (_c *FullNode_LogAlerts_Call) Run(run func(ctx context.Context)) *FullNode_LogAlerts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_LogAlerts_Call) Return(alerts []alerting.Alert, err error) *FullNode_LogAlerts_Call {
	_c.Call.Return(alerts, err)
	return _c
}

func (_c *FullNode_LogAlerts_Call) RunAndReturn(run func(ctx context.Context) ([]alerting.Alert, error)) *FullNode_LogAlerts_Call {
	_c.Call.Return(run)
	return _c
}

// LogList provides a mock function for the type FullNode
func (_mock *FullNode) LogList(context1 context.Context) ([]string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for LogList")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_LogList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogList'
type FullNode_LogList_Call struct {
	*mock.Call
}

// LogList is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) LogList(context1 interface{}) *FullNode_LogList_Call {
	return &FullNode_LogList_Call{Call: _e.mock.On("LogList", context1)}
}

func (_c *FullNode_LogList_Call) Run(run func(context1 context.Context)) *FullNode_LogList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_LogList_Call) Return(strings []string, err error) *FullNode_LogList_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *FullNode_LogList_Call) RunAndReturn(run func(context1 context.Context) ([]string, error)) *FullNode_LogList_Call {
	_c.Call.Return(run)
	return _c
}

// LogSetLevel provides a mock function for the type FullNode
func (_mock *FullNode) LogSetLevel(context1 context.Context, s string, s1 string) error {
	ret := _mock.Called(context1, s, s1)

	if len(ret) == 0 {
		panic("no return value specified for LogSetLevel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(context1, s, s1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_LogSetLevel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogSetLevel'
type FullNode_LogSetLevel_Call struct {
	*mock.Call
}

// LogSetLevel is a helper method to define mock.On call
//   - context1
//   - s
//   - s1
func (_e *FullNode_Expecter) LogSetLevel(context1 interface{}, s interface{}, s1 interface{}) *FullNode_LogSetLevel_Call {
	return &FullNode_LogSetLevel_Call{Call: _e.mock.On("LogSetLevel", context1, s, s1)}
}

func (_c *FullNode_LogSetLevel_Call) Run(run func(context1 context.Context, s string, s1 string)) *FullNode_LogSetLevel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *FullNode_LogSetLevel_Call) Return(err error) *FullNode_LogSetLevel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_LogSetLevel_Call) RunAndReturn(run func(context1 context.Context, s string, s1 string) error) *FullNode_LogSetLevel_Call {
	_c.Call.Return(run)
	return _c
}

// MarketAddBalance provides a mock function for the type FullNode
func (_mock *FullNode) MarketAddBalance(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error) {
	ret := _mock.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketAddBalance")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) (cid.Cid, error)); ok {
		return returnFunc(ctx, wallet, addr, amt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) cid.Cid); ok {
		r0 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt) error); ok {
		r1 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MarketAddBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarketAddBalance'
type FullNode_MarketAddBalance_Call struct {
	*mock.Call
}

// MarketAddBalance is a helper method to define mock.On call
//   - ctx
//   - wallet
//   - addr
//   - amt
func (_e *FullNode_Expecter) MarketAddBalance(ctx interface{}, wallet interface{}, addr interface{}, amt interface{}) *FullNode_MarketAddBalance_Call {
	return &FullNode_MarketAddBalance_Call{Call: _e.mock.On("MarketAddBalance", ctx, wallet, addr, amt)}
}

func (_c *FullNode_MarketAddBalance_Call) Run(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt)) *FullNode_MarketAddBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_MarketAddBalance_Call) Return(cid1 cid.Cid, err error) *FullNode_MarketAddBalance_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_MarketAddBalance_Call) RunAndReturn(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error)) *FullNode_MarketAddBalance_Call {
	_c.Call.Return(run)
	return _c
}

// MarketGetReserved provides a mock function for the type FullNode
func (_mock *FullNode) MarketGetReserved(ctx context.Context, addr address.Address) (types.BigInt, error) {
	ret := _mock.Called(ctx, addr)

	if len(ret) == 0 {
		panic("no return value specified for MarketGetReserved")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (types.BigInt, error)); ok {
		return returnFunc(ctx, addr)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) types.BigInt); ok {
		r0 = returnFunc(ctx, addr)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MarketGetReserved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarketGetReserved'
type FullNode_MarketGetReserved_Call struct {
	*mock.Call
}

// MarketGetReserved is a helper method to define mock.On call
//   - ctx
//   - addr
func (_e *FullNode_Expecter) MarketGetReserved(ctx interface{}, addr interface{}) *FullNode_MarketGetReserved_Call {
	return &FullNode_MarketGetReserved_Call{Call: _e.mock.On("MarketGetReserved", ctx, addr)}
}

func (_c *FullNode_MarketGetReserved_Call) Run(run func(ctx context.Context, addr address.Address)) *FullNode_MarketGetReserved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_MarketGetReserved_Call) Return(v types.BigInt, err error) *FullNode_MarketGetReserved_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_MarketGetReserved_Call) RunAndReturn(run func(ctx context.Context, addr address.Address) (types.BigInt, error)) *FullNode_MarketGetReserved_Call {
	_c.Call.Return(run)
	return _c
}

// MarketReleaseFunds provides a mock function for the type FullNode
func (_mock *FullNode) MarketReleaseFunds(ctx context.Context, addr address.Address, amt types.BigInt) error {
	ret := _mock.Called(ctx, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketReleaseFunds")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.BigInt) error); ok {
		r0 = returnFunc(ctx, addr, amt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_MarketReleaseFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarketReleaseFunds'
type FullNode_MarketReleaseFunds_Call struct {
	*mock.Call
}

// MarketReleaseFunds is a helper method to define mock.On call
//   - ctx
//   - addr
//   - amt
func (_e *FullNode_Expecter) MarketReleaseFunds(ctx interface{}, addr interface{}, amt interface{}) *FullNode_MarketReleaseFunds_Call {
	return &FullNode_MarketReleaseFunds_Call{Call: _e.mock.On("MarketReleaseFunds", ctx, addr, amt)}
}

func (_c *FullNode_MarketReleaseFunds_Call) Run(run func(ctx context.Context, addr address.Address, amt types.BigInt)) *FullNode_MarketReleaseFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_MarketReleaseFunds_Call) Return(err error) *FullNode_MarketReleaseFunds_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_MarketReleaseFunds_Call) RunAndReturn(run func(ctx context.Context, addr address.Address, amt types.BigInt) error) *FullNode_MarketReleaseFunds_Call {
	_c.Call.Return(run)
	return _c
}

// MarketReserveFunds provides a mock function for the type FullNode
func (_mock *FullNode) MarketReserveFunds(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error) {
	ret := _mock.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketReserveFunds")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) (cid.Cid, error)); ok {
		return returnFunc(ctx, wallet, addr, amt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) cid.Cid); ok {
		r0 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt) error); ok {
		r1 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MarketReserveFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarketReserveFunds'
type FullNode_MarketReserveFunds_Call struct {
	*mock.Call
}

// MarketReserveFunds is a helper method to define mock.On call
//   - ctx
//   - wallet
//   - addr
//   - amt
func (_e *FullNode_Expecter) MarketReserveFunds(ctx interface{}, wallet interface{}, addr interface{}, amt interface{}) *FullNode_MarketReserveFunds_Call {
	return &FullNode_MarketReserveFunds_Call{Call: _e.mock.On("MarketReserveFunds", ctx, wallet, addr, amt)}
}

func (_c *FullNode_MarketReserveFunds_Call) Run(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt)) *FullNode_MarketReserveFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_MarketReserveFunds_Call) Return(cid1 cid.Cid, err error) *FullNode_MarketReserveFunds_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_MarketReserveFunds_Call) RunAndReturn(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error)) *FullNode_MarketReserveFunds_Call {
	_c.Call.Return(run)
	return _c
}

// MarketWithdraw provides a mock function for the type FullNode
func (_mock *FullNode) MarketWithdraw(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error) {
	ret := _mock.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketWithdraw")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) (cid.Cid, error)); ok {
		return returnFunc(ctx, wallet, addr, amt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) cid.Cid); ok {
		r0 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt) error); ok {
		r1 = returnFunc(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MarketWithdraw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarketWithdraw'
type FullNode_MarketWithdraw_Call struct {
	*mock.Call
}

// MarketWithdraw is a helper method to define mock.On call
//   - ctx
//   - wallet
//   - addr
//   - amt
func (_e *FullNode_Expecter) MarketWithdraw(ctx interface{}, wallet interface{}, addr interface{}, amt interface{}) *FullNode_MarketWithdraw_Call {
	return &FullNode_MarketWithdraw_Call{Call: _e.mock.On("MarketWithdraw", ctx, wallet, addr, amt)}
}

func (_c *FullNode_MarketWithdraw_Call) Run(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt)) *FullNode_MarketWithdraw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_MarketWithdraw_Call) Return(cid1 cid.Cid, err error) *FullNode_MarketWithdraw_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_MarketWithdraw_Call) RunAndReturn(run func(ctx context.Context, wallet address.Address, addr address.Address, amt types.BigInt) (cid.Cid, error)) *FullNode_MarketWithdraw_Call {
	_c.Call.Return(run)
	return _c
}

// MinerCreateBlock provides a mock function for the type FullNode
func (_mock *FullNode) MinerCreateBlock(context1 context.Context, blockTemplate *api.BlockTemplate) (*types.BlockMsg, error) {
	ret := _mock.Called(context1, blockTemplate)

	if len(ret) == 0 {
		panic("no return value specified for MinerCreateBlock")
	}

	var r0 *types.BlockMsg
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *api.BlockTemplate) (*types.BlockMsg, error)); ok {
		return returnFunc(context1, blockTemplate)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *api.BlockTemplate) *types.BlockMsg); ok {
		r0 = returnFunc(context1, blockTemplate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockMsg)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *api.BlockTemplate) error); ok {
		r1 = returnFunc(context1, blockTemplate)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MinerCreateBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerCreateBlock'
type FullNode_MinerCreateBlock_Call struct {
	*mock.Call
}

// MinerCreateBlock is a helper method to define mock.On call
//   - context1
//   - blockTemplate
func (_e *FullNode_Expecter) MinerCreateBlock(context1 interface{}, blockTemplate interface{}) *FullNode_MinerCreateBlock_Call {
	return &FullNode_MinerCreateBlock_Call{Call: _e.mock.On("MinerCreateBlock", context1, blockTemplate)}
}

func (_c *FullNode_MinerCreateBlock_Call) Run(run func(context1 context.Context, blockTemplate *api.BlockTemplate)) *FullNode_MinerCreateBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api.BlockTemplate))
	})
	return _c
}

func (_c *FullNode_MinerCreateBlock_Call) Return(blockMsg *types.BlockMsg, err error) *FullNode_MinerCreateBlock_Call {
	_c.Call.Return(blockMsg, err)
	return _c
}

func (_c *FullNode_MinerCreateBlock_Call) RunAndReturn(run func(context1 context.Context, blockTemplate *api.BlockTemplate) (*types.BlockMsg, error)) *FullNode_MinerCreateBlock_Call {
	_c.Call.Return(run)
	return _c
}

// MinerGetBaseInfo provides a mock function for the type FullNode
func (_mock *FullNode) MinerGetBaseInfo(context1 context.Context, address1 address.Address, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*api.MiningBaseInfo, error) {
	ret := _mock.Called(context1, address1, chainEpoch, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for MinerGetBaseInfo")
	}

	var r0 *api.MiningBaseInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) (*api.MiningBaseInfo, error)); ok {
		return returnFunc(context1, address1, chainEpoch, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) *api.MiningBaseInfo); ok {
		r0 = returnFunc(context1, address1, chainEpoch, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MiningBaseInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, chainEpoch, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MinerGetBaseInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerGetBaseInfo'
type FullNode_MinerGetBaseInfo_Call struct {
	*mock.Call
}

// MinerGetBaseInfo is a helper method to define mock.On call
//   - context1
//   - address1
//   - chainEpoch
//   - tipSetKey
func (_e *FullNode_Expecter) MinerGetBaseInfo(context1 interface{}, address1 interface{}, chainEpoch interface{}, tipSetKey interface{}) *FullNode_MinerGetBaseInfo_Call {
	return &FullNode_MinerGetBaseInfo_Call{Call: _e.mock.On("MinerGetBaseInfo", context1, address1, chainEpoch, tipSetKey)}
}

func (_c *FullNode_MinerGetBaseInfo_Call) Run(run func(context1 context.Context, address1 address.Address, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey)) *FullNode_MinerGetBaseInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.ChainEpoch), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MinerGetBaseInfo_Call) Return(miningBaseInfo *api.MiningBaseInfo, err error) *FullNode_MinerGetBaseInfo_Call {
	_c.Call.Return(miningBaseInfo, err)
	return _c
}

func (_c *FullNode_MinerGetBaseInfo_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, chainEpoch abi.ChainEpoch, tipSetKey types.TipSetKey) (*api.MiningBaseInfo, error)) *FullNode_MinerGetBaseInfo_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolBatchPush provides a mock function for the type FullNode
func (_mock *FullNode) MpoolBatchPush(context1 context.Context, signedMessages []*types.SignedMessage) ([]cid.Cid, error) {
	ret := _mock.Called(context1, signedMessages)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPush")
	}

	var r0 []cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) ([]cid.Cid, error)); ok {
		return returnFunc(context1, signedMessages)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) []cid.Cid); ok {
		r0 = returnFunc(context1, signedMessages)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*types.SignedMessage) error); ok {
		r1 = returnFunc(context1, signedMessages)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolBatchPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolBatchPush'
type FullNode_MpoolBatchPush_Call struct {
	*mock.Call
}

// MpoolBatchPush is a helper method to define mock.On call
//   - context1
//   - signedMessages
func (_e *FullNode_Expecter) MpoolBatchPush(context1 interface{}, signedMessages interface{}) *FullNode_MpoolBatchPush_Call {
	return &FullNode_MpoolBatchPush_Call{Call: _e.mock.On("MpoolBatchPush", context1, signedMessages)}
}

func (_c *FullNode_MpoolBatchPush_Call) Run(run func(context1 context.Context, signedMessages []*types.SignedMessage)) *FullNode_MpoolBatchPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*types.SignedMessage))
	})
	return _c
}

func (_c *FullNode_MpoolBatchPush_Call) Return(cids []cid.Cid, err error) *FullNode_MpoolBatchPush_Call {
	_c.Call.Return(cids, err)
	return _c
}

func (_c *FullNode_MpoolBatchPush_Call) RunAndReturn(run func(context1 context.Context, signedMessages []*types.SignedMessage) ([]cid.Cid, error)) *FullNode_MpoolBatchPush_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolBatchPushMessage provides a mock function for the type FullNode
func (_mock *FullNode) MpoolBatchPushMessage(context1 context.Context, messages []*types.Message, messageSendSpec *api.MessageSendSpec) ([]*types.SignedMessage, error) {
	ret := _mock.Called(context1, messages, messageSendSpec)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPushMessage")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.Message, *api.MessageSendSpec) ([]*types.SignedMessage, error)); ok {
		return returnFunc(context1, messages, messageSendSpec)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.Message, *api.MessageSendSpec) []*types.SignedMessage); ok {
		r0 = returnFunc(context1, messages, messageSendSpec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*types.Message, *api.MessageSendSpec) error); ok {
		r1 = returnFunc(context1, messages, messageSendSpec)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolBatchPushMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolBatchPushMessage'
type FullNode_MpoolBatchPushMessage_Call struct {
	*mock.Call
}

// MpoolBatchPushMessage is a helper method to define mock.On call
//   - context1
//   - messages
//   - messageSendSpec
func (_e *FullNode_Expecter) MpoolBatchPushMessage(context1 interface{}, messages interface{}, messageSendSpec interface{}) *FullNode_MpoolBatchPushMessage_Call {
	return &FullNode_MpoolBatchPushMessage_Call{Call: _e.mock.On("MpoolBatchPushMessage", context1, messages, messageSendSpec)}
}

func (_c *FullNode_MpoolBatchPushMessage_Call) Run(run func(context1 context.Context, messages []*types.Message, messageSendSpec *api.MessageSendSpec)) *FullNode_MpoolBatchPushMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*types.Message), args[2].(*api.MessageSendSpec))
	})
	return _c
}

func (_c *FullNode_MpoolBatchPushMessage_Call) Return(signedMessages []*types.SignedMessage, err error) *FullNode_MpoolBatchPushMessage_Call {
	_c.Call.Return(signedMessages, err)
	return _c
}

func (_c *FullNode_MpoolBatchPushMessage_Call) RunAndReturn(run func(context1 context.Context, messages []*types.Message, messageSendSpec *api.MessageSendSpec) ([]*types.SignedMessage, error)) *FullNode_MpoolBatchPushMessage_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolBatchPushUntrusted provides a mock function for the type FullNode
func (_mock *FullNode) MpoolBatchPushUntrusted(context1 context.Context, signedMessages []*types.SignedMessage) ([]cid.Cid, error) {
	ret := _mock.Called(context1, signedMessages)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPushUntrusted")
	}

	var r0 []cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) ([]cid.Cid, error)); ok {
		return returnFunc(context1, signedMessages)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) []cid.Cid); ok {
		r0 = returnFunc(context1, signedMessages)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*types.SignedMessage) error); ok {
		r1 = returnFunc(context1, signedMessages)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolBatchPushUntrusted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolBatchPushUntrusted'
type FullNode_MpoolBatchPushUntrusted_Call struct {
	*mock.Call
}

// MpoolBatchPushUntrusted is a helper method to define mock.On call
//   - context1
//   - signedMessages
func (_e *FullNode_Expecter) MpoolBatchPushUntrusted(context1 interface{}, signedMessages interface{}) *FullNode_MpoolBatchPushUntrusted_Call {
	return &FullNode_MpoolBatchPushUntrusted_Call{Call: _e.mock.On("MpoolBatchPushUntrusted", context1, signedMessages)}
}

func (_c *FullNode_MpoolBatchPushUntrusted_Call) Run(run func(context1 context.Context, signedMessages []*types.SignedMessage)) *FullNode_MpoolBatchPushUntrusted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*types.SignedMessage))
	})
	return _c
}

func (_c *FullNode_MpoolBatchPushUntrusted_Call) Return(cids []cid.Cid, err error) *FullNode_MpoolBatchPushUntrusted_Call {
	_c.Call.Return(cids, err)
	return _c
}

func (_c *FullNode_MpoolBatchPushUntrusted_Call) RunAndReturn(run func(context1 context.Context, signedMessages []*types.SignedMessage) ([]cid.Cid, error)) *FullNode_MpoolBatchPushUntrusted_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolCheckMessages provides a mock function for the type FullNode
func (_mock *FullNode) MpoolCheckMessages(context1 context.Context, messagePrototypes []*api.MessagePrototype) ([][]api.MessageCheckStatus, error) {
	ret := _mock.Called(context1, messagePrototypes)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*api.MessagePrototype) ([][]api.MessageCheckStatus, error)); ok {
		return returnFunc(context1, messagePrototypes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*api.MessagePrototype) [][]api.MessageCheckStatus); ok {
		r0 = returnFunc(context1, messagePrototypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*api.MessagePrototype) error); ok {
		r1 = returnFunc(context1, messagePrototypes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolCheckMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolCheckMessages'
type FullNode_MpoolCheckMessages_Call struct {
	*mock.Call
}

// MpoolCheckMessages is a helper method to define mock.On call
//   - context1
//   - messagePrototypes
func (_e *FullNode_Expecter) MpoolCheckMessages(context1 interface{}, messagePrototypes interface{}) *FullNode_MpoolCheckMessages_Call {
	return &FullNode_MpoolCheckMessages_Call{Call: _e.mock.On("MpoolCheckMessages", context1, messagePrototypes)}
}

func (_c *FullNode_MpoolCheckMessages_Call) Run(run func(context1 context.Context, messagePrototypes []*api.MessagePrototype)) *FullNode_MpoolCheckMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*api.MessagePrototype))
	})
	return _c
}

func (_c *FullNode_MpoolCheckMessages_Call) Return(messageCheckStatusss [][]api.MessageCheckStatus, err error) *FullNode_MpoolCheckMessages_Call {
	_c.Call.Return(messageCheckStatusss, err)
	return _c
}

func (_c *FullNode_MpoolCheckMessages_Call) RunAndReturn(run func(context1 context.Context, messagePrototypes []*api.MessagePrototype) ([][]api.MessageCheckStatus, error)) *FullNode_MpoolCheckMessages_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolCheckPendingMessages provides a mock function for the type FullNode
func (_mock *FullNode) MpoolCheckPendingMessages(context1 context.Context, address1 address.Address) ([][]api.MessageCheckStatus, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckPendingMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) ([][]api.MessageCheckStatus, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) [][]api.MessageCheckStatus); ok {
		r0 = returnFunc(context1, address1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolCheckPendingMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolCheckPendingMessages'
type FullNode_MpoolCheckPendingMessages_Call struct {
	*mock.Call
}

// MpoolCheckPendingMessages is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) MpoolCheckPendingMessages(context1 interface{}, address1 interface{}) *FullNode_MpoolCheckPendingMessages_Call {
	return &FullNode_MpoolCheckPendingMessages_Call{Call: _e.mock.On("MpoolCheckPendingMessages", context1, address1)}
}

func (_c *FullNode_MpoolCheckPendingMessages_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_MpoolCheckPendingMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_MpoolCheckPendingMessages_Call) Return(messageCheckStatusss [][]api.MessageCheckStatus, err error) *FullNode_MpoolCheckPendingMessages_Call {
	_c.Call.Return(messageCheckStatusss, err)
	return _c
}

func (_c *FullNode_MpoolCheckPendingMessages_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) ([][]api.MessageCheckStatus, error)) *FullNode_MpoolCheckPendingMessages_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolCheckReplaceMessages provides a mock function for the type FullNode
func (_mock *FullNode) MpoolCheckReplaceMessages(context1 context.Context, messages []*types.Message) ([][]api.MessageCheckStatus, error) {
	ret := _mock.Called(context1, messages)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckReplaceMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.Message) ([][]api.MessageCheckStatus, error)); ok {
		return returnFunc(context1, messages)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*types.Message) [][]api.MessageCheckStatus); ok {
		r0 = returnFunc(context1, messages)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*types.Message) error); ok {
		r1 = returnFunc(context1, messages)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolCheckReplaceMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolCheckReplaceMessages'
type FullNode_MpoolCheckReplaceMessages_Call struct {
	*mock.Call
}

// MpoolCheckReplaceMessages is a helper method to define mock.On call
//   - context1
//   - messages
func (_e *FullNode_Expecter) MpoolCheckReplaceMessages(context1 interface{}, messages interface{}) *FullNode_MpoolCheckReplaceMessages_Call {
	return &FullNode_MpoolCheckReplaceMessages_Call{Call: _e.mock.On("MpoolCheckReplaceMessages", context1, messages)}
}

func (_c *FullNode_MpoolCheckReplaceMessages_Call) Run(run func(context1 context.Context, messages []*types.Message)) *FullNode_MpoolCheckReplaceMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*types.Message))
	})
	return _c
}

func (_c *FullNode_MpoolCheckReplaceMessages_Call) Return(messageCheckStatusss [][]api.MessageCheckStatus, err error) *FullNode_MpoolCheckReplaceMessages_Call {
	_c.Call.Return(messageCheckStatusss, err)
	return _c
}

func (_c *FullNode_MpoolCheckReplaceMessages_Call) RunAndReturn(run func(context1 context.Context, messages []*types.Message) ([][]api.MessageCheckStatus, error)) *FullNode_MpoolCheckReplaceMessages_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolClear provides a mock function for the type FullNode
func (_mock *FullNode) MpoolClear(ctx context.Context, clearLocal bool) error {
	ret := _mock.Called(ctx, clearLocal)

	if len(ret) == 0 {
		panic("no return value specified for MpoolClear")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) error); ok {
		r0 = returnFunc(ctx, clearLocal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_MpoolClear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolClear'
type FullNode_MpoolClear_Call struct {
	*mock.Call
}

// MpoolClear is a helper method to define mock.On call
//   - ctx
//   - clearLocal
func (_e *FullNode_Expecter) MpoolClear(ctx interface{}, clearLocal interface{}) *FullNode_MpoolClear_Call {
	return &FullNode_MpoolClear_Call{Call: _e.mock.On("MpoolClear", ctx, clearLocal)}
}

func (_c *FullNode_MpoolClear_Call) Run(run func(ctx context.Context, clearLocal bool)) *FullNode_MpoolClear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *FullNode_MpoolClear_Call) Return(err error) *FullNode_MpoolClear_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_MpoolClear_Call) RunAndReturn(run func(ctx context.Context, clearLocal bool) error) *FullNode_MpoolClear_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolGetConfig provides a mock function for the type FullNode
func (_mock *FullNode) MpoolGetConfig(context1 context.Context) (*types.MpoolConfig, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolGetConfig")
	}

	var r0 *types.MpoolConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*types.MpoolConfig, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *types.MpoolConfig); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MpoolConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolGetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolGetConfig'
type FullNode_MpoolGetConfig_Call struct {
	*mock.Call
}

// MpoolGetConfig is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) MpoolGetConfig(context1 interface{}) *FullNode_MpoolGetConfig_Call {
	return &FullNode_MpoolGetConfig_Call{Call: _e.mock.On("MpoolGetConfig", context1)}
}

func (_c *FullNode_MpoolGetConfig_Call) Run(run func(context1 context.Context)) *FullNode_MpoolGetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_MpoolGetConfig_Call) Return(mpoolConfig *types.MpoolConfig, err error) *FullNode_MpoolGetConfig_Call {
	_c.Call.Return(mpoolConfig, err)
	return _c
}

func (_c *FullNode_MpoolGetConfig_Call) RunAndReturn(run func(context1 context.Context) (*types.MpoolConfig, error)) *FullNode_MpoolGetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolGetNonce provides a mock function for the type FullNode
func (_mock *FullNode) MpoolGetNonce(context1 context.Context, address1 address.Address) (uint64, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolGetNonce")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (uint64, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolGetNonce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolGetNonce'
type FullNode_MpoolGetNonce_Call struct {
	*mock.Call
}

// MpoolGetNonce is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) MpoolGetNonce(context1 interface{}, address1 interface{}) *FullNode_MpoolGetNonce_Call {
	return &FullNode_MpoolGetNonce_Call{Call: _e.mock.On("MpoolGetNonce", context1, address1)}
}

func (_c *FullNode_MpoolGetNonce_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_MpoolGetNonce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_MpoolGetNonce_Call) Return(v uint64, err error) *FullNode_MpoolGetNonce_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_MpoolGetNonce_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (uint64, error)) *FullNode_MpoolGetNonce_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolPending provides a mock function for the type FullNode
func (_mock *FullNode) MpoolPending(context1 context.Context, tipSetKey types.TipSetKey) ([]*types.SignedMessage, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPending")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]*types.SignedMessage, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []*types.SignedMessage); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolPending'
type FullNode_MpoolPending_Call struct {
	*mock.Call
}

// MpoolPending is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) MpoolPending(context1 interface{}, tipSetKey interface{}) *FullNode_MpoolPending_Call {
	return &FullNode_MpoolPending_Call{Call: _e.mock.On("MpoolPending", context1, tipSetKey)}
}

func (_c *FullNode_MpoolPending_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_MpoolPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MpoolPending_Call) Return(signedMessages []*types.SignedMessage, err error) *FullNode_MpoolPending_Call {
	_c.Call.Return(signedMessages, err)
	return _c
}

func (_c *FullNode_MpoolPending_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) ([]*types.SignedMessage, error)) *FullNode_MpoolPending_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolPush provides a mock function for the type FullNode
func (_mock *FullNode) MpoolPush(context1 context.Context, signedMessage *types.SignedMessage) (cid.Cid, error) {
	ret := _mock.Called(context1, signedMessage)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPush")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) (cid.Cid, error)); ok {
		return returnFunc(context1, signedMessage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) cid.Cid); ok {
		r0 = returnFunc(context1, signedMessage)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.SignedMessage) error); ok {
		r1 = returnFunc(context1, signedMessage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolPush'
type FullNode_MpoolPush_Call struct {
	*mock.Call
}

// MpoolPush is a helper method to define mock.On call
//   - context1
//   - signedMessage
func (_e *FullNode_Expecter) MpoolPush(context1 interface{}, signedMessage interface{}) *FullNode_MpoolPush_Call {
	return &FullNode_MpoolPush_Call{Call: _e.mock.On("MpoolPush", context1, signedMessage)}
}

func (_c *FullNode_MpoolPush_Call) Run(run func(context1 context.Context, signedMessage *types.SignedMessage)) *FullNode_MpoolPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.SignedMessage))
	})
	return _c
}

func (_c *FullNode_MpoolPush_Call) Return(cid1 cid.Cid, err error) *FullNode_MpoolPush_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_MpoolPush_Call) RunAndReturn(run func(context1 context.Context, signedMessage *types.SignedMessage) (cid.Cid, error)) *FullNode_MpoolPush_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolPushMessage provides a mock function for the type FullNode
func (_mock *FullNode) MpoolPushMessage(ctx context.Context, msg *types.Message, spec *api.MessageSendSpec) (*types.SignedMessage, error) {
	ret := _mock.Called(ctx, msg, spec)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPushMessage")
	}

	var r0 *types.SignedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec) (*types.SignedMessage, error)); ok {
		return returnFunc(ctx, msg, spec)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec) *types.SignedMessage); ok {
		r0 = returnFunc(ctx, msg, spec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Message, *api.MessageSendSpec) error); ok {
		r1 = returnFunc(ctx, msg, spec)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolPushMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolPushMessage'
type FullNode_MpoolPushMessage_Call struct {
	*mock.Call
}

// MpoolPushMessage is a helper method to define mock.On call
//   - ctx
//   - msg
//   - spec
func (_e *FullNode_Expecter) MpoolPushMessage(ctx interface{}, msg interface{}, spec interface{}) *FullNode_MpoolPushMessage_Call {
	return &FullNode_MpoolPushMessage_Call{Call: _e.mock.On("MpoolPushMessage", ctx, msg, spec)}
}

func (_c *FullNode_MpoolPushMessage_Call) Run(run func(ctx context.Context, msg *types.Message, spec *api.MessageSendSpec)) *FullNode_MpoolPushMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Message), args[2].(*api.MessageSendSpec))
	})
	return _c
}

func (_c *FullNode_MpoolPushMessage_Call) Return(signedMessage *types.SignedMessage, err error) *FullNode_MpoolPushMessage_Call {
	_c.Call.Return(signedMessage, err)
	return _c
}

func (_c *FullNode_MpoolPushMessage_Call) RunAndReturn(run func(ctx context.Context, msg *types.Message, spec *api.MessageSendSpec) (*types.SignedMessage, error)) *FullNode_MpoolPushMessage_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolPushUntrusted provides a mock function for the type FullNode
func (_mock *FullNode) MpoolPushUntrusted(context1 context.Context, signedMessage *types.SignedMessage) (cid.Cid, error) {
	ret := _mock.Called(context1, signedMessage)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPushUntrusted")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) (cid.Cid, error)); ok {
		return returnFunc(context1, signedMessage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) cid.Cid); ok {
		r0 = returnFunc(context1, signedMessage)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.SignedMessage) error); ok {
		r1 = returnFunc(context1, signedMessage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolPushUntrusted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolPushUntrusted'
type FullNode_MpoolPushUntrusted_Call struct {
	*mock.Call
}

// MpoolPushUntrusted is a helper method to define mock.On call
//   - context1
//   - signedMessage
func (_e *FullNode_Expecter) MpoolPushUntrusted(context1 interface{}, signedMessage interface{}) *FullNode_MpoolPushUntrusted_Call {
	return &FullNode_MpoolPushUntrusted_Call{Call: _e.mock.On("MpoolPushUntrusted", context1, signedMessage)}
}

func (_c *FullNode_MpoolPushUntrusted_Call) Run(run func(context1 context.Context, signedMessage *types.SignedMessage)) *FullNode_MpoolPushUntrusted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.SignedMessage))
	})
	return _c
}

func (_c *FullNode_MpoolPushUntrusted_Call) Return(cid1 cid.Cid, err error) *FullNode_MpoolPushUntrusted_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_MpoolPushUntrusted_Call) RunAndReturn(run func(context1 context.Context, signedMessage *types.SignedMessage) (cid.Cid, error)) *FullNode_MpoolPushUntrusted_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolSelect provides a mock function for the type FullNode
func (_mock *FullNode) MpoolSelect(context1 context.Context, tipSetKey types.TipSetKey, f float64) ([]*types.SignedMessage, error) {
	ret := _mock.Called(context1, tipSetKey, f)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSelect")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, float64) ([]*types.SignedMessage, error)); ok {
		return returnFunc(context1, tipSetKey, f)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, float64) []*types.SignedMessage); ok {
		r0 = returnFunc(context1, tipSetKey, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey, float64) error); ok {
		r1 = returnFunc(context1, tipSetKey, f)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolSelect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolSelect'
type FullNode_MpoolSelect_Call struct {
	*mock.Call
}

// MpoolSelect is a helper method to define mock.On call
//   - context1
//   - tipSetKey
//   - f
func (_e *FullNode_Expecter) MpoolSelect(context1 interface{}, tipSetKey interface{}, f interface{}) *FullNode_MpoolSelect_Call {
	return &FullNode_MpoolSelect_Call{Call: _e.mock.On("MpoolSelect", context1, tipSetKey, f)}
}

func (_c *FullNode_MpoolSelect_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey, f float64)) *FullNode_MpoolSelect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey), args[2].(float64))
	})
	return _c
}

func (_c *FullNode_MpoolSelect_Call) Return(signedMessages []*types.SignedMessage, err error) *FullNode_MpoolSelect_Call {
	_c.Call.Return(signedMessages, err)
	return _c
}

func (_c *FullNode_MpoolSelect_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey, f float64) ([]*types.SignedMessage, error)) *FullNode_MpoolSelect_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolSetConfig provides a mock function for the type FullNode
func (_mock *FullNode) MpoolSetConfig(context1 context.Context, mpoolConfig *types.MpoolConfig) error {
	ret := _mock.Called(context1, mpoolConfig)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSetConfig")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.MpoolConfig) error); ok {
		r0 = returnFunc(context1, mpoolConfig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_MpoolSetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolSetConfig'
type FullNode_MpoolSetConfig_Call struct {
	*mock.Call
}

// MpoolSetConfig is a helper method to define mock.On call
//   - context1
//   - mpoolConfig
func (_e *FullNode_Expecter) MpoolSetConfig(context1 interface{}, mpoolConfig interface{}) *FullNode_MpoolSetConfig_Call {
	return &FullNode_MpoolSetConfig_Call{Call: _e.mock.On("MpoolSetConfig", context1, mpoolConfig)}
}

func (_c *FullNode_MpoolSetConfig_Call) Run(run func(context1 context.Context, mpoolConfig *types.MpoolConfig)) *FullNode_MpoolSetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.MpoolConfig))
	})
	return _c
}

func (_c *FullNode_MpoolSetConfig_Call) Return(err error) *FullNode_MpoolSetConfig_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_MpoolSetConfig_Call) RunAndReturn(run func(context1 context.Context, mpoolConfig *types.MpoolConfig) error) *FullNode_MpoolSetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// MpoolSub provides a mock function for the type FullNode
func (_mock *FullNode) MpoolSub(context1 context.Context) (<-chan api.MpoolUpdate, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSub")
	}

	var r0 <-chan api.MpoolUpdate
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan api.MpoolUpdate, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan api.MpoolUpdate); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan api.MpoolUpdate)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MpoolSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MpoolSub'
type FullNode_MpoolSub_Call struct {
	*mock.Call
}

// MpoolSub is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) MpoolSub(context1 interface{}) *FullNode_MpoolSub_Call {
	return &FullNode_MpoolSub_Call{Call: _e.mock.On("MpoolSub", context1)}
}

func (_c *FullNode_MpoolSub_Call) Run(run func(context1 context.Context)) *FullNode_MpoolSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_MpoolSub_Call) Return(mpoolUpdateCh <-chan api.MpoolUpdate, err error) *FullNode_MpoolSub_Call {
	_c.Call.Return(mpoolUpdateCh, err)
	return _c
}

func (_c *FullNode_MpoolSub_Call) RunAndReturn(run func(context1 context.Context) (<-chan api.MpoolUpdate, error)) *FullNode_MpoolSub_Call {
	_c.Call.Return(run)
	return _c
}

// MsigAddApprove provides a mock function for the type FullNode
func (_mock *FullNode) MsigAddApprove(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, b bool) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, v, address12, address13, b)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, v, address12, address13, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, v, address12, address13, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) error); ok {
		r1 = returnFunc(context1, address1, address11, v, address12, address13, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigAddApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigAddApprove'
type FullNode_MsigAddApprove_Call struct {
	*mock.Call
}

// MsigAddApprove is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - v
//   - address12
//   - address13
//   - b
func (_e *FullNode_Expecter) MsigAddApprove(context1 interface{}, address1 interface{}, address11 interface{}, v interface{}, address12 interface{}, address13 interface{}, b interface{}) *FullNode_MsigAddApprove_Call {
	return &FullNode_MsigAddApprove_Call{Call: _e.mock.On("MsigAddApprove", context1, address1, address11, v, address12, address13, b)}
}

func (_c *FullNode_MsigAddApprove_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, b bool)) *FullNode_MsigAddApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(uint64), args[4].(address.Address), args[5].(address.Address), args[6].(bool))
	})
	return _c
}

func (_c *FullNode_MsigAddApprove_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigAddApprove_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigAddApprove_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, b bool) (*api.MessagePrototype, error)) *FullNode_MsigAddApprove_Call {
	_c.Call.Return(run)
	return _c
}

// MsigAddCancel provides a mock function for the type FullNode
func (_mock *FullNode) MsigAddCancel(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, b bool) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, v, address12, b)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, v, address12, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, v, address12, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) error); ok {
		r1 = returnFunc(context1, address1, address11, v, address12, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigAddCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigAddCancel'
type FullNode_MsigAddCancel_Call struct {
	*mock.Call
}

// MsigAddCancel is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - v
//   - address12
//   - b
func (_e *FullNode_Expecter) MsigAddCancel(context1 interface{}, address1 interface{}, address11 interface{}, v interface{}, address12 interface{}, b interface{}) *FullNode_MsigAddCancel_Call {
	return &FullNode_MsigAddCancel_Call{Call: _e.mock.On("MsigAddCancel", context1, address1, address11, v, address12, b)}
}

func (_c *FullNode_MsigAddCancel_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, b bool)) *FullNode_MsigAddCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(uint64), args[4].(address.Address), args[5].(bool))
	})
	return _c
}

func (_c *FullNode_MsigAddCancel_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigAddCancel_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigAddCancel_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, b bool) (*api.MessagePrototype, error)) *FullNode_MsigAddCancel_Call {
	_c.Call.Return(run)
	return _c
}

// MsigAddPropose provides a mock function for the type FullNode
func (_mock *FullNode) MsigAddPropose(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, b bool) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, address12, b)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, address12, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, address12, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, bool) error); ok {
		r1 = returnFunc(context1, address1, address11, address12, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigAddPropose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigAddPropose'
type FullNode_MsigAddPropose_Call struct {
	*mock.Call
}

// MsigAddPropose is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - address12
//   - b
func (_e *FullNode_Expecter) MsigAddPropose(context1 interface{}, address1 interface{}, address11 interface{}, address12 interface{}, b interface{}) *FullNode_MsigAddPropose_Call {
	return &FullNode_MsigAddPropose_Call{Call: _e.mock.On("MsigAddPropose", context1, address1, address11, address12, b)}
}

func (_c *FullNode_MsigAddPropose_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, b bool)) *FullNode_MsigAddPropose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(address.Address), args[4].(bool))
	})
	return _c
}

func (_c *FullNode_MsigAddPropose_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigAddPropose_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigAddPropose_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, b bool) (*api.MessagePrototype, error)) *FullNode_MsigAddPropose_Call {
	_c.Call.Return(run)
	return _c
}

// MsigApprove provides a mock function for the type FullNode
func (_mock *FullNode) MsigApprove(context1 context.Context, address1 address.Address, v uint64, address11 address.Address) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, v, address11)

	if len(ret) == 0 {
		panic("no return value specified for MsigApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, v, address11)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, v, address11)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address) error); ok {
		r1 = returnFunc(context1, address1, v, address11)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigApprove'
type FullNode_MsigApprove_Call struct {
	*mock.Call
}

// MsigApprove is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - address11
func (_e *FullNode_Expecter) MsigApprove(context1 interface{}, address1 interface{}, v interface{}, address11 interface{}) *FullNode_MsigApprove_Call {
	return &FullNode_MsigApprove_Call{Call: _e.mock.On("MsigApprove", context1, address1, v, address11)}
}

func (_c *FullNode_MsigApprove_Call) Run(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address)) *FullNode_MsigApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(uint64), args[3].(address.Address))
	})
	return _c
}

func (_c *FullNode_MsigApprove_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigApprove_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigApprove_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address) (*api.MessagePrototype, error)) *FullNode_MsigApprove_Call {
	_c.Call.Return(run)
	return _c
}

// MsigApproveTxnHash provides a mock function for the type FullNode
func (_mock *FullNode) MsigApproveTxnHash(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, address12 address.Address, v1 types.BigInt, address13 address.Address, v2 uint64, bytes []byte) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, v, address11, address12, v1, address13, v2, bytes)

	if len(ret) == 0 {
		panic("no return value specified for MsigApproveTxnHash")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, v, address11, address12, v1, address13, v2, bytes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, v, address11, address12, v1, address13, v2, bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) error); ok {
		r1 = returnFunc(context1, address1, v, address11, address12, v1, address13, v2, bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigApproveTxnHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigApproveTxnHash'
type FullNode_MsigApproveTxnHash_Call struct {
	*mock.Call
}

// MsigApproveTxnHash is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - address11
//   - address12
//   - v1
//   - address13
//   - v2
//   - bytes
func (_e *FullNode_Expecter) MsigApproveTxnHash(context1 interface{}, address1 interface{}, v interface{}, address11 interface{}, address12 interface{}, v1 interface{}, address13 interface{}, v2 interface{}, bytes interface{}) *FullNode_MsigApproveTxnHash_Call {
	return &FullNode_MsigApproveTxnHash_Call{Call: _e.mock.On("MsigApproveTxnHash", context1, address1, v, address11, address12, v1, address13, v2, bytes)}
}

func (_c *FullNode_MsigApproveTxnHash_Call) Run(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, address12 address.Address, v1 types.BigInt, address13 address.Address, v2 uint64, bytes []byte)) *FullNode_MsigApproveTxnHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(uint64), args[3].(address.Address), args[4].(address.Address), args[5].(types.BigInt), args[6].(address.Address), args[7].(uint64), args[8].([]byte))
	})
	return _c
}

func (_c *FullNode_MsigApproveTxnHash_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigApproveTxnHash_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigApproveTxnHash_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, address12 address.Address, v1 types.BigInt, address13 address.Address, v2 uint64, bytes []byte) (*api.MessagePrototype, error)) *FullNode_MsigApproveTxnHash_Call {
	_c.Call.Return(run)
	return _c
}

// MsigCancel provides a mock function for the type FullNode
func (_mock *FullNode) MsigCancel(context1 context.Context, address1 address.Address, v uint64, address11 address.Address) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, v, address11)

	if len(ret) == 0 {
		panic("no return value specified for MsigCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, v, address11)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, v, address11)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address) error); ok {
		r1 = returnFunc(context1, address1, v, address11)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigCancel'
type FullNode_MsigCancel_Call struct {
	*mock.Call
}

// MsigCancel is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - address11
func (_e *FullNode_Expecter) MsigCancel(context1 interface{}, address1 interface{}, v interface{}, address11 interface{}) *FullNode_MsigCancel_Call {
	return &FullNode_MsigCancel_Call{Call: _e.mock.On("MsigCancel", context1, address1, v, address11)}
}

func (_c *FullNode_MsigCancel_Call) Run(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address)) *FullNode_MsigCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(uint64), args[3].(address.Address))
	})
	return _c
}

func (_c *FullNode_MsigCancel_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigCancel_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigCancel_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address) (*api.MessagePrototype, error)) *FullNode_MsigCancel_Call {
	_c.Call.Return(run)
	return _c
}

// MsigCancelTxnHash provides a mock function for the type FullNode
func (_mock *FullNode) MsigCancelTxnHash(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, v1 types.BigInt, address12 address.Address, v2 uint64, bytes []byte) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, v, address11, v1, address12, v2, bytes)

	if len(ret) == 0 {
		panic("no return value specified for MsigCancelTxnHash")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, types.BigInt, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, v, address11, v1, address12, v2, bytes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, types.BigInt, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, v, address11, v1, address12, v2, bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, types.BigInt, address.Address, uint64, []byte) error); ok {
		r1 = returnFunc(context1, address1, v, address11, v1, address12, v2, bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigCancelTxnHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigCancelTxnHash'
type FullNode_MsigCancelTxnHash_Call struct {
	*mock.Call
}

// MsigCancelTxnHash is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - address11
//   - v1
//   - address12
//   - v2
//   - bytes
func (_e *FullNode_Expecter) MsigCancelTxnHash(context1 interface{}, address1 interface{}, v interface{}, address11 interface{}, v1 interface{}, address12 interface{}, v2 interface{}, bytes interface{}) *FullNode_MsigCancelTxnHash_Call {
	return &FullNode_MsigCancelTxnHash_Call{Call: _e.mock.On("MsigCancelTxnHash", context1, address1, v, address11, v1, address12, v2, bytes)}
}

func (_c *FullNode_MsigCancelTxnHash_Call) Run(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, v1 types.BigInt, address12 address.Address, v2 uint64, bytes []byte)) *FullNode_MsigCancelTxnHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(uint64), args[3].(address.Address), args[4].(types.BigInt), args[5].(address.Address), args[6].(uint64), args[7].([]byte))
	})
	return _c
}

func (_c *FullNode_MsigCancelTxnHash_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigCancelTxnHash_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigCancelTxnHash_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v uint64, address11 address.Address, v1 types.BigInt, address12 address.Address, v2 uint64, bytes []byte) (*api.MessagePrototype, error)) *FullNode_MsigCancelTxnHash_Call {
	_c.Call.Return(run)
	return _c
}

// MsigCreate provides a mock function for the type FullNode
func (_mock *FullNode) MsigCreate(context1 context.Context, v uint64, addresss []address.Address, chainEpoch abi.ChainEpoch, v1 types.BigInt, address1 address.Address, v2 types.BigInt) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, v, addresss, chainEpoch, v1, address1, v2)

	if len(ret) == 0 {
		panic("no return value specified for MsigCreate")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, types.BigInt, address.Address, types.BigInt) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, v, addresss, chainEpoch, v1, address1, v2)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, types.BigInt, address.Address, types.BigInt) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, v, addresss, chainEpoch, v1, address1, v2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, types.BigInt, address.Address, types.BigInt) error); ok {
		r1 = returnFunc(context1, v, addresss, chainEpoch, v1, address1, v2)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigCreate'
type FullNode_MsigCreate_Call struct {
	*mock.Call
}

// MsigCreate is a helper method to define mock.On call
//   - context1
//   - v
//   - addresss
//   - chainEpoch
//   - v1
//   - address1
//   - v2
func (_e *FullNode_Expecter) MsigCreate(context1 interface{}, v interface{}, addresss interface{}, chainEpoch interface{}, v1 interface{}, address1 interface{}, v2 interface{}) *FullNode_MsigCreate_Call {
	return &FullNode_MsigCreate_Call{Call: _e.mock.On("MsigCreate", context1, v, addresss, chainEpoch, v1, address1, v2)}
}

func (_c *FullNode_MsigCreate_Call) Run(run func(context1 context.Context, v uint64, addresss []address.Address, chainEpoch abi.ChainEpoch, v1 types.BigInt, address1 address.Address, v2 types.BigInt)) *FullNode_MsigCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].([]address.Address), args[3].(abi.ChainEpoch), args[4].(types.BigInt), args[5].(address.Address), args[6].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_MsigCreate_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigCreate_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigCreate_Call) RunAndReturn(run func(context1 context.Context, v uint64, addresss []address.Address, chainEpoch abi.ChainEpoch, v1 types.BigInt, address1 address.Address, v2 types.BigInt) (*api.MessagePrototype, error)) *FullNode_MsigCreate_Call {
	_c.Call.Return(run)
	return _c
}

// MsigGetAvailableBalance provides a mock function for the type FullNode
func (_mock *FullNode) MsigGetAvailableBalance(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetAvailableBalance")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigGetAvailableBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigGetAvailableBalance'
type FullNode_MsigGetAvailableBalance_Call struct {
	*mock.Call
}

// MsigGetAvailableBalance is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) MsigGetAvailableBalance(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_MsigGetAvailableBalance_Call {
	return &FullNode_MsigGetAvailableBalance_Call{Call: _e.mock.On("MsigGetAvailableBalance", context1, address1, tipSetKey)}
}

func (_c *FullNode_MsigGetAvailableBalance_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_MsigGetAvailableBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MsigGetAvailableBalance_Call) Return(v types.BigInt, err error) *FullNode_MsigGetAvailableBalance_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_MsigGetAvailableBalance_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_MsigGetAvailableBalance_Call {
	_c.Call.Return(run)
	return _c
}

// MsigGetPending provides a mock function for the type FullNode
func (_mock *FullNode) MsigGetPending(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]*api.MsigTransaction, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetPending")
	}

	var r0 []*api.MsigTransaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]*api.MsigTransaction, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []*api.MsigTransaction); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.MsigTransaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigGetPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigGetPending'
type FullNode_MsigGetPending_Call struct {
	*mock.Call
}

// MsigGetPending is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) MsigGetPending(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_MsigGetPending_Call {
	return &FullNode_MsigGetPending_Call{Call: _e.mock.On("MsigGetPending", context1, address1, tipSetKey)}
}

func (_c *FullNode_MsigGetPending_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_MsigGetPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MsigGetPending_Call) Return(msigTransactions []*api.MsigTransaction, err error) *FullNode_MsigGetPending_Call {
	_c.Call.Return(msigTransactions, err)
	return _c
}

func (_c *FullNode_MsigGetPending_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]*api.MsigTransaction, error)) *FullNode_MsigGetPending_Call {
	_c.Call.Return(run)
	return _c
}

// MsigGetVested provides a mock function for the type FullNode
func (_mock *FullNode) MsigGetVested(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey, tipSetKey1 types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, tipSetKey, tipSetKey1)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetVested")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, tipSetKey, tipSetKey1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, address1, tipSetKey, tipSetKey1)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey, tipSetKey1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigGetVested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigGetVested'
type FullNode_MsigGetVested_Call struct {
	*mock.Call
}

// MsigGetVested is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
//   - tipSetKey1
func (_e *FullNode_Expecter) MsigGetVested(context1 interface{}, address1 interface{}, tipSetKey interface{}, tipSetKey1 interface{}) *FullNode_MsigGetVested_Call {
	return &FullNode_MsigGetVested_Call{Call: _e.mock.On("MsigGetVested", context1, address1, tipSetKey, tipSetKey1)}
}

func (_c *FullNode_MsigGetVested_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey, tipSetKey1 types.TipSetKey)) *FullNode_MsigGetVested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MsigGetVested_Call) Return(v types.BigInt, err error) *FullNode_MsigGetVested_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_MsigGetVested_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey, tipSetKey1 types.TipSetKey) (types.BigInt, error)) *FullNode_MsigGetVested_Call {
	_c.Call.Return(run)
	return _c
}

// MsigGetVestingSchedule provides a mock function for the type FullNode
func (_mock *FullNode) MsigGetVestingSchedule(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MsigVesting, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetVestingSchedule")
	}

	var r0 api.MsigVesting
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MsigVesting, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MsigVesting); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.MsigVesting)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigGetVestingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigGetVestingSchedule'
type FullNode_MsigGetVestingSchedule_Call struct {
	*mock.Call
}

// MsigGetVestingSchedule is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) MsigGetVestingSchedule(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_MsigGetVestingSchedule_Call {
	return &FullNode_MsigGetVestingSchedule_Call{Call: _e.mock.On("MsigGetVestingSchedule", context1, address1, tipSetKey)}
}

func (_c *FullNode_MsigGetVestingSchedule_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_MsigGetVestingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_MsigGetVestingSchedule_Call) Return(msigVesting api.MsigVesting, err error) *FullNode_MsigGetVestingSchedule_Call {
	_c.Call.Return(msigVesting, err)
	return _c
}

func (_c *FullNode_MsigGetVestingSchedule_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MsigVesting, error)) *FullNode_MsigGetVestingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// MsigPropose provides a mock function for the type FullNode
func (_mock *FullNode) MsigPropose(context1 context.Context, address1 address.Address, address11 address.Address, v types.BigInt, address12 address.Address, v1 uint64, bytes []byte) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, v, address12, v1, bytes)

	if len(ret) == 0 {
		panic("no return value specified for MsigPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, v, address12, v1, bytes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, v, address12, v1, bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt, address.Address, uint64, []byte) error); ok {
		r1 = returnFunc(context1, address1, address11, v, address12, v1, bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigPropose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigPropose'
type FullNode_MsigPropose_Call struct {
	*mock.Call
}

// MsigPropose is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - v
//   - address12
//   - v1
//   - bytes
func (_e *FullNode_Expecter) MsigPropose(context1 interface{}, address1 interface{}, address11 interface{}, v interface{}, address12 interface{}, v1 interface{}, bytes interface{}) *FullNode_MsigPropose_Call {
	return &FullNode_MsigPropose_Call{Call: _e.mock.On("MsigPropose", context1, address1, address11, v, address12, v1, bytes)}
}

func (_c *FullNode_MsigPropose_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, v types.BigInt, address12 address.Address, v1 uint64, bytes []byte)) *FullNode_MsigPropose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt), args[4].(address.Address), args[5].(uint64), args[6].([]byte))
	})
	return _c
}

func (_c *FullNode_MsigPropose_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigPropose_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigPropose_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, v types.BigInt, address12 address.Address, v1 uint64, bytes []byte) (*api.MessagePrototype, error)) *FullNode_MsigPropose_Call {
	_c.Call.Return(run)
	return _c
}

// MsigRemoveSigner provides a mock function for the type FullNode
func (_mock *FullNode) MsigRemoveSigner(ctx context.Context, msig address.Address, proposer address.Address, toRemove address.Address, decrease bool) (*api.MessagePrototype, error) {
	ret := _mock.Called(ctx, msig, proposer, toRemove, decrease)

	if len(ret) == 0 {
		panic("no return value specified for MsigRemoveSigner")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return returnFunc(ctx, msig, proposer, toRemove, decrease)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = returnFunc(ctx, msig, proposer, toRemove, decrease)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, bool) error); ok {
		r1 = returnFunc(ctx, msig, proposer, toRemove, decrease)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigRemoveSigner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigRemoveSigner'
type FullNode_MsigRemoveSigner_Call struct {
	*mock.Call
}

// MsigRemoveSigner is a helper method to define mock.On call
//   - ctx
//   - msig
//   - proposer
//   - toRemove
//   - decrease
func (_e *FullNode_Expecter) MsigRemoveSigner(ctx interface{}, msig interface{}, proposer interface{}, toRemove interface{}, decrease interface{}) *FullNode_MsigRemoveSigner_Call {
	return &FullNode_MsigRemoveSigner_Call{Call: _e.mock.On("MsigRemoveSigner", ctx, msig, proposer, toRemove, decrease)}
}

func (_c *FullNode_MsigRemoveSigner_Call) Run(run func(ctx context.Context, msig address.Address, proposer address.Address, toRemove address.Address, decrease bool)) *FullNode_MsigRemoveSigner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(address.Address), args[4].(bool))
	})
	return _c
}

func (_c *FullNode_MsigRemoveSigner_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigRemoveSigner_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigRemoveSigner_Call) RunAndReturn(run func(ctx context.Context, msig address.Address, proposer address.Address, toRemove address.Address, decrease bool) (*api.MessagePrototype, error)) *FullNode_MsigRemoveSigner_Call {
	_c.Call.Return(run)
	return _c
}

// MsigSwapApprove provides a mock function for the type FullNode
func (_mock *FullNode) MsigSwapApprove(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, address14 address.Address) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, v, address12, address13, address14)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, v, address12, address13, address14)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, v, address12, address13, address14)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) error); ok {
		r1 = returnFunc(context1, address1, address11, v, address12, address13, address14)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigSwapApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigSwapApprove'
type FullNode_MsigSwapApprove_Call struct {
	*mock.Call
}

// MsigSwapApprove is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - v
//   - address12
//   - address13
//   - address14
func (_e *FullNode_Expecter) MsigSwapApprove(context1 interface{}, address1 interface{}, address11 interface{}, v interface{}, address12 interface{}, address13 interface{}, address14 interface{}) *FullNode_MsigSwapApprove_Call {
	return &FullNode_MsigSwapApprove_Call{Call: _e.mock.On("MsigSwapApprove", context1, address1, address11, v, address12, address13, address14)}
}

func (_c *FullNode_MsigSwapApprove_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, address14 address.Address)) *FullNode_MsigSwapApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(uint64), args[4].(address.Address), args[5].(address.Address), args[6].(address.Address))
	})
	return _c
}

func (_c *FullNode_MsigSwapApprove_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigSwapApprove_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigSwapApprove_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address, address14 address.Address) (*api.MessagePrototype, error)) *FullNode_MsigSwapApprove_Call {
	_c.Call.Return(run)
	return _c
}

// MsigSwapCancel provides a mock function for the type FullNode
func (_mock *FullNode) MsigSwapCancel(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, v, address12, address13)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, v, address12, address13)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, v, address12, address13)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) error); ok {
		r1 = returnFunc(context1, address1, address11, v, address12, address13)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigSwapCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigSwapCancel'
type FullNode_MsigSwapCancel_Call struct {
	*mock.Call
}

// MsigSwapCancel is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - v
//   - address12
//   - address13
func (_e *FullNode_Expecter) MsigSwapCancel(context1 interface{}, address1 interface{}, address11 interface{}, v interface{}, address12 interface{}, address13 interface{}) *FullNode_MsigSwapCancel_Call {
	return &FullNode_MsigSwapCancel_Call{Call: _e.mock.On("MsigSwapCancel", context1, address1, address11, v, address12, address13)}
}

func (_c *FullNode_MsigSwapCancel_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address)) *FullNode_MsigSwapCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(uint64), args[4].(address.Address), args[5].(address.Address))
	})
	return _c
}

func (_c *FullNode_MsigSwapCancel_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigSwapCancel_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigSwapCancel_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, v uint64, address12 address.Address, address13 address.Address) (*api.MessagePrototype, error)) *FullNode_MsigSwapCancel_Call {
	_c.Call.Return(run)
	return _c
}

// MsigSwapPropose provides a mock function for the type FullNode
func (_mock *FullNode) MsigSwapPropose(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, address13 address.Address) (*api.MessagePrototype, error) {
	ret := _mock.Called(context1, address1, address11, address12, address13)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return returnFunc(context1, address1, address11, address12, address13)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = returnFunc(context1, address1, address11, address12, address13)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, address.Address) error); ok {
		r1 = returnFunc(context1, address1, address11, address12, address13)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_MsigSwapPropose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsigSwapPropose'
type FullNode_MsigSwapPropose_Call struct {
	*mock.Call
}

// MsigSwapPropose is a helper method to define mock.On call
//   - context1
//   - address1
//   - address11
//   - address12
//   - address13
func (_e *FullNode_Expecter) MsigSwapPropose(context1 interface{}, address1 interface{}, address11 interface{}, address12 interface{}, address13 interface{}) *FullNode_MsigSwapPropose_Call {
	return &FullNode_MsigSwapPropose_Call{Call: _e.mock.On("MsigSwapPropose", context1, address1, address11, address12, address13)}
}

func (_c *FullNode_MsigSwapPropose_Call) Run(run func(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, address13 address.Address)) *FullNode_MsigSwapPropose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(address.Address), args[4].(address.Address))
	})
	return _c
}

func (_c *FullNode_MsigSwapPropose_Call) Return(messagePrototype *api.MessagePrototype, err error) *FullNode_MsigSwapPropose_Call {
	_c.Call.Return(messagePrototype, err)
	return _c
}

func (_c *FullNode_MsigSwapPropose_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, address11 address.Address, address12 address.Address, address13 address.Address) (*api.MessagePrototype, error)) *FullNode_MsigSwapPropose_Call {
	_c.Call.Return(run)
	return _c
}

// NetAddrsListen provides a mock function for the type FullNode
func (_mock *FullNode) NetAddrsListen(context1 context.Context) (peer.AddrInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetAddrsListen")
	}

	var r0 peer.AddrInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (peer.AddrInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) peer.AddrInfo); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetAddrsListen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetAddrsListen'
type FullNode_NetAddrsListen_Call struct {
	*mock.Call
}

// NetAddrsListen is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) NetAddrsListen(context1 interface{}) *FullNode_NetAddrsListen_Call {
	return &FullNode_NetAddrsListen_Call{Call: _e.mock.On("NetAddrsListen", context1)}
}

func (_c *FullNode_NetAddrsListen_Call) Run(run func(context1 context.Context)) *FullNode_NetAddrsListen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetAddrsListen_Call) Return(addrInfo peer.AddrInfo, err error) *FullNode_NetAddrsListen_Call {
	_c.Call.Return(addrInfo, err)
	return _c
}

func (_c *FullNode_NetAddrsListen_Call) RunAndReturn(run func(context1 context.Context) (peer.AddrInfo, error)) *FullNode_NetAddrsListen_Call {
	_c.Call.Return(run)
	return _c
}

// NetAgentVersion provides a mock function for the type FullNode
func (_mock *FullNode) NetAgentVersion(ctx context.Context, p peer.ID) (string, error) {
	ret := _mock.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for NetAgentVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (string, error)); ok {
		return returnFunc(ctx, p)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) string); ok {
		r0 = returnFunc(ctx, p)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(ctx, p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetAgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetAgentVersion'
type FullNode_NetAgentVersion_Call struct {
	*mock.Call
}

// NetAgentVersion is a helper method to define mock.On call
//   - ctx
//   - p
func (_e *FullNode_Expecter) NetAgentVersion(ctx interface{}, p interface{}) *FullNode_NetAgentVersion_Call {
	return &FullNode_NetAgentVersion_Call{Call: _e.mock.On("NetAgentVersion", ctx, p)}
}

func (_c *FullNode_NetAgentVersion_Call) Run(run func(ctx context.Context, p peer.ID)) *FullNode_NetAgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetAgentVersion_Call) Return(s string, err error) *FullNode_NetAgentVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *FullNode_NetAgentVersion_Call) RunAndReturn(run func(ctx context.Context, p peer.ID) (string, error)) *FullNode_NetAgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NetAutoNatStatus provides a mock function for the type FullNode
func (_mock *FullNode) NetAutoNatStatus(context1 context.Context) (api.NatInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetAutoNatStatus")
	}

	var r0 api.NatInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (api.NatInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) api.NatInfo); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(api.NatInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetAutoNatStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetAutoNatStatus'
type FullNode_NetAutoNatStatus_Call struct {
	*mock.Call
}

// NetAutoNatStatus is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) NetAutoNatStatus(context1 interface{}) *FullNode_NetAutoNatStatus_Call {
	return &FullNode_NetAutoNatStatus_Call{Call: _e.mock.On("NetAutoNatStatus", context1)}
}

func (_c *FullNode_NetAutoNatStatus_Call) Run(run func(context1 context.Context)) *FullNode_NetAutoNatStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetAutoNatStatus_Call) Return(natInfo api.NatInfo, err error) *FullNode_NetAutoNatStatus_Call {
	_c.Call.Return(natInfo, err)
	return _c
}

func (_c *FullNode_NetAutoNatStatus_Call) RunAndReturn(run func(context1 context.Context) (api.NatInfo, error)) *FullNode_NetAutoNatStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NetBandwidthStats provides a mock function for the type FullNode
func (_mock *FullNode) NetBandwidthStats(ctx context.Context) (metrics.Stats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStats")
	}

	var r0 metrics.Stats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (metrics.Stats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) metrics.Stats); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(metrics.Stats)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetBandwidthStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBandwidthStats'
type FullNode_NetBandwidthStats_Call struct {
	*mock.Call
}

// NetBandwidthStats is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetBandwidthStats(ctx interface{}) *FullNode_NetBandwidthStats_Call {
	return &FullNode_NetBandwidthStats_Call{Call: _e.mock.On("NetBandwidthStats", ctx)}
}

func (_c *FullNode_NetBandwidthStats_Call) Run(run func(ctx context.Context)) *FullNode_NetBandwidthStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetBandwidthStats_Call) Return(stats metrics.Stats, err error) *FullNode_NetBandwidthStats_Call {
	_c.Call.Return(stats, err)
	return _c
}

func (_c *FullNode_NetBandwidthStats_Call) RunAndReturn(run func(ctx context.Context) (metrics.Stats, error)) *FullNode_NetBandwidthStats_Call {
	_c.Call.Return(run)
	return _c
}

// NetBandwidthStatsByPeer provides a mock function for the type FullNode
func (_mock *FullNode) NetBandwidthStatsByPeer(ctx context.Context) (map[string]metrics.Stats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStatsByPeer")
	}

	var r0 map[string]metrics.Stats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[string]metrics.Stats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[string]metrics.Stats); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]metrics.Stats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetBandwidthStatsByPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBandwidthStatsByPeer'
type FullNode_NetBandwidthStatsByPeer_Call struct {
	*mock.Call
}

// NetBandwidthStatsByPeer is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetBandwidthStatsByPeer(ctx interface{}) *FullNode_NetBandwidthStatsByPeer_Call {
	return &FullNode_NetBandwidthStatsByPeer_Call{Call: _e.mock.On("NetBandwidthStatsByPeer", ctx)}
}

func (_c *FullNode_NetBandwidthStatsByPeer_Call) Run(run func(ctx context.Context)) *FullNode_NetBandwidthStatsByPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetBandwidthStatsByPeer_Call) Return(stringToStats map[string]metrics.Stats, err error) *FullNode_NetBandwidthStatsByPeer_Call {
	_c.Call.Return(stringToStats, err)
	return _c
}

func (_c *FullNode_NetBandwidthStatsByPeer_Call) RunAndReturn(run func(ctx context.Context) (map[string]metrics.Stats, error)) *FullNode_NetBandwidthStatsByPeer_Call {
	_c.Call.Return(run)
	return _c
}

// NetBandwidthStatsByProtocol provides a mock function for the type FullNode
func (_mock *FullNode) NetBandwidthStatsByProtocol(ctx context.Context) (map[protocol.ID]metrics.Stats, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStatsByProtocol")
	}

	var r0 map[protocol.ID]metrics.Stats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[protocol.ID]metrics.Stats, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[protocol.ID]metrics.Stats); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[protocol.ID]metrics.Stats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetBandwidthStatsByProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBandwidthStatsByProtocol'
type FullNode_NetBandwidthStatsByProtocol_Call struct {
	*mock.Call
}

// NetBandwidthStatsByProtocol is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetBandwidthStatsByProtocol(ctx interface{}) *FullNode_NetBandwidthStatsByProtocol_Call {
	return &FullNode_NetBandwidthStatsByProtocol_Call{Call: _e.mock.On("NetBandwidthStatsByProtocol", ctx)}
}

func (_c *FullNode_NetBandwidthStatsByProtocol_Call) Run(run func(ctx context.Context)) *FullNode_NetBandwidthStatsByProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetBandwidthStatsByProtocol_Call) Return(iDToStats map[protocol.ID]metrics.Stats, err error) *FullNode_NetBandwidthStatsByProtocol_Call {
	_c.Call.Return(iDToStats, err)
	return _c
}

func (_c *FullNode_NetBandwidthStatsByProtocol_Call) RunAndReturn(run func(ctx context.Context) (map[protocol.ID]metrics.Stats, error)) *FullNode_NetBandwidthStatsByProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// NetBlockAdd provides a mock function for the type FullNode
func (_mock *FullNode) NetBlockAdd(ctx context.Context, acl api.NetBlockList) error {
	ret := _mock.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockAdd")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.NetBlockList) error); ok {
		r0 = returnFunc(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetBlockAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBlockAdd'
type FullNode_NetBlockAdd_Call struct {
	*mock.Call
}

// NetBlockAdd is a helper method to define mock.On call
//   - ctx
//   - acl
func (_e *FullNode_Expecter) NetBlockAdd(ctx interface{}, acl interface{}) *FullNode_NetBlockAdd_Call {
	return &FullNode_NetBlockAdd_Call{Call: _e.mock.On("NetBlockAdd", ctx, acl)}
}

func (_c *FullNode_NetBlockAdd_Call) Run(run func(ctx context.Context, acl api.NetBlockList)) *FullNode_NetBlockAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(api.NetBlockList))
	})
	return _c
}

func (_c *FullNode_NetBlockAdd_Call) Return(err error) *FullNode_NetBlockAdd_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetBlockAdd_Call) RunAndReturn(run func(ctx context.Context, acl api.NetBlockList) error) *FullNode_NetBlockAdd_Call {
	_c.Call.Return(run)
	return _c
}

// NetBlockList provides a mock function for the type FullNode
func (_mock *FullNode) NetBlockList(ctx context.Context) (api.NetBlockList, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockList")
	}

	var r0 api.NetBlockList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (api.NetBlockList, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) api.NetBlockList); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(api.NetBlockList)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetBlockList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBlockList'
type FullNode_NetBlockList_Call struct {
	*mock.Call
}

// NetBlockList is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetBlockList(ctx interface{}) *FullNode_NetBlockList_Call {
	return &FullNode_NetBlockList_Call{Call: _e.mock.On("NetBlockList", ctx)}
}

func (_c *FullNode_NetBlockList_Call) Run(run func(ctx context.Context)) *FullNode_NetBlockList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetBlockList_Call) Return(netBlockList api.NetBlockList, err error) *FullNode_NetBlockList_Call {
	_c.Call.Return(netBlockList, err)
	return _c
}

func (_c *FullNode_NetBlockList_Call) RunAndReturn(run func(ctx context.Context) (api.NetBlockList, error)) *FullNode_NetBlockList_Call {
	_c.Call.Return(run)
	return _c
}

// NetBlockRemove provides a mock function for the type FullNode
func (_mock *FullNode) NetBlockRemove(ctx context.Context, acl api.NetBlockList) error {
	ret := _mock.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockRemove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, api.NetBlockList) error); ok {
		r0 = returnFunc(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetBlockRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetBlockRemove'
type FullNode_NetBlockRemove_Call struct {
	*mock.Call
}

// NetBlockRemove is a helper method to define mock.On call
//   - ctx
//   - acl
func (_e *FullNode_Expecter) NetBlockRemove(ctx interface{}, acl interface{}) *FullNode_NetBlockRemove_Call {
	return &FullNode_NetBlockRemove_Call{Call: _e.mock.On("NetBlockRemove", ctx, acl)}
}

func (_c *FullNode_NetBlockRemove_Call) Run(run func(ctx context.Context, acl api.NetBlockList)) *FullNode_NetBlockRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(api.NetBlockList))
	})
	return _c
}

func (_c *FullNode_NetBlockRemove_Call) Return(err error) *FullNode_NetBlockRemove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetBlockRemove_Call) RunAndReturn(run func(ctx context.Context, acl api.NetBlockList) error) *FullNode_NetBlockRemove_Call {
	_c.Call.Return(run)
	return _c
}

// NetConnect provides a mock function for the type FullNode
func (_mock *FullNode) NetConnect(context1 context.Context, addrInfo peer.AddrInfo) error {
	ret := _mock.Called(context1, addrInfo)

	if len(ret) == 0 {
		panic("no return value specified for NetConnect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = returnFunc(context1, addrInfo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetConnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetConnect'
type FullNode_NetConnect_Call struct {
	*mock.Call
}

// NetConnect is a helper method to define mock.On call
//   - context1
//   - addrInfo
func (_e *FullNode_Expecter) NetConnect(context1 interface{}, addrInfo interface{}) *FullNode_NetConnect_Call {
	return &FullNode_NetConnect_Call{Call: _e.mock.On("NetConnect", context1, addrInfo)}
}

func (_c *FullNode_NetConnect_Call) Run(run func(context1 context.Context, addrInfo peer.AddrInfo)) *FullNode_NetConnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.AddrInfo))
	})
	return _c
}

func (_c *FullNode_NetConnect_Call) Return(err error) *FullNode_NetConnect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetConnect_Call) RunAndReturn(run func(context1 context.Context, addrInfo peer.AddrInfo) error) *FullNode_NetConnect_Call {
	_c.Call.Return(run)
	return _c
}

// NetConnectedness provides a mock function for the type FullNode
func (_mock *FullNode) NetConnectedness(context1 context.Context, iD peer.ID) (network.Connectedness, error) {
	ret := _mock.Called(context1, iD)

	if len(ret) == 0 {
		panic("no return value specified for NetConnectedness")
	}

	var r0 network.Connectedness
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (network.Connectedness, error)); ok {
		return returnFunc(context1, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) network.Connectedness); ok {
		r0 = returnFunc(context1, iD)
	} else {
		r0 = ret.Get(0).(network.Connectedness)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(context1, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetConnectedness_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetConnectedness'
type FullNode_NetConnectedness_Call struct {
	*mock.Call
}

// NetConnectedness is a helper method to define mock.On call
//   - context1
//   - iD
func (_e *FullNode_Expecter) NetConnectedness(context1 interface{}, iD interface{}) *FullNode_NetConnectedness_Call {
	return &FullNode_NetConnectedness_Call{Call: _e.mock.On("NetConnectedness", context1, iD)}
}

func (_c *FullNode_NetConnectedness_Call) Run(run func(context1 context.Context, iD peer.ID)) *FullNode_NetConnectedness_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetConnectedness_Call) Return(connectedness network.Connectedness, err error) *FullNode_NetConnectedness_Call {
	_c.Call.Return(connectedness, err)
	return _c
}

func (_c *FullNode_NetConnectedness_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID) (network.Connectedness, error)) *FullNode_NetConnectedness_Call {
	_c.Call.Return(run)
	return _c
}

// NetDisconnect provides a mock function for the type FullNode
func (_mock *FullNode) NetDisconnect(context1 context.Context, iD peer.ID) error {
	ret := _mock.Called(context1, iD)

	if len(ret) == 0 {
		panic("no return value specified for NetDisconnect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) error); ok {
		r0 = returnFunc(context1, iD)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetDisconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetDisconnect'
type FullNode_NetDisconnect_Call struct {
	*mock.Call
}

// NetDisconnect is a helper method to define mock.On call
//   - context1
//   - iD
func (_e *FullNode_Expecter) NetDisconnect(context1 interface{}, iD interface{}) *FullNode_NetDisconnect_Call {
	return &FullNode_NetDisconnect_Call{Call: _e.mock.On("NetDisconnect", context1, iD)}
}

func (_c *FullNode_NetDisconnect_Call) Run(run func(context1 context.Context, iD peer.ID)) *FullNode_NetDisconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetDisconnect_Call) Return(err error) *FullNode_NetDisconnect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetDisconnect_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID) error) *FullNode_NetDisconnect_Call {
	_c.Call.Return(run)
	return _c
}

// NetFindPeer provides a mock function for the type FullNode
func (_mock *FullNode) NetFindPeer(context1 context.Context, iD peer.ID) (peer.AddrInfo, error) {
	ret := _mock.Called(context1, iD)

	if len(ret) == 0 {
		panic("no return value specified for NetFindPeer")
	}

	var r0 peer.AddrInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (peer.AddrInfo, error)); ok {
		return returnFunc(context1, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) peer.AddrInfo); ok {
		r0 = returnFunc(context1, iD)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(context1, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetFindPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetFindPeer'
type FullNode_NetFindPeer_Call struct {
	*mock.Call
}

// NetFindPeer is a helper method to define mock.On call
//   - context1
//   - iD
func (_e *FullNode_Expecter) NetFindPeer(context1 interface{}, iD interface{}) *FullNode_NetFindPeer_Call {
	return &FullNode_NetFindPeer_Call{Call: _e.mock.On("NetFindPeer", context1, iD)}
}

func (_c *FullNode_NetFindPeer_Call) Run(run func(context1 context.Context, iD peer.ID)) *FullNode_NetFindPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetFindPeer_Call) Return(addrInfo peer.AddrInfo, err error) *FullNode_NetFindPeer_Call {
	_c.Call.Return(addrInfo, err)
	return _c
}

func (_c *FullNode_NetFindPeer_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID) (peer.AddrInfo, error)) *FullNode_NetFindPeer_Call {
	_c.Call.Return(run)
	return _c
}

// NetLimit provides a mock function for the type FullNode
func (_mock *FullNode) NetLimit(ctx context.Context, scope string) (api.NetLimit, error) {
	ret := _mock.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for NetLimit")
	}

	var r0 api.NetLimit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (api.NetLimit, error)); ok {
		return returnFunc(ctx, scope)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) api.NetLimit); ok {
		r0 = returnFunc(ctx, scope)
	} else {
		r0 = ret.Get(0).(api.NetLimit)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetLimit'
type FullNode_NetLimit_Call struct {
	*mock.Call
}

// NetLimit is a helper method to define mock.On call
//   - ctx
//   - scope
func (_e *FullNode_Expecter) NetLimit(ctx interface{}, scope interface{}) *FullNode_NetLimit_Call {
	return &FullNode_NetLimit_Call{Call: _e.mock.On("NetLimit", ctx, scope)}
}

func (_c *FullNode_NetLimit_Call) Run(run func(ctx context.Context, scope string)) *FullNode_NetLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_NetLimit_Call) Return(netLimit api.NetLimit, err error) *FullNode_NetLimit_Call {
	_c.Call.Return(netLimit, err)
	return _c
}

func (_c *FullNode_NetLimit_Call) RunAndReturn(run func(ctx context.Context, scope string) (api.NetLimit, error)) *FullNode_NetLimit_Call {
	_c.Call.Return(run)
	return _c
}

// NetListening provides a mock function for the type FullNode
func (_mock *FullNode) NetListening(ctx context.Context) (bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetListening")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetListening_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetListening'
type FullNode_NetListening_Call struct {
	*mock.Call
}

// NetListening is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetListening(ctx interface{}) *FullNode_NetListening_Call {
	return &FullNode_NetListening_Call{Call: _e.mock.On("NetListening", ctx)}
}

func (_c *FullNode_NetListening_Call) Run(run func(ctx context.Context)) *FullNode_NetListening_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetListening_Call) Return(b bool, err error) *FullNode_NetListening_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_NetListening_Call) RunAndReturn(run func(ctx context.Context) (bool, error)) *FullNode_NetListening_Call {
	_c.Call.Return(run)
	return _c
}

// NetPeerInfo provides a mock function for the type FullNode
func (_mock *FullNode) NetPeerInfo(context1 context.Context, iD peer.ID) (*api.ExtendedPeerInfo, error) {
	ret := _mock.Called(context1, iD)

	if len(ret) == 0 {
		panic("no return value specified for NetPeerInfo")
	}

	var r0 *api.ExtendedPeerInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (*api.ExtendedPeerInfo, error)); ok {
		return returnFunc(context1, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) *api.ExtendedPeerInfo); ok {
		r0 = returnFunc(context1, iD)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ExtendedPeerInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(context1, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetPeerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetPeerInfo'
type FullNode_NetPeerInfo_Call struct {
	*mock.Call
}

// NetPeerInfo is a helper method to define mock.On call
//   - context1
//   - iD
func (_e *FullNode_Expecter) NetPeerInfo(context1 interface{}, iD interface{}) *FullNode_NetPeerInfo_Call {
	return &FullNode_NetPeerInfo_Call{Call: _e.mock.On("NetPeerInfo", context1, iD)}
}

func (_c *FullNode_NetPeerInfo_Call) Run(run func(context1 context.Context, iD peer.ID)) *FullNode_NetPeerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetPeerInfo_Call) Return(extendedPeerInfo *api.ExtendedPeerInfo, err error) *FullNode_NetPeerInfo_Call {
	_c.Call.Return(extendedPeerInfo, err)
	return _c
}

func (_c *FullNode_NetPeerInfo_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID) (*api.ExtendedPeerInfo, error)) *FullNode_NetPeerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// NetPeers provides a mock function for the type FullNode
func (_mock *FullNode) NetPeers(context1 context.Context) ([]peer.AddrInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetPeers")
	}

	var r0 []peer.AddrInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]peer.AddrInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []peer.AddrInfo); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.AddrInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetPeers'
type FullNode_NetPeers_Call struct {
	*mock.Call
}

// NetPeers is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) NetPeers(context1 interface{}) *FullNode_NetPeers_Call {
	return &FullNode_NetPeers_Call{Call: _e.mock.On("NetPeers", context1)}
}

func (_c *FullNode_NetPeers_Call) Run(run func(context1 context.Context)) *FullNode_NetPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetPeers_Call) Return(addrInfos []peer.AddrInfo, err error) *FullNode_NetPeers_Call {
	_c.Call.Return(addrInfos, err)
	return _c
}

func (_c *FullNode_NetPeers_Call) RunAndReturn(run func(context1 context.Context) ([]peer.AddrInfo, error)) *FullNode_NetPeers_Call {
	_c.Call.Return(run)
	return _c
}

// NetPing provides a mock function for the type FullNode
func (_mock *FullNode) NetPing(context1 context.Context, iD peer.ID) (time.Duration, error) {
	ret := _mock.Called(context1, iD)

	if len(ret) == 0 {
		panic("no return value specified for NetPing")
	}

	var r0 time.Duration
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (time.Duration, error)); ok {
		return returnFunc(context1, iD)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) time.Duration); ok {
		r0 = returnFunc(context1, iD)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(context1, iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetPing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetPing'
type FullNode_NetPing_Call struct {
	*mock.Call
}

// NetPing is a helper method to define mock.On call
//   - context1
//   - iD
func (_e *FullNode_Expecter) NetPing(context1 interface{}, iD interface{}) *FullNode_NetPing_Call {
	return &FullNode_NetPing_Call{Call: _e.mock.On("NetPing", context1, iD)}
}

func (_c *FullNode_NetPing_Call) Run(run func(context1 context.Context, iD peer.ID)) *FullNode_NetPing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(peer.ID))
	})
	return _c
}

func (_c *FullNode_NetPing_Call) Return(duration time.Duration, err error) *FullNode_NetPing_Call {
	_c.Call.Return(duration, err)
	return _c
}

func (_c *FullNode_NetPing_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID) (time.Duration, error)) *FullNode_NetPing_Call {
	_c.Call.Return(run)
	return _c
}

// NetProtectAdd provides a mock function for the type FullNode
func (_mock *FullNode) NetProtectAdd(ctx context.Context, acl []peer.ID) error {
	ret := _mock.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectAdd")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []peer.ID) error); ok {
		r0 = returnFunc(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetProtectAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetProtectAdd'
type FullNode_NetProtectAdd_Call struct {
	*mock.Call
}

// NetProtectAdd is a helper method to define mock.On call
//   - ctx
//   - acl
func (_e *FullNode_Expecter) NetProtectAdd(ctx interface{}, acl interface{}) *FullNode_NetProtectAdd_Call {
	return &FullNode_NetProtectAdd_Call{Call: _e.mock.On("NetProtectAdd", ctx, acl)}
}

func (_c *FullNode_NetProtectAdd_Call) Run(run func(ctx context.Context, acl []peer.ID)) *FullNode_NetProtectAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]peer.ID))
	})
	return _c
}

func (_c *FullNode_NetProtectAdd_Call) Return(err error) *FullNode_NetProtectAdd_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetProtectAdd_Call) RunAndReturn(run func(ctx context.Context, acl []peer.ID) error) *FullNode_NetProtectAdd_Call {
	_c.Call.Return(run)
	return _c
}

// NetProtectList provides a mock function for the type FullNode
func (_mock *FullNode) NetProtectList(ctx context.Context) ([]peer.ID, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectList")
	}

	var r0 []peer.ID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]peer.ID, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []peer.ID); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetProtectList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetProtectList'
type FullNode_NetProtectList_Call struct {
	*mock.Call
}

// NetProtectList is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetProtectList(ctx interface{}) *FullNode_NetProtectList_Call {
	return &FullNode_NetProtectList_Call{Call: _e.mock.On("NetProtectList", ctx)}
}

func (_c *FullNode_NetProtectList_Call) Run(run func(ctx context.Context)) *FullNode_NetProtectList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetProtectList_Call) Return(iDs []peer.ID, err error) *FullNode_NetProtectList_Call {
	_c.Call.Return(iDs, err)
	return _c
}

func (_c *FullNode_NetProtectList_Call) RunAndReturn(run func(ctx context.Context) ([]peer.ID, error)) *FullNode_NetProtectList_Call {
	_c.Call.Return(run)
	return _c
}

// NetProtectRemove provides a mock function for the type FullNode
func (_mock *FullNode) NetProtectRemove(ctx context.Context, acl []peer.ID) error {
	ret := _mock.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectRemove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []peer.ID) error); ok {
		r0 = returnFunc(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetProtectRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetProtectRemove'
type FullNode_NetProtectRemove_Call struct {
	*mock.Call
}

// NetProtectRemove is a helper method to define mock.On call
//   - ctx
//   - acl
func (_e *FullNode_Expecter) NetProtectRemove(ctx interface{}, acl interface{}) *FullNode_NetProtectRemove_Call {
	return &FullNode_NetProtectRemove_Call{Call: _e.mock.On("NetProtectRemove", ctx, acl)}
}

func (_c *FullNode_NetProtectRemove_Call) Run(run func(ctx context.Context, acl []peer.ID)) *FullNode_NetProtectRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]peer.ID))
	})
	return _c
}

func (_c *FullNode_NetProtectRemove_Call) Return(err error) *FullNode_NetProtectRemove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetProtectRemove_Call) RunAndReturn(run func(ctx context.Context, acl []peer.ID) error) *FullNode_NetProtectRemove_Call {
	_c.Call.Return(run)
	return _c
}

// NetPubsubScores provides a mock function for the type FullNode
func (_mock *FullNode) NetPubsubScores(context1 context.Context) ([]api.PubsubScore, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetPubsubScores")
	}

	var r0 []api.PubsubScore
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]api.PubsubScore, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []api.PubsubScore); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.PubsubScore)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetPubsubScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetPubsubScores'
type FullNode_NetPubsubScores_Call struct {
	*mock.Call
}

// NetPubsubScores is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) NetPubsubScores(context1 interface{}) *FullNode_NetPubsubScores_Call {
	return &FullNode_NetPubsubScores_Call{Call: _e.mock.On("NetPubsubScores", context1)}
}

func (_c *FullNode_NetPubsubScores_Call) Run(run func(context1 context.Context)) *FullNode_NetPubsubScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetPubsubScores_Call) Return(pubsubScores []api.PubsubScore, err error) *FullNode_NetPubsubScores_Call {
	_c.Call.Return(pubsubScores, err)
	return _c
}

func (_c *FullNode_NetPubsubScores_Call) RunAndReturn(run func(context1 context.Context) ([]api.PubsubScore, error)) *FullNode_NetPubsubScores_Call {
	_c.Call.Return(run)
	return _c
}

// NetSetLimit provides a mock function for the type FullNode
func (_mock *FullNode) NetSetLimit(ctx context.Context, scope string, limit api.NetLimit) error {
	ret := _mock.Called(ctx, scope, limit)

	if len(ret) == 0 {
		panic("no return value specified for NetSetLimit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, api.NetLimit) error); ok {
		r0 = returnFunc(ctx, scope, limit)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_NetSetLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetSetLimit'
type FullNode_NetSetLimit_Call struct {
	*mock.Call
}

// NetSetLimit is a helper method to define mock.On call
//   - ctx
//   - scope
//   - limit
func (_e *FullNode_Expecter) NetSetLimit(ctx interface{}, scope interface{}, limit interface{}) *FullNode_NetSetLimit_Call {
	return &FullNode_NetSetLimit_Call{Call: _e.mock.On("NetSetLimit", ctx, scope, limit)}
}

func (_c *FullNode_NetSetLimit_Call) Run(run func(ctx context.Context, scope string, limit api.NetLimit)) *FullNode_NetSetLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(api.NetLimit))
	})
	return _c
}

func (_c *FullNode_NetSetLimit_Call) Return(err error) *FullNode_NetSetLimit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_NetSetLimit_Call) RunAndReturn(run func(ctx context.Context, scope string, limit api.NetLimit) error) *FullNode_NetSetLimit_Call {
	_c.Call.Return(run)
	return _c
}

// NetStat provides a mock function for the type FullNode
func (_mock *FullNode) NetStat(ctx context.Context, scope string) (api.NetStat, error) {
	ret := _mock.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for NetStat")
	}

	var r0 api.NetStat
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (api.NetStat, error)); ok {
		return returnFunc(ctx, scope)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) api.NetStat); ok {
		r0 = returnFunc(ctx, scope)
	} else {
		r0 = ret.Get(0).(api.NetStat)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetStat'
type FullNode_NetStat_Call struct {
	*mock.Call
}

// NetStat is a helper method to define mock.On call
//   - ctx
//   - scope
func (_e *FullNode_Expecter) NetStat(ctx interface{}, scope interface{}) *FullNode_NetStat_Call {
	return &FullNode_NetStat_Call{Call: _e.mock.On("NetStat", ctx, scope)}
}

func (_c *FullNode_NetStat_Call) Run(run func(ctx context.Context, scope string)) *FullNode_NetStat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_NetStat_Call) Return(netStat api.NetStat, err error) *FullNode_NetStat_Call {
	_c.Call.Return(netStat, err)
	return _c
}

func (_c *FullNode_NetStat_Call) RunAndReturn(run func(ctx context.Context, scope string) (api.NetStat, error)) *FullNode_NetStat_Call {
	_c.Call.Return(run)
	return _c
}

// NetVersion provides a mock function for the type FullNode
func (_mock *FullNode) NetVersion(ctx context.Context) (string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetVersion'
type FullNode_NetVersion_Call struct {
	*mock.Call
}

// NetVersion is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) NetVersion(ctx interface{}) *FullNode_NetVersion_Call {
	return &FullNode_NetVersion_Call{Call: _e.mock.On("NetVersion", ctx)}
}

func (_c *FullNode_NetVersion_Call) Run(run func(ctx context.Context)) *FullNode_NetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_NetVersion_Call) Return(s string, err error) *FullNode_NetVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *FullNode_NetVersion_Call) RunAndReturn(run func(ctx context.Context) (string, error)) *FullNode_NetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NodeStatus provides a mock function for the type FullNode
func (_mock *FullNode) NodeStatus(ctx context.Context, inclChainStatus bool) (api.NodeStatus, error) {
	ret := _mock.Called(ctx, inclChainStatus)

	if len(ret) == 0 {
		panic("no return value specified for NodeStatus")
	}

	var r0 api.NodeStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) (api.NodeStatus, error)); ok {
		return returnFunc(ctx, inclChainStatus)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) api.NodeStatus); ok {
		r0 = returnFunc(ctx, inclChainStatus)
	} else {
		r0 = ret.Get(0).(api.NodeStatus)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = returnFunc(ctx, inclChainStatus)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_NodeStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NodeStatus'
type FullNode_NodeStatus_Call struct {
	*mock.Call
}

// NodeStatus is a helper method to define mock.On call
//   - ctx
//   - inclChainStatus
func (_e *FullNode_Expecter) NodeStatus(ctx interface{}, inclChainStatus interface{}) *FullNode_NodeStatus_Call {
	return &FullNode_NodeStatus_Call{Call: _e.mock.On("NodeStatus", ctx, inclChainStatus)}
}

func (_c *FullNode_NodeStatus_Call) Run(run func(ctx context.Context, inclChainStatus bool)) *FullNode_NodeStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *FullNode_NodeStatus_Call) Return(nodeStatus api.NodeStatus, err error) *FullNode_NodeStatus_Call {
	_c.Call.Return(nodeStatus, err)
	return _c
}

func (_c *FullNode_NodeStatus_Call) RunAndReturn(run func(ctx context.Context, inclChainStatus bool) (api.NodeStatus, error)) *FullNode_NodeStatus_Call {
	_c.Call.Return(run)
	return _c
}

// PaychAllocateLane provides a mock function for the type FullNode
func (_mock *FullNode) PaychAllocateLane(ctx context.Context, ch address.Address) (uint64, error) {
	ret := _mock.Called(ctx, ch)

	if len(ret) == 0 {
		panic("no return value specified for PaychAllocateLane")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (uint64, error)); ok {
		return returnFunc(ctx, ch)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = returnFunc(ctx, ch)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychAllocateLane_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychAllocateLane'
type FullNode_PaychAllocateLane_Call struct {
	*mock.Call
}

// PaychAllocateLane is a helper method to define mock.On call
//   - ctx
//   - ch
func (_e *FullNode_Expecter) PaychAllocateLane(ctx interface{}, ch interface{}) *FullNode_PaychAllocateLane_Call {
	return &FullNode_PaychAllocateLane_Call{Call: _e.mock.On("PaychAllocateLane", ctx, ch)}
}

func (_c *FullNode_PaychAllocateLane_Call) Run(run func(ctx context.Context, ch address.Address)) *FullNode_PaychAllocateLane_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychAllocateLane_Call) Return(v uint64, err error) *FullNode_PaychAllocateLane_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_PaychAllocateLane_Call) RunAndReturn(run func(ctx context.Context, ch address.Address) (uint64, error)) *FullNode_PaychAllocateLane_Call {
	_c.Call.Return(run)
	return _c
}

// PaychAvailableFunds provides a mock function for the type FullNode
func (_mock *FullNode) PaychAvailableFunds(ctx context.Context, ch address.Address) (*api.ChannelAvailableFunds, error) {
	ret := _mock.Called(ctx, ch)

	if len(ret) == 0 {
		panic("no return value specified for PaychAvailableFunds")
	}

	var r0 *api.ChannelAvailableFunds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (*api.ChannelAvailableFunds, error)); ok {
		return returnFunc(ctx, ch)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) *api.ChannelAvailableFunds); ok {
		r0 = returnFunc(ctx, ch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelAvailableFunds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychAvailableFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychAvailableFunds'
type FullNode_PaychAvailableFunds_Call struct {
	*mock.Call
}

// PaychAvailableFunds is a helper method to define mock.On call
//   - ctx
//   - ch
func (_e *FullNode_Expecter) PaychAvailableFunds(ctx interface{}, ch interface{}) *FullNode_PaychAvailableFunds_Call {
	return &FullNode_PaychAvailableFunds_Call{Call: _e.mock.On("PaychAvailableFunds", ctx, ch)}
}

func (_c *FullNode_PaychAvailableFunds_Call) Run(run func(ctx context.Context, ch address.Address)) *FullNode_PaychAvailableFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychAvailableFunds_Call) Return(channelAvailableFunds *api.ChannelAvailableFunds, err error) *FullNode_PaychAvailableFunds_Call {
	_c.Call.Return(channelAvailableFunds, err)
	return _c
}

func (_c *FullNode_PaychAvailableFunds_Call) RunAndReturn(run func(ctx context.Context, ch address.Address) (*api.ChannelAvailableFunds, error)) *FullNode_PaychAvailableFunds_Call {
	_c.Call.Return(run)
	return _c
}

// PaychAvailableFundsByFromTo provides a mock function for the type FullNode
func (_mock *FullNode) PaychAvailableFundsByFromTo(ctx context.Context, from address.Address, to address.Address) (*api.ChannelAvailableFunds, error) {
	ret := _mock.Called(ctx, from, to)

	if len(ret) == 0 {
		panic("no return value specified for PaychAvailableFundsByFromTo")
	}

	var r0 *api.ChannelAvailableFunds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address) (*api.ChannelAvailableFunds, error)); ok {
		return returnFunc(ctx, from, to)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address) *api.ChannelAvailableFunds); ok {
		r0 = returnFunc(ctx, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelAvailableFunds)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address) error); ok {
		r1 = returnFunc(ctx, from, to)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychAvailableFundsByFromTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychAvailableFundsByFromTo'
type FullNode_PaychAvailableFundsByFromTo_Call struct {
	*mock.Call
}

// PaychAvailableFundsByFromTo is a helper method to define mock.On call
//   - ctx
//   - from
//   - to
func (_e *FullNode_Expecter) PaychAvailableFundsByFromTo(ctx interface{}, from interface{}, to interface{}) *FullNode_PaychAvailableFundsByFromTo_Call {
	return &FullNode_PaychAvailableFundsByFromTo_Call{Call: _e.mock.On("PaychAvailableFundsByFromTo", ctx, from, to)}
}

func (_c *FullNode_PaychAvailableFundsByFromTo_Call) Run(run func(ctx context.Context, from address.Address, to address.Address)) *FullNode_PaychAvailableFundsByFromTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychAvailableFundsByFromTo_Call) Return(channelAvailableFunds *api.ChannelAvailableFunds, err error) *FullNode_PaychAvailableFundsByFromTo_Call {
	_c.Call.Return(channelAvailableFunds, err)
	return _c
}

func (_c *FullNode_PaychAvailableFundsByFromTo_Call) RunAndReturn(run func(ctx context.Context, from address.Address, to address.Address) (*api.ChannelAvailableFunds, error)) *FullNode_PaychAvailableFundsByFromTo_Call {
	_c.Call.Return(run)
	return _c
}

// PaychCollect provides a mock function for the type FullNode
func (_mock *FullNode) PaychCollect(context1 context.Context, address1 address.Address) (cid.Cid, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for PaychCollect")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (cid.Cid, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychCollect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychCollect'
type FullNode_PaychCollect_Call struct {
	*mock.Call
}

// PaychCollect is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) PaychCollect(context1 interface{}, address1 interface{}) *FullNode_PaychCollect_Call {
	return &FullNode_PaychCollect_Call{Call: _e.mock.On("PaychCollect", context1, address1)}
}

func (_c *FullNode_PaychCollect_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_PaychCollect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychCollect_Call) Return(cid1 cid.Cid, err error) *FullNode_PaychCollect_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_PaychCollect_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (cid.Cid, error)) *FullNode_PaychCollect_Call {
	_c.Call.Return(run)
	return _c
}

// PaychFund provides a mock function for the type FullNode
func (_mock *FullNode) PaychFund(ctx context.Context, from address.Address, to address.Address, amt types.BigInt) (*api.ChannelInfo, error) {
	ret := _mock.Called(ctx, from, to, amt)

	if len(ret) == 0 {
		panic("no return value specified for PaychFund")
	}

	var r0 *api.ChannelInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) (*api.ChannelInfo, error)); ok {
		return returnFunc(ctx, from, to, amt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) *api.ChannelInfo); ok {
		r0 = returnFunc(ctx, from, to, amt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt) error); ok {
		r1 = returnFunc(ctx, from, to, amt)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychFund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychFund'
type FullNode_PaychFund_Call struct {
	*mock.Call
}

// PaychFund is a helper method to define mock.On call
//   - ctx
//   - from
//   - to
//   - amt
func (_e *FullNode_Expecter) PaychFund(ctx interface{}, from interface{}, to interface{}, amt interface{}) *FullNode_PaychFund_Call {
	return &FullNode_PaychFund_Call{Call: _e.mock.On("PaychFund", ctx, from, to, amt)}
}

func (_c *FullNode_PaychFund_Call) Run(run func(ctx context.Context, from address.Address, to address.Address, amt types.BigInt)) *FullNode_PaychFund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_PaychFund_Call) Return(channelInfo *api.ChannelInfo, err error) *FullNode_PaychFund_Call {
	_c.Call.Return(channelInfo, err)
	return _c
}

func (_c *FullNode_PaychFund_Call) RunAndReturn(run func(ctx context.Context, from address.Address, to address.Address, amt types.BigInt) (*api.ChannelInfo, error)) *FullNode_PaychFund_Call {
	_c.Call.Return(run)
	return _c
}

// PaychGet provides a mock function for the type FullNode
func (_mock *FullNode) PaychGet(ctx context.Context, from address.Address, to address.Address, amt types.BigInt, opts api.PaychGetOpts) (*api.ChannelInfo, error) {
	ret := _mock.Called(ctx, from, to, amt, opts)

	if len(ret) == 0 {
		panic("no return value specified for PaychGet")
	}

	var r0 *api.ChannelInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt, api.PaychGetOpts) (*api.ChannelInfo, error)); ok {
		return returnFunc(ctx, from, to, amt, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt, api.PaychGetOpts) *api.ChannelInfo); ok {
		r0 = returnFunc(ctx, from, to, amt, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt, api.PaychGetOpts) error); ok {
		r1 = returnFunc(ctx, from, to, amt, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychGet'
type FullNode_PaychGet_Call struct {
	*mock.Call
}

// PaychGet is a helper method to define mock.On call
//   - ctx
//   - from
//   - to
//   - amt
//   - opts
func (_e *FullNode_Expecter) PaychGet(ctx interface{}, from interface{}, to interface{}, amt interface{}, opts interface{}) *FullNode_PaychGet_Call {
	return &FullNode_PaychGet_Call{Call: _e.mock.On("PaychGet", ctx, from, to, amt, opts)}
}

func (_c *FullNode_PaychGet_Call) Run(run func(ctx context.Context, from address.Address, to address.Address, amt types.BigInt, opts api.PaychGetOpts)) *FullNode_PaychGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].(types.BigInt), args[4].(api.PaychGetOpts))
	})
	return _c
}

func (_c *FullNode_PaychGet_Call) Return(channelInfo *api.ChannelInfo, err error) *FullNode_PaychGet_Call {
	_c.Call.Return(channelInfo, err)
	return _c
}

func (_c *FullNode_PaychGet_Call) RunAndReturn(run func(ctx context.Context, from address.Address, to address.Address, amt types.BigInt, opts api.PaychGetOpts) (*api.ChannelInfo, error)) *FullNode_PaychGet_Call {
	_c.Call.Return(run)
	return _c
}

// PaychGetWaitReady provides a mock function for the type FullNode
func (_mock *FullNode) PaychGetWaitReady(context1 context.Context, cid1 cid.Cid) (address.Address, error) {
	ret := _mock.Called(context1, cid1)

	if len(ret) == 0 {
		panic("no return value specified for PaychGetWaitReady")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (address.Address, error)); ok {
		return returnFunc(context1, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) address.Address); ok {
		r0 = returnFunc(context1, cid1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychGetWaitReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychGetWaitReady'
type FullNode_PaychGetWaitReady_Call struct {
	*mock.Call
}

// PaychGetWaitReady is a helper method to define mock.On call
//   - context1
//   - cid1
func (_e *FullNode_Expecter) PaychGetWaitReady(context1 interface{}, cid1 interface{}) *FullNode_PaychGetWaitReady_Call {
	return &FullNode_PaychGetWaitReady_Call{Call: _e.mock.On("PaychGetWaitReady", context1, cid1)}
}

func (_c *FullNode_PaychGetWaitReady_Call) Run(run func(context1 context.Context, cid1 cid.Cid)) *FullNode_PaychGetWaitReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_PaychGetWaitReady_Call) Return(address1 address.Address, err error) *FullNode_PaychGetWaitReady_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_PaychGetWaitReady_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid) (address.Address, error)) *FullNode_PaychGetWaitReady_Call {
	_c.Call.Return(run)
	return _c
}

// PaychList provides a mock function for the type FullNode
func (_mock *FullNode) PaychList(context1 context.Context) ([]address.Address, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for PaychList")
	}

	var r0 []address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]address.Address, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychList'
type FullNode_PaychList_Call struct {
	*mock.Call
}

// PaychList is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) PaychList(context1 interface{}) *FullNode_PaychList_Call {
	return &FullNode_PaychList_Call{Call: _e.mock.On("PaychList", context1)}
}

func (_c *FullNode_PaychList_Call) Run(run func(context1 context.Context)) *FullNode_PaychList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_PaychList_Call) Return(addresss []address.Address, err error) *FullNode_PaychList_Call {
	_c.Call.Return(addresss, err)
	return _c
}

func (_c *FullNode_PaychList_Call) RunAndReturn(run func(context1 context.Context) ([]address.Address, error)) *FullNode_PaychList_Call {
	_c.Call.Return(run)
	return _c
}

// PaychNewPayment provides a mock function for the type FullNode
func (_mock *FullNode) PaychNewPayment(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec) (*api.PaymentInfo, error) {
	ret := _mock.Called(ctx, from, to, vouchers)

	if len(ret) == 0 {
		panic("no return value specified for PaychNewPayment")
	}

	var r0 *api.PaymentInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) (*api.PaymentInfo, error)); ok {
		return returnFunc(ctx, from, to, vouchers)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) *api.PaymentInfo); ok {
		r0 = returnFunc(ctx, from, to, vouchers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaymentInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) error); ok {
		r1 = returnFunc(ctx, from, to, vouchers)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychNewPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychNewPayment'
type FullNode_PaychNewPayment_Call struct {
	*mock.Call
}

// PaychNewPayment is a helper method to define mock.On call
//   - ctx
//   - from
//   - to
//   - vouchers
func (_e *FullNode_Expecter) PaychNewPayment(ctx interface{}, from interface{}, to interface{}, vouchers interface{}) *FullNode_PaychNewPayment_Call {
	return &FullNode_PaychNewPayment_Call{Call: _e.mock.On("PaychNewPayment", ctx, from, to, vouchers)}
}

func (_c *FullNode_PaychNewPayment_Call) Run(run func(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec)) *FullNode_PaychNewPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(address.Address), args[3].([]api.VoucherSpec))
	})
	return _c
}

func (_c *FullNode_PaychNewPayment_Call) Return(paymentInfo *api.PaymentInfo, err error) *FullNode_PaychNewPayment_Call {
	_c.Call.Return(paymentInfo, err)
	return _c
}

func (_c *FullNode_PaychNewPayment_Call) RunAndReturn(run func(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec) (*api.PaymentInfo, error)) *FullNode_PaychNewPayment_Call {
	_c.Call.Return(run)
	return _c
}

// PaychSettle provides a mock function for the type FullNode
func (_mock *FullNode) PaychSettle(context1 context.Context, address1 address.Address) (cid.Cid, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for PaychSettle")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (cid.Cid, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychSettle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychSettle'
type FullNode_PaychSettle_Call struct {
	*mock.Call
}

// PaychSettle is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) PaychSettle(context1 interface{}, address1 interface{}) *FullNode_PaychSettle_Call {
	return &FullNode_PaychSettle_Call{Call: _e.mock.On("PaychSettle", context1, address1)}
}

func (_c *FullNode_PaychSettle_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_PaychSettle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychSettle_Call) Return(cid1 cid.Cid, err error) *FullNode_PaychSettle_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_PaychSettle_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (cid.Cid, error)) *FullNode_PaychSettle_Call {
	_c.Call.Return(run)
	return _c
}

// PaychStatus provides a mock function for the type FullNode
func (_mock *FullNode) PaychStatus(context1 context.Context, address1 address.Address) (*api.PaychStatus, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for PaychStatus")
	}

	var r0 *api.PaychStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (*api.PaychStatus, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) *api.PaychStatus); ok {
		r0 = returnFunc(context1, address1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaychStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychStatus'
type FullNode_PaychStatus_Call struct {
	*mock.Call
}

// PaychStatus is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) PaychStatus(context1 interface{}, address1 interface{}) *FullNode_PaychStatus_Call {
	return &FullNode_PaychStatus_Call{Call: _e.mock.On("PaychStatus", context1, address1)}
}

func (_c *FullNode_PaychStatus_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_PaychStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychStatus_Call) Return(paychStatus *api.PaychStatus, err error) *FullNode_PaychStatus_Call {
	_c.Call.Return(paychStatus, err)
	return _c
}

func (_c *FullNode_PaychStatus_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (*api.PaychStatus, error)) *FullNode_PaychStatus_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherAdd provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherAdd(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, v types.BigInt) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, signedVoucher, bytes, v)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherAdd")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, types.BigInt) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, signedVoucher, bytes, v)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, types.BigInt) types.BigInt); ok {
		r0 = returnFunc(context1, address1, signedVoucher, bytes, v)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, types.BigInt) error); ok {
		r1 = returnFunc(context1, address1, signedVoucher, bytes, v)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychVoucherAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherAdd'
type FullNode_PaychVoucherAdd_Call struct {
	*mock.Call
}

// PaychVoucherAdd is a helper method to define mock.On call
//   - context1
//   - address1
//   - signedVoucher
//   - bytes
//   - v
func (_e *FullNode_Expecter) PaychVoucherAdd(context1 interface{}, address1 interface{}, signedVoucher interface{}, bytes interface{}, v interface{}) *FullNode_PaychVoucherAdd_Call {
	return &FullNode_PaychVoucherAdd_Call{Call: _e.mock.On("PaychVoucherAdd", context1, address1, signedVoucher, bytes, v)}
}

func (_c *FullNode_PaychVoucherAdd_Call) Run(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, v types.BigInt)) *FullNode_PaychVoucherAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*paych.SignedVoucher), args[3].([]byte), args[4].(types.BigInt))
	})
	return _c
}

func (_c *FullNode_PaychVoucherAdd_Call) Return(v1 types.BigInt, err error) *FullNode_PaychVoucherAdd_Call {
	_c.Call.Return(v1, err)
	return _c
}

func (_c *FullNode_PaychVoucherAdd_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, v types.BigInt) (types.BigInt, error)) *FullNode_PaychVoucherAdd_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherCheckSpendable provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherCheckSpendable(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte) (bool, error) {
	ret := _mock.Called(context1, address1, signedVoucher, bytes, bytes1)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCheckSpendable")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) (bool, error)); ok {
		return returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) bool); ok {
		r0 = returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) error); ok {
		r1 = returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychVoucherCheckSpendable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherCheckSpendable'
type FullNode_PaychVoucherCheckSpendable_Call struct {
	*mock.Call
}

// PaychVoucherCheckSpendable is a helper method to define mock.On call
//   - context1
//   - address1
//   - signedVoucher
//   - bytes
//   - bytes1
func (_e *FullNode_Expecter) PaychVoucherCheckSpendable(context1 interface{}, address1 interface{}, signedVoucher interface{}, bytes interface{}, bytes1 interface{}) *FullNode_PaychVoucherCheckSpendable_Call {
	return &FullNode_PaychVoucherCheckSpendable_Call{Call: _e.mock.On("PaychVoucherCheckSpendable", context1, address1, signedVoucher, bytes, bytes1)}
}

func (_c *FullNode_PaychVoucherCheckSpendable_Call) Run(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte)) *FullNode_PaychVoucherCheckSpendable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*paych.SignedVoucher), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *FullNode_PaychVoucherCheckSpendable_Call) Return(b bool, err error) *FullNode_PaychVoucherCheckSpendable_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_PaychVoucherCheckSpendable_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte) (bool, error)) *FullNode_PaychVoucherCheckSpendable_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherCheckValid provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherCheckValid(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher) error {
	ret := _mock.Called(context1, address1, signedVoucher)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCheckValid")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher) error); ok {
		r0 = returnFunc(context1, address1, signedVoucher)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_PaychVoucherCheckValid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherCheckValid'
type FullNode_PaychVoucherCheckValid_Call struct {
	*mock.Call
}

// PaychVoucherCheckValid is a helper method to define mock.On call
//   - context1
//   - address1
//   - signedVoucher
func (_e *FullNode_Expecter) PaychVoucherCheckValid(context1 interface{}, address1 interface{}, signedVoucher interface{}) *FullNode_PaychVoucherCheckValid_Call {
	return &FullNode_PaychVoucherCheckValid_Call{Call: _e.mock.On("PaychVoucherCheckValid", context1, address1, signedVoucher)}
}

func (_c *FullNode_PaychVoucherCheckValid_Call) Run(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher)) *FullNode_PaychVoucherCheckValid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*paych.SignedVoucher))
	})
	return _c
}

func (_c *FullNode_PaychVoucherCheckValid_Call) Return(err error) *FullNode_PaychVoucherCheckValid_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_PaychVoucherCheckValid_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher) error) *FullNode_PaychVoucherCheckValid_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherCreate provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherCreate(context1 context.Context, address1 address.Address, v types.BigInt, v1 uint64) (*api.VoucherCreateResult, error) {
	ret := _mock.Called(context1, address1, v, v1)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCreate")
	}

	var r0 *api.VoucherCreateResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.BigInt, uint64) (*api.VoucherCreateResult, error)); ok {
		return returnFunc(context1, address1, v, v1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.BigInt, uint64) *api.VoucherCreateResult); ok {
		r0 = returnFunc(context1, address1, v, v1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.VoucherCreateResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.BigInt, uint64) error); ok {
		r1 = returnFunc(context1, address1, v, v1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychVoucherCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherCreate'
type FullNode_PaychVoucherCreate_Call struct {
	*mock.Call
}

// PaychVoucherCreate is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - v1
func (_e *FullNode_Expecter) PaychVoucherCreate(context1 interface{}, address1 interface{}, v interface{}, v1 interface{}) *FullNode_PaychVoucherCreate_Call {
	return &FullNode_PaychVoucherCreate_Call{Call: _e.mock.On("PaychVoucherCreate", context1, address1, v, v1)}
}

func (_c *FullNode_PaychVoucherCreate_Call) Run(run func(context1 context.Context, address1 address.Address, v types.BigInt, v1 uint64)) *FullNode_PaychVoucherCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.BigInt), args[3].(uint64))
	})
	return _c
}

func (_c *FullNode_PaychVoucherCreate_Call) Return(voucherCreateResult *api.VoucherCreateResult, err error) *FullNode_PaychVoucherCreate_Call {
	_c.Call.Return(voucherCreateResult, err)
	return _c
}

func (_c *FullNode_PaychVoucherCreate_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v types.BigInt, v1 uint64) (*api.VoucherCreateResult, error)) *FullNode_PaychVoucherCreate_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherList provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherList(context1 context.Context, address1 address.Address) ([]*paych.SignedVoucher, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherList")
	}

	var r0 []*paych.SignedVoucher
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) ([]*paych.SignedVoucher, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) []*paych.SignedVoucher); ok {
		r0 = returnFunc(context1, address1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*paych.SignedVoucher)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychVoucherList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherList'
type FullNode_PaychVoucherList_Call struct {
	*mock.Call
}

// PaychVoucherList is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) PaychVoucherList(context1 interface{}, address1 interface{}) *FullNode_PaychVoucherList_Call {
	return &FullNode_PaychVoucherList_Call{Call: _e.mock.On("PaychVoucherList", context1, address1)}
}

func (_c *FullNode_PaychVoucherList_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_PaychVoucherList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_PaychVoucherList_Call) Return(signedVouchers []*paych.SignedVoucher, err error) *FullNode_PaychVoucherList_Call {
	_c.Call.Return(signedVouchers, err)
	return _c
}

func (_c *FullNode_PaychVoucherList_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) ([]*paych.SignedVoucher, error)) *FullNode_PaychVoucherList_Call {
	_c.Call.Return(run)
	return _c
}

// PaychVoucherSubmit provides a mock function for the type FullNode
func (_mock *FullNode) PaychVoucherSubmit(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte) (cid.Cid, error) {
	ret := _mock.Called(context1, address1, signedVoucher, bytes, bytes1)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherSubmit")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) (cid.Cid, error)); ok {
		return returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) cid.Cid); ok {
		r0 = returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) error); ok {
		r1 = returnFunc(context1, address1, signedVoucher, bytes, bytes1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_PaychVoucherSubmit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaychVoucherSubmit'
type FullNode_PaychVoucherSubmit_Call struct {
	*mock.Call
}

// PaychVoucherSubmit is a helper method to define mock.On call
//   - context1
//   - address1
//   - signedVoucher
//   - bytes
//   - bytes1
func (_e *FullNode_Expecter) PaychVoucherSubmit(context1 interface{}, address1 interface{}, signedVoucher interface{}, bytes interface{}, bytes1 interface{}) *FullNode_PaychVoucherSubmit_Call {
	return &FullNode_PaychVoucherSubmit_Call{Call: _e.mock.On("PaychVoucherSubmit", context1, address1, signedVoucher, bytes, bytes1)}
}

func (_c *FullNode_PaychVoucherSubmit_Call) Run(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte)) *FullNode_PaychVoucherSubmit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*paych.SignedVoucher), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *FullNode_PaychVoucherSubmit_Call) Return(cid1 cid.Cid, err error) *FullNode_PaychVoucherSubmit_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_PaychVoucherSubmit_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, signedVoucher *paych.SignedVoucher, bytes []byte, bytes1 []byte) (cid.Cid, error)) *FullNode_PaychVoucherSubmit_Call {
	_c.Call.Return(run)
	return _c
}

// Session provides a mock function for the type FullNode
func (_mock *FullNode) Session(context1 context.Context) (uuid.UUID, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Session")
	}

	var r0 uuid.UUID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (uuid.UUID, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) uuid.UUID); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_Session_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Session'
type FullNode_Session_Call struct {
	*mock.Call
}

// Session is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) Session(context1 interface{}) *FullNode_Session_Call {
	return &FullNode_Session_Call{Call: _e.mock.On("Session", context1)}
}

func (_c *FullNode_Session_Call) Run(run func(context1 context.Context)) *FullNode_Session_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Session_Call) Return(uUID uuid.UUID, err error) *FullNode_Session_Call {
	_c.Call.Return(uUID, err)
	return _c
}

func (_c *FullNode_Session_Call) RunAndReturn(run func(context1 context.Context) (uuid.UUID, error)) *FullNode_Session_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function for the type FullNode
func (_mock *FullNode) Shutdown(context1 context.Context) error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type FullNode_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) Shutdown(context1 interface{}) *FullNode_Shutdown_Call {
	return &FullNode_Shutdown_Call{Call: _e.mock.On("Shutdown", context1)}
}

func (_c *FullNode_Shutdown_Call) Run(run func(context1 context.Context)) *FullNode_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Shutdown_Call) Return(err error) *FullNode_Shutdown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_Shutdown_Call) RunAndReturn(run func(context1 context.Context) error) *FullNode_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// StartTime provides a mock function for the type FullNode
func (_mock *FullNode) StartTime(context1 context.Context) (time.Time, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for StartTime")
	}

	var r0 time.Time
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (time.Time, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StartTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartTime'
type FullNode_StartTime_Call struct {
	*mock.Call
}

// StartTime is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) StartTime(context1 interface{}) *FullNode_StartTime_Call {
	return &FullNode_StartTime_Call{Call: _e.mock.On("StartTime", context1)}
}

func (_c *FullNode_StartTime_Call) Run(run func(context1 context.Context)) *FullNode_StartTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_StartTime_Call) Return(time1 time.Time, err error) *FullNode_StartTime_Call {
	_c.Call.Return(time1, err)
	return _c
}

func (_c *FullNode_StartTime_Call) RunAndReturn(run func(context1 context.Context) (time.Time, error)) *FullNode_StartTime_Call {
	_c.Call.Return(run)
	return _c
}

// StateAccountKey provides a mock function for the type FullNode
func (_mock *FullNode) StateAccountKey(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateAccountKey")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateAccountKey'
type FullNode_StateAccountKey_Call struct {
	*mock.Call
}

// StateAccountKey is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateAccountKey(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateAccountKey_Call {
	return &FullNode_StateAccountKey_Call{Call: _e.mock.On("StateAccountKey", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateAccountKey_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateAccountKey_Call) Return(address11 address.Address, err error) *FullNode_StateAccountKey_Call {
	_c.Call.Return(address11, err)
	return _c
}

func (_c *FullNode_StateAccountKey_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error)) *FullNode_StateAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// StateActorCodeCIDs provides a mock function for the type FullNode
func (_mock *FullNode) StateActorCodeCIDs(context1 context.Context, version network0.Version) (map[string]cid.Cid, error) {
	ret := _mock.Called(context1, version)

	if len(ret) == 0 {
		panic("no return value specified for StateActorCodeCIDs")
	}

	var r0 map[string]cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.Version) (map[string]cid.Cid, error)); ok {
		return returnFunc(context1, version)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.Version) map[string]cid.Cid); ok {
		r0 = returnFunc(context1, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]cid.Cid)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, network0.Version) error); ok {
		r1 = returnFunc(context1, version)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateActorCodeCIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateActorCodeCIDs'
type FullNode_StateActorCodeCIDs_Call struct {
	*mock.Call
}

// StateActorCodeCIDs is a helper method to define mock.On call
//   - context1
//   - version
func (_e *FullNode_Expecter) StateActorCodeCIDs(context1 interface{}, version interface{}) *FullNode_StateActorCodeCIDs_Call {
	return &FullNode_StateActorCodeCIDs_Call{Call: _e.mock.On("StateActorCodeCIDs", context1, version)}
}

func (_c *FullNode_StateActorCodeCIDs_Call) Run(run func(context1 context.Context, version network0.Version)) *FullNode_StateActorCodeCIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(network0.Version))
	})
	return _c
}

func (_c *FullNode_StateActorCodeCIDs_Call) Return(stringToCid map[string]cid.Cid, err error) *FullNode_StateActorCodeCIDs_Call {
	_c.Call.Return(stringToCid, err)
	return _c
}

func (_c *FullNode_StateActorCodeCIDs_Call) RunAndReturn(run func(context1 context.Context, version network0.Version) (map[string]cid.Cid, error)) *FullNode_StateActorCodeCIDs_Call {
	_c.Call.Return(run)
	return _c
}

// StateActorManifestCID provides a mock function for the type FullNode
func (_mock *FullNode) StateActorManifestCID(context1 context.Context, version network0.Version) (cid.Cid, error) {
	ret := _mock.Called(context1, version)

	if len(ret) == 0 {
		panic("no return value specified for StateActorManifestCID")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.Version) (cid.Cid, error)); ok {
		return returnFunc(context1, version)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.Version) cid.Cid); ok {
		r0 = returnFunc(context1, version)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, network0.Version) error); ok {
		r1 = returnFunc(context1, version)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateActorManifestCID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateActorManifestCID'
type FullNode_StateActorManifestCID_Call struct {
	*mock.Call
}

// StateActorManifestCID is a helper method to define mock.On call
//   - context1
//   - version
func (_e *FullNode_Expecter) StateActorManifestCID(context1 interface{}, version interface{}) *FullNode_StateActorManifestCID_Call {
	return &FullNode_StateActorManifestCID_Call{Call: _e.mock.On("StateActorManifestCID", context1, version)}
}

func (_c *FullNode_StateActorManifestCID_Call) Run(run func(context1 context.Context, version network0.Version)) *FullNode_StateActorManifestCID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(network0.Version))
	})
	return _c
}

func (_c *FullNode_StateActorManifestCID_Call) Return(cid1 cid.Cid, err error) *FullNode_StateActorManifestCID_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_StateActorManifestCID_Call) RunAndReturn(run func(context1 context.Context, version network0.Version) (cid.Cid, error)) *FullNode_StateActorManifestCID_Call {
	_c.Call.Return(run)
	return _c
}

// StateAllMinerFaults provides a mock function for the type FullNode
func (_mock *FullNode) StateAllMinerFaults(ctx context.Context, lookback abi.ChainEpoch, ts types.TipSetKey) ([]*api.Fault, error) {
	ret := _mock.Called(ctx, lookback, ts)

	if len(ret) == 0 {
		panic("no return value specified for StateAllMinerFaults")
	}

	var r0 []*api.Fault
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) ([]*api.Fault, error)); ok {
		return returnFunc(ctx, lookback, ts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) []*api.Fault); ok {
		r0 = returnFunc(ctx, lookback, ts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Fault)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, lookback, ts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateAllMinerFaults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateAllMinerFaults'
type FullNode_StateAllMinerFaults_Call struct {
	*mock.Call
}

// StateAllMinerFaults is a helper method to define mock.On call
//   - ctx
//   - lookback
//   - ts
func (_e *FullNode_Expecter) StateAllMinerFaults(ctx interface{}, lookback interface{}, ts interface{}) *FullNode_StateAllMinerFaults_Call {
	return &FullNode_StateAllMinerFaults_Call{Call: _e.mock.On("StateAllMinerFaults", ctx, lookback, ts)}
}

func (_c *FullNode_StateAllMinerFaults_Call) Run(run func(ctx context.Context, lookback abi.ChainEpoch, ts types.TipSetKey)) *FullNode_StateAllMinerFaults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateAllMinerFaults_Call) Return(faults []*api.Fault, err error) *FullNode_StateAllMinerFaults_Call {
	_c.Call.Return(faults, err)
	return _c
}

func (_c *FullNode_StateAllMinerFaults_Call) RunAndReturn(run func(ctx context.Context, lookback abi.ChainEpoch, ts types.TipSetKey) ([]*api.Fault, error)) *FullNode_StateAllMinerFaults_Call {
	_c.Call.Return(run)
	return _c
}

// StateCall provides a mock function for the type FullNode
func (_mock *FullNode) StateCall(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey) (*api.InvocResult, error) {
	ret := _mock.Called(context1, message, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateCall")
	}

	var r0 *api.InvocResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) (*api.InvocResult, error)); ok {
		return returnFunc(context1, message, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) *api.InvocResult); ok {
		r0 = returnFunc(context1, message, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, message, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateCall'
type FullNode_StateCall_Call struct {
	*mock.Call
}

// StateCall is a helper method to define mock.On call
//   - context1
//   - message
//   - tipSetKey
func (_e *FullNode_Expecter) StateCall(context1 interface{}, message interface{}, tipSetKey interface{}) *FullNode_StateCall_Call {
	return &FullNode_StateCall_Call{Call: _e.mock.On("StateCall", context1, message, tipSetKey)}
}

func (_c *FullNode_StateCall_Call) Run(run func(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey)) *FullNode_StateCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Message), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateCall_Call) Return(invocResult *api.InvocResult, err error) *FullNode_StateCall_Call {
	_c.Call.Return(invocResult, err)
	return _c
}

func (_c *FullNode_StateCall_Call) RunAndReturn(run func(context1 context.Context, message *types.Message, tipSetKey types.TipSetKey) (*api.InvocResult, error)) *FullNode_StateCall_Call {
	_c.Call.Return(run)
	return _c
}

// StateChangedActors provides a mock function for the type FullNode
func (_mock *FullNode) StateChangedActors(context1 context.Context, cid1 cid.Cid, cid11 cid.Cid) (map[string]types.Actor, error) {
	ret := _mock.Called(context1, cid1, cid11)

	if len(ret) == 0 {
		panic("no return value specified for StateChangedActors")
	}

	var r0 map[string]types.Actor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) (map[string]types.Actor, error)); ok {
		return returnFunc(context1, cid1, cid11)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) map[string]types.Actor); ok {
		r0 = returnFunc(context1, cid1, cid11)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.Actor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = returnFunc(context1, cid1, cid11)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateChangedActors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateChangedActors'
type FullNode_StateChangedActors_Call struct {
	*mock.Call
}

// StateChangedActors is a helper method to define mock.On call
//   - context1
//   - cid1
//   - cid11
func (_e *FullNode_Expecter) StateChangedActors(context1 interface{}, cid1 interface{}, cid11 interface{}) *FullNode_StateChangedActors_Call {
	return &FullNode_StateChangedActors_Call{Call: _e.mock.On("StateChangedActors", context1, cid1, cid11)}
}

func (_c *FullNode_StateChangedActors_Call) Run(run func(context1 context.Context, cid1 cid.Cid, cid11 cid.Cid)) *FullNode_StateChangedActors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_StateChangedActors_Call) Return(stringToV map[string]types.Actor, err error) *FullNode_StateChangedActors_Call {
	_c.Call.Return(stringToV, err)
	return _c
}

func (_c *FullNode_StateChangedActors_Call) RunAndReturn(run func(context1 context.Context, cid1 cid.Cid, cid11 cid.Cid) (map[string]types.Actor, error)) *FullNode_StateChangedActors_Call {
	_c.Call.Return(run)
	return _c
}

// StateCirculatingSupply provides a mock function for the type FullNode
func (_mock *FullNode) StateCirculatingSupply(context1 context.Context, tipSetKey types.TipSetKey) (abi.TokenAmount, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateCirculatingSupply")
	}

	var r0 abi.TokenAmount
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (abi.TokenAmount, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) abi.TokenAmount); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		r0 = ret.Get(0).(abi.TokenAmount)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateCirculatingSupply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateCirculatingSupply'
type FullNode_StateCirculatingSupply_Call struct {
	*mock.Call
}

// StateCirculatingSupply is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateCirculatingSupply(context1 interface{}, tipSetKey interface{}) *FullNode_StateCirculatingSupply_Call {
	return &FullNode_StateCirculatingSupply_Call{Call: _e.mock.On("StateCirculatingSupply", context1, tipSetKey)}
}

func (_c *FullNode_StateCirculatingSupply_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateCirculatingSupply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateCirculatingSupply_Call) Return(v abi.TokenAmount, err error) *FullNode_StateCirculatingSupply_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateCirculatingSupply_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (abi.TokenAmount, error)) *FullNode_StateCirculatingSupply_Call {
	_c.Call.Return(run)
	return _c
}

// StateCompute provides a mock function for the type FullNode
func (_mock *FullNode) StateCompute(context1 context.Context, chainEpoch abi.ChainEpoch, messages []*types.Message, tipSetKey types.TipSetKey) (*api.ComputeStateOutput, error) {
	ret := _mock.Called(context1, chainEpoch, messages, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateCompute")
	}

	var r0 *api.ComputeStateOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) (*api.ComputeStateOutput, error)); ok {
		return returnFunc(context1, chainEpoch, messages, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) *api.ComputeStateOutput); ok {
		r0 = returnFunc(context1, chainEpoch, messages, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ComputeStateOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, chainEpoch, messages, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateCompute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateCompute'
type FullNode_StateCompute_Call struct {
	*mock.Call
}

// StateCompute is a helper method to define mock.On call
//   - context1
//   - chainEpoch
//   - messages
//   - tipSetKey
func (_e *FullNode_Expecter) StateCompute(context1 interface{}, chainEpoch interface{}, messages interface{}, tipSetKey interface{}) *FullNode_StateCompute_Call {
	return &FullNode_StateCompute_Call{Call: _e.mock.On("StateCompute", context1, chainEpoch, messages, tipSetKey)}
}

func (_c *FullNode_StateCompute_Call) Run(run func(context1 context.Context, chainEpoch abi.ChainEpoch, messages []*types.Message, tipSetKey types.TipSetKey)) *FullNode_StateCompute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].([]*types.Message), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateCompute_Call) Return(computeStateOutput *api.ComputeStateOutput, err error) *FullNode_StateCompute_Call {
	_c.Call.Return(computeStateOutput, err)
	return _c
}

func (_c *FullNode_StateCompute_Call) RunAndReturn(run func(context1 context.Context, chainEpoch abi.ChainEpoch, messages []*types.Message, tipSetKey types.TipSetKey) (*api.ComputeStateOutput, error)) *FullNode_StateCompute_Call {
	_c.Call.Return(run)
	return _c
}

// StateComputeDataCID provides a mock function for the type FullNode
func (_mock *FullNode) StateComputeDataCID(ctx context.Context, maddr address.Address, sectorType abi.RegisteredSealProof, deals []abi.DealID, tsk types.TipSetKey) (cid.Cid, error) {
	ret := _mock.Called(ctx, maddr, sectorType, deals, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateComputeDataCID")
	}

	var r0 cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) (cid.Cid, error)); ok {
		return returnFunc(ctx, maddr, sectorType, deals, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) cid.Cid); ok {
		r0 = returnFunc(ctx, maddr, sectorType, deals, tsk)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, maddr, sectorType, deals, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateComputeDataCID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateComputeDataCID'
type FullNode_StateComputeDataCID_Call struct {
	*mock.Call
}

// StateComputeDataCID is a helper method to define mock.On call
//   - ctx
//   - maddr
//   - sectorType
//   - deals
//   - tsk
func (_e *FullNode_Expecter) StateComputeDataCID(ctx interface{}, maddr interface{}, sectorType interface{}, deals interface{}, tsk interface{}) *FullNode_StateComputeDataCID_Call {
	return &FullNode_StateComputeDataCID_Call{Call: _e.mock.On("StateComputeDataCID", ctx, maddr, sectorType, deals, tsk)}
}

func (_c *FullNode_StateComputeDataCID_Call) Run(run func(ctx context.Context, maddr address.Address, sectorType abi.RegisteredSealProof, deals []abi.DealID, tsk types.TipSetKey)) *FullNode_StateComputeDataCID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.RegisteredSealProof), args[3].([]abi.DealID), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateComputeDataCID_Call) Return(cid1 cid.Cid, err error) *FullNode_StateComputeDataCID_Call {
	_c.Call.Return(cid1, err)
	return _c
}

func (_c *FullNode_StateComputeDataCID_Call) RunAndReturn(run func(ctx context.Context, maddr address.Address, sectorType abi.RegisteredSealProof, deals []abi.DealID, tsk types.TipSetKey) (cid.Cid, error)) *FullNode_StateComputeDataCID_Call {
	_c.Call.Return(run)
	return _c
}

// StateDealProviderCollateralBounds provides a mock function for the type FullNode
func (_mock *FullNode) StateDealProviderCollateralBounds(context1 context.Context, paddedPieceSize abi.PaddedPieceSize, b bool, tipSetKey types.TipSetKey) (api.DealCollateralBounds, error) {
	ret := _mock.Called(context1, paddedPieceSize, b, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateDealProviderCollateralBounds")
	}

	var r0 api.DealCollateralBounds
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) (api.DealCollateralBounds, error)); ok {
		return returnFunc(context1, paddedPieceSize, b, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) api.DealCollateralBounds); ok {
		r0 = returnFunc(context1, paddedPieceSize, b, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.DealCollateralBounds)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, paddedPieceSize, b, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateDealProviderCollateralBounds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateDealProviderCollateralBounds'
type FullNode_StateDealProviderCollateralBounds_Call struct {
	*mock.Call
}

// StateDealProviderCollateralBounds is a helper method to define mock.On call
//   - context1
//   - paddedPieceSize
//   - b
//   - tipSetKey
func (_e *FullNode_Expecter) StateDealProviderCollateralBounds(context1 interface{}, paddedPieceSize interface{}, b interface{}, tipSetKey interface{}) *FullNode_StateDealProviderCollateralBounds_Call {
	return &FullNode_StateDealProviderCollateralBounds_Call{Call: _e.mock.On("StateDealProviderCollateralBounds", context1, paddedPieceSize, b, tipSetKey)}
}

func (_c *FullNode_StateDealProviderCollateralBounds_Call) Run(run func(context1 context.Context, paddedPieceSize abi.PaddedPieceSize, b bool, tipSetKey types.TipSetKey)) *FullNode_StateDealProviderCollateralBounds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.PaddedPieceSize), args[2].(bool), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateDealProviderCollateralBounds_Call) Return(dealCollateralBounds api.DealCollateralBounds, err error) *FullNode_StateDealProviderCollateralBounds_Call {
	_c.Call.Return(dealCollateralBounds, err)
	return _c
}

func (_c *FullNode_StateDealProviderCollateralBounds_Call) RunAndReturn(run func(context1 context.Context, paddedPieceSize abi.PaddedPieceSize, b bool, tipSetKey types.TipSetKey) (api.DealCollateralBounds, error)) *FullNode_StateDealProviderCollateralBounds_Call {
	_c.Call.Return(run)
	return _c
}

// StateDecodeParams provides a mock function for the type FullNode
func (_mock *FullNode) StateDecodeParams(ctx context.Context, toAddr address.Address, method abi.MethodNum, params []byte, tsk types.TipSetKey) (interface{}, error) {
	ret := _mock.Called(ctx, toAddr, method, params, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateDecodeParams")
	}

	var r0 interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) (interface{}, error)); ok {
		return returnFunc(ctx, toAddr, method, params, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) interface{}); ok {
		r0 = returnFunc(ctx, toAddr, method, params, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, toAddr, method, params, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateDecodeParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateDecodeParams'
type FullNode_StateDecodeParams_Call struct {
	*mock.Call
}

// StateDecodeParams is a helper method to define mock.On call
//   - ctx
//   - toAddr
//   - method
//   - params
//   - tsk
func (_e *FullNode_Expecter) StateDecodeParams(ctx interface{}, toAddr interface{}, method interface{}, params interface{}, tsk interface{}) *FullNode_StateDecodeParams_Call {
	return &FullNode_StateDecodeParams_Call{Call: _e.mock.On("StateDecodeParams", ctx, toAddr, method, params, tsk)}
}

func (_c *FullNode_StateDecodeParams_Call) Run(run func(ctx context.Context, toAddr address.Address, method abi.MethodNum, params []byte, tsk types.TipSetKey)) *FullNode_StateDecodeParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.MethodNum), args[3].([]byte), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateDecodeParams_Call) Return(ifaceVal interface{}, err error) *FullNode_StateDecodeParams_Call {
	_c.Call.Return(ifaceVal, err)
	return _c
}

func (_c *FullNode_StateDecodeParams_Call) RunAndReturn(run func(ctx context.Context, toAddr address.Address, method abi.MethodNum, params []byte, tsk types.TipSetKey) (interface{}, error)) *FullNode_StateDecodeParams_Call {
	_c.Call.Return(run)
	return _c
}

// StateEncodeParams provides a mock function for the type FullNode
func (_mock *FullNode) StateEncodeParams(ctx context.Context, toActCode cid.Cid, method abi.MethodNum, params json.RawMessage) ([]byte, error) {
	ret := _mock.Called(ctx, toActCode, method, params)

	if len(ret) == 0 {
		panic("no return value specified for StateEncodeParams")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) ([]byte, error)); ok {
		return returnFunc(ctx, toActCode, method, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) []byte); ok {
		r0 = returnFunc(ctx, toActCode, method, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) error); ok {
		r1 = returnFunc(ctx, toActCode, method, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateEncodeParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateEncodeParams'
type FullNode_StateEncodeParams_Call struct {
	*mock.Call
}

// StateEncodeParams is a helper method to define mock.On call
//   - ctx
//   - toActCode
//   - method
//   - params
func (_e *FullNode_Expecter) StateEncodeParams(ctx interface{}, toActCode interface{}, method interface{}, params interface{}) *FullNode_StateEncodeParams_Call {
	return &FullNode_StateEncodeParams_Call{Call: _e.mock.On("StateEncodeParams", ctx, toActCode, method, params)}
}

func (_c *FullNode_StateEncodeParams_Call) Run(run func(ctx context.Context, toActCode cid.Cid, method abi.MethodNum, params json.RawMessage)) *FullNode_StateEncodeParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(abi.MethodNum), args[3].(json.RawMessage))
	})
	return _c
}

func (_c *FullNode_StateEncodeParams_Call) Return(bytes []byte, err error) *FullNode_StateEncodeParams_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *FullNode_StateEncodeParams_Call) RunAndReturn(run func(ctx context.Context, toActCode cid.Cid, method abi.MethodNum, params json.RawMessage) ([]byte, error)) *FullNode_StateEncodeParams_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetActor provides a mock function for the type FullNode
func (_mock *FullNode) StateGetActor(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*types.Actor, error) {
	ret := _mock.Called(ctx, actor, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetActor")
	}

	var r0 *types.Actor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*types.Actor, error)); ok {
		return returnFunc(ctx, actor, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *types.Actor); ok {
		r0 = returnFunc(ctx, actor, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Actor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, actor, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetActor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetActor'
type FullNode_StateGetActor_Call struct {
	*mock.Call
}

// StateGetActor is a helper method to define mock.On call
//   - ctx
//   - actor
//   - tsk
func (_e *FullNode_Expecter) StateGetActor(ctx interface{}, actor interface{}, tsk interface{}) *FullNode_StateGetActor_Call {
	return &FullNode_StateGetActor_Call{Call: _e.mock.On("StateGetActor", ctx, actor, tsk)}
}

func (_c *FullNode_StateGetActor_Call) Run(run func(ctx context.Context, actor address.Address, tsk types.TipSetKey)) *FullNode_StateGetActor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetActor_Call) Return(v *types.Actor, err error) *FullNode_StateGetActor_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateGetActor_Call) RunAndReturn(run func(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*types.Actor, error)) *FullNode_StateGetActor_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllAllocations provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllAllocations(ctx context.Context, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllAllocations")
	}

	var r0 map[verifreg.AllocationId]verifreg.Allocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[verifreg.AllocationId]verifreg.Allocation); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.AllocationId]verifreg.Allocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllAllocations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllAllocations'
type FullNode_StateGetAllAllocations_Call struct {
	*mock.Call
}

// StateGetAllAllocations is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) StateGetAllAllocations(ctx interface{}, tsk interface{}) *FullNode_StateGetAllAllocations_Call {
	return &FullNode_StateGetAllAllocations_Call{Call: _e.mock.On("StateGetAllAllocations", ctx, tsk)}
}

func (_c *FullNode_StateGetAllAllocations_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_StateGetAllAllocations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllAllocations_Call) Return(vToV map[verifreg.AllocationId]verifreg.Allocation, err error) *FullNode_StateGetAllAllocations_Call {
	_c.Call.Return(vToV, err)
	return _c
}

func (_c *FullNode_StateGetAllAllocations_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)) *FullNode_StateGetAllAllocations_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllClaims provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllClaims(ctx context.Context, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllClaims")
	}

	var r0 map[verifreg.ClaimId]verifreg.Claim
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[verifreg.ClaimId]verifreg.Claim); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.ClaimId]verifreg.Claim)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllClaims_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllClaims'
type FullNode_StateGetAllClaims_Call struct {
	*mock.Call
}

// StateGetAllClaims is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) StateGetAllClaims(ctx interface{}, tsk interface{}) *FullNode_StateGetAllClaims_Call {
	return &FullNode_StateGetAllClaims_Call{Call: _e.mock.On("StateGetAllClaims", ctx, tsk)}
}

func (_c *FullNode_StateGetAllClaims_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_StateGetAllClaims_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllClaims_Call) Return(vToV map[verifreg.ClaimId]verifreg.Claim, err error) *FullNode_StateGetAllClaims_Call {
	_c.Call.Return(vToV, err)
	return _c
}

func (_c *FullNode_StateGetAllClaims_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)) *FullNode_StateGetAllClaims_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllocation provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllocation(ctx context.Context, clientAddr address.Address, allocationId verifreg.AllocationId, tsk types.TipSetKey) (*verifreg.Allocation, error) {
	ret := _mock.Called(ctx, clientAddr, allocationId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocation")
	}

	var r0 *verifreg.Allocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) (*verifreg.Allocation, error)); ok {
		return returnFunc(ctx, clientAddr, allocationId, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) *verifreg.Allocation); ok {
		r0 = returnFunc(ctx, clientAddr, allocationId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Allocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, clientAddr, allocationId, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllocation'
type FullNode_StateGetAllocation_Call struct {
	*mock.Call
}

// StateGetAllocation is a helper method to define mock.On call
//   - ctx
//   - clientAddr
//   - allocationId
//   - tsk
func (_e *FullNode_Expecter) StateGetAllocation(ctx interface{}, clientAddr interface{}, allocationId interface{}, tsk interface{}) *FullNode_StateGetAllocation_Call {
	return &FullNode_StateGetAllocation_Call{Call: _e.mock.On("StateGetAllocation", ctx, clientAddr, allocationId, tsk)}
}

func (_c *FullNode_StateGetAllocation_Call) Run(run func(ctx context.Context, clientAddr address.Address, allocationId verifreg.AllocationId, tsk types.TipSetKey)) *FullNode_StateGetAllocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(verifreg.AllocationId), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllocation_Call) Return(v *verifreg.Allocation, err error) *FullNode_StateGetAllocation_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateGetAllocation_Call) RunAndReturn(run func(ctx context.Context, clientAddr address.Address, allocationId verifreg.AllocationId, tsk types.TipSetKey) (*verifreg.Allocation, error)) *FullNode_StateGetAllocation_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllocationForPendingDeal provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllocationForPendingDeal(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (*verifreg.Allocation, error) {
	ret := _mock.Called(ctx, dealId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocationForPendingDeal")
	}

	var r0 *verifreg.Allocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (*verifreg.Allocation, error)); ok {
		return returnFunc(ctx, dealId, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) *verifreg.Allocation); ok {
		r0 = returnFunc(ctx, dealId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Allocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, dealId, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllocationForPendingDeal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllocationForPendingDeal'
type FullNode_StateGetAllocationForPendingDeal_Call struct {
	*mock.Call
}

// StateGetAllocationForPendingDeal is a helper method to define mock.On call
//   - ctx
//   - dealId
//   - tsk
func (_e *FullNode_Expecter) StateGetAllocationForPendingDeal(ctx interface{}, dealId interface{}, tsk interface{}) *FullNode_StateGetAllocationForPendingDeal_Call {
	return &FullNode_StateGetAllocationForPendingDeal_Call{Call: _e.mock.On("StateGetAllocationForPendingDeal", ctx, dealId, tsk)}
}

func (_c *FullNode_StateGetAllocationForPendingDeal_Call) Run(run func(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey)) *FullNode_StateGetAllocationForPendingDeal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.DealID), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllocationForPendingDeal_Call) Return(v *verifreg.Allocation, err error) *FullNode_StateGetAllocationForPendingDeal_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateGetAllocationForPendingDeal_Call) RunAndReturn(run func(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (*verifreg.Allocation, error)) *FullNode_StateGetAllocationForPendingDeal_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllocationIdForPendingDeal provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllocationIdForPendingDeal(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (verifreg.AllocationId, error) {
	ret := _mock.Called(ctx, dealId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocationIdForPendingDeal")
	}

	var r0 verifreg.AllocationId
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (verifreg.AllocationId, error)); ok {
		return returnFunc(ctx, dealId, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) verifreg.AllocationId); ok {
		r0 = returnFunc(ctx, dealId, tsk)
	} else {
		r0 = ret.Get(0).(verifreg.AllocationId)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, dealId, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllocationIdForPendingDeal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllocationIdForPendingDeal'
type FullNode_StateGetAllocationIdForPendingDeal_Call struct {
	*mock.Call
}

// StateGetAllocationIdForPendingDeal is a helper method to define mock.On call
//   - ctx
//   - dealId
//   - tsk
func (_e *FullNode_Expecter) StateGetAllocationIdForPendingDeal(ctx interface{}, dealId interface{}, tsk interface{}) *FullNode_StateGetAllocationIdForPendingDeal_Call {
	return &FullNode_StateGetAllocationIdForPendingDeal_Call{Call: _e.mock.On("StateGetAllocationIdForPendingDeal", ctx, dealId, tsk)}
}

func (_c *FullNode_StateGetAllocationIdForPendingDeal_Call) Run(run func(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey)) *FullNode_StateGetAllocationIdForPendingDeal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.DealID), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllocationIdForPendingDeal_Call) Return(v verifreg.AllocationId, err error) *FullNode_StateGetAllocationIdForPendingDeal_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateGetAllocationIdForPendingDeal_Call) RunAndReturn(run func(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (verifreg.AllocationId, error)) *FullNode_StateGetAllocationIdForPendingDeal_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetAllocations provides a mock function for the type FullNode
func (_mock *FullNode) StateGetAllocations(ctx context.Context, clientAddr address.Address, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error) {
	ret := _mock.Called(ctx, clientAddr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocations")
	}

	var r0 map[verifreg.AllocationId]verifreg.Allocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)); ok {
		return returnFunc(ctx, clientAddr, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) map[verifreg.AllocationId]verifreg.Allocation); ok {
		r0 = returnFunc(ctx, clientAddr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.AllocationId]verifreg.Allocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, clientAddr, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetAllocations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetAllocations'
type FullNode_StateGetAllocations_Call struct {
	*mock.Call
}

// StateGetAllocations is a helper method to define mock.On call
//   - ctx
//   - clientAddr
//   - tsk
func (_e *FullNode_Expecter) StateGetAllocations(ctx interface{}, clientAddr interface{}, tsk interface{}) *FullNode_StateGetAllocations_Call {
	return &FullNode_StateGetAllocations_Call{Call: _e.mock.On("StateGetAllocations", ctx, clientAddr, tsk)}
}

func (_c *FullNode_StateGetAllocations_Call) Run(run func(ctx context.Context, clientAddr address.Address, tsk types.TipSetKey)) *FullNode_StateGetAllocations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetAllocations_Call) Return(vToV map[verifreg.AllocationId]verifreg.Allocation, err error) *FullNode_StateGetAllocations_Call {
	_c.Call.Return(vToV, err)
	return _c
}

func (_c *FullNode_StateGetAllocations_Call) RunAndReturn(run func(ctx context.Context, clientAddr address.Address, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)) *FullNode_StateGetAllocations_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetBeaconEntry provides a mock function for the type FullNode
func (_mock *FullNode) StateGetBeaconEntry(ctx context.Context, epoch abi.ChainEpoch) (*types.BeaconEntry, error) {
	ret := _mock.Called(ctx, epoch)

	if len(ret) == 0 {
		panic("no return value specified for StateGetBeaconEntry")
	}

	var r0 *types.BeaconEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch) (*types.BeaconEntry, error)); ok {
		return returnFunc(ctx, epoch)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch) *types.BeaconEntry); ok {
		r0 = returnFunc(ctx, epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BeaconEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch) error); ok {
		r1 = returnFunc(ctx, epoch)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetBeaconEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetBeaconEntry'
type FullNode_StateGetBeaconEntry_Call struct {
	*mock.Call
}

// StateGetBeaconEntry is a helper method to define mock.On call
//   - ctx
//   - epoch
func (_e *FullNode_Expecter) StateGetBeaconEntry(ctx interface{}, epoch interface{}) *FullNode_StateGetBeaconEntry_Call {
	return &FullNode_StateGetBeaconEntry_Call{Call: _e.mock.On("StateGetBeaconEntry", ctx, epoch)}
}

func (_c *FullNode_StateGetBeaconEntry_Call) Run(run func(ctx context.Context, epoch abi.ChainEpoch)) *FullNode_StateGetBeaconEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch))
	})
	return _c
}

func (_c *FullNode_StateGetBeaconEntry_Call) Return(beaconEntry *types.BeaconEntry, err error) *FullNode_StateGetBeaconEntry_Call {
	_c.Call.Return(beaconEntry, err)
	return _c
}

func (_c *FullNode_StateGetBeaconEntry_Call) RunAndReturn(run func(ctx context.Context, epoch abi.ChainEpoch) (*types.BeaconEntry, error)) *FullNode_StateGetBeaconEntry_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetClaim provides a mock function for the type FullNode
func (_mock *FullNode) StateGetClaim(ctx context.Context, providerAddr address.Address, claimId verifreg.ClaimId, tsk types.TipSetKey) (*verifreg.Claim, error) {
	ret := _mock.Called(ctx, providerAddr, claimId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetClaim")
	}

	var r0 *verifreg.Claim
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) (*verifreg.Claim, error)); ok {
		return returnFunc(ctx, providerAddr, claimId, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) *verifreg.Claim); ok {
		r0 = returnFunc(ctx, providerAddr, claimId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Claim)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, providerAddr, claimId, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetClaim'
type FullNode_StateGetClaim_Call struct {
	*mock.Call
}

// StateGetClaim is a helper method to define mock.On call
//   - ctx
//   - providerAddr
//   - claimId
//   - tsk
func (_e *FullNode_Expecter) StateGetClaim(ctx interface{}, providerAddr interface{}, claimId interface{}, tsk interface{}) *FullNode_StateGetClaim_Call {
	return &FullNode_StateGetClaim_Call{Call: _e.mock.On("StateGetClaim", ctx, providerAddr, claimId, tsk)}
}

func (_c *FullNode_StateGetClaim_Call) Run(run func(ctx context.Context, providerAddr address.Address, claimId verifreg.ClaimId, tsk types.TipSetKey)) *FullNode_StateGetClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(verifreg.ClaimId), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetClaim_Call) Return(v *verifreg.Claim, err error) *FullNode_StateGetClaim_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateGetClaim_Call) RunAndReturn(run func(ctx context.Context, providerAddr address.Address, claimId verifreg.ClaimId, tsk types.TipSetKey) (*verifreg.Claim, error)) *FullNode_StateGetClaim_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetClaims provides a mock function for the type FullNode
func (_mock *FullNode) StateGetClaims(ctx context.Context, providerAddr address.Address, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error) {
	ret := _mock.Called(ctx, providerAddr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetClaims")
	}

	var r0 map[verifreg.ClaimId]verifreg.Claim
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)); ok {
		return returnFunc(ctx, providerAddr, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) map[verifreg.ClaimId]verifreg.Claim); ok {
		r0 = returnFunc(ctx, providerAddr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.ClaimId]verifreg.Claim)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, providerAddr, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetClaims_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetClaims'
type FullNode_StateGetClaims_Call struct {
	*mock.Call
}

// StateGetClaims is a helper method to define mock.On call
//   - ctx
//   - providerAddr
//   - tsk
func (_e *FullNode_Expecter) StateGetClaims(ctx interface{}, providerAddr interface{}, tsk interface{}) *FullNode_StateGetClaims_Call {
	return &FullNode_StateGetClaims_Call{Call: _e.mock.On("StateGetClaims", ctx, providerAddr, tsk)}
}

func (_c *FullNode_StateGetClaims_Call) Run(run func(ctx context.Context, providerAddr address.Address, tsk types.TipSetKey)) *FullNode_StateGetClaims_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetClaims_Call) Return(vToV map[verifreg.ClaimId]verifreg.Claim, err error) *FullNode_StateGetClaims_Call {
	_c.Call.Return(vToV, err)
	return _c
}

func (_c *FullNode_StateGetClaims_Call) RunAndReturn(run func(ctx context.Context, providerAddr address.Address, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)) *FullNode_StateGetClaims_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetNetworkParams provides a mock function for the type FullNode
func (_mock *FullNode) StateGetNetworkParams(ctx context.Context) (*api.NetworkParams, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for StateGetNetworkParams")
	}

	var r0 *api.NetworkParams
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*api.NetworkParams, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *api.NetworkParams); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.NetworkParams)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetNetworkParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetNetworkParams'
type FullNode_StateGetNetworkParams_Call struct {
	*mock.Call
}

// StateGetNetworkParams is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) StateGetNetworkParams(ctx interface{}) *FullNode_StateGetNetworkParams_Call {
	return &FullNode_StateGetNetworkParams_Call{Call: _e.mock.On("StateGetNetworkParams", ctx)}
}

func (_c *FullNode_StateGetNetworkParams_Call) Run(run func(ctx context.Context)) *FullNode_StateGetNetworkParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_StateGetNetworkParams_Call) Return(networkParams *api.NetworkParams, err error) *FullNode_StateGetNetworkParams_Call {
	_c.Call.Return(networkParams, err)
	return _c
}

func (_c *FullNode_StateGetNetworkParams_Call) RunAndReturn(run func(ctx context.Context) (*api.NetworkParams, error)) *FullNode_StateGetNetworkParams_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetRandomnessDigestFromBeacon provides a mock function for the type FullNode
func (_mock *FullNode) StateGetRandomnessDigestFromBeacon(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _mock.Called(ctx, randEpoch, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessDigestFromBeacon")
	}

	var r0 abi.Randomness
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (abi.Randomness, error)); ok {
		return returnFunc(ctx, randEpoch, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) abi.Randomness); ok {
		r0 = returnFunc(ctx, randEpoch, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, randEpoch, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetRandomnessDigestFromBeacon_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetRandomnessDigestFromBeacon'
type FullNode_StateGetRandomnessDigestFromBeacon_Call struct {
	*mock.Call
}

// StateGetRandomnessDigestFromBeacon is a helper method to define mock.On call
//   - ctx
//   - randEpoch
//   - tsk
func (_e *FullNode_Expecter) StateGetRandomnessDigestFromBeacon(ctx interface{}, randEpoch interface{}, tsk interface{}) *FullNode_StateGetRandomnessDigestFromBeacon_Call {
	return &FullNode_StateGetRandomnessDigestFromBeacon_Call{Call: _e.mock.On("StateGetRandomnessDigestFromBeacon", ctx, randEpoch, tsk)}
}

func (_c *FullNode_StateGetRandomnessDigestFromBeacon_Call) Run(run func(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey)) *FullNode_StateGetRandomnessDigestFromBeacon_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetRandomnessDigestFromBeacon_Call) Return(randomness abi.Randomness, err error) *FullNode_StateGetRandomnessDigestFromBeacon_Call {
	_c.Call.Return(randomness, err)
	return _c
}

func (_c *FullNode_StateGetRandomnessDigestFromBeacon_Call) RunAndReturn(run func(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error)) *FullNode_StateGetRandomnessDigestFromBeacon_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetRandomnessDigestFromTickets provides a mock function for the type FullNode
func (_mock *FullNode) StateGetRandomnessDigestFromTickets(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _mock.Called(ctx, randEpoch, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessDigestFromTickets")
	}

	var r0 abi.Randomness
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (abi.Randomness, error)); ok {
		return returnFunc(ctx, randEpoch, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) abi.Randomness); ok {
		r0 = returnFunc(ctx, randEpoch, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, randEpoch, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetRandomnessDigestFromTickets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetRandomnessDigestFromTickets'
type FullNode_StateGetRandomnessDigestFromTickets_Call struct {
	*mock.Call
}

// StateGetRandomnessDigestFromTickets is a helper method to define mock.On call
//   - ctx
//   - randEpoch
//   - tsk
func (_e *FullNode_Expecter) StateGetRandomnessDigestFromTickets(ctx interface{}, randEpoch interface{}, tsk interface{}) *FullNode_StateGetRandomnessDigestFromTickets_Call {
	return &FullNode_StateGetRandomnessDigestFromTickets_Call{Call: _e.mock.On("StateGetRandomnessDigestFromTickets", ctx, randEpoch, tsk)}
}

func (_c *FullNode_StateGetRandomnessDigestFromTickets_Call) Run(run func(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey)) *FullNode_StateGetRandomnessDigestFromTickets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetRandomnessDigestFromTickets_Call) Return(randomness abi.Randomness, err error) *FullNode_StateGetRandomnessDigestFromTickets_Call {
	_c.Call.Return(randomness, err)
	return _c
}

func (_c *FullNode_StateGetRandomnessDigestFromTickets_Call) RunAndReturn(run func(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error)) *FullNode_StateGetRandomnessDigestFromTickets_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetRandomnessFromBeacon provides a mock function for the type FullNode
func (_mock *FullNode) StateGetRandomnessFromBeacon(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _mock.Called(ctx, personalization, randEpoch, entropy, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessFromBeacon")
	}

	var r0 abi.Randomness
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) (abi.Randomness, error)); ok {
		return returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) abi.Randomness); ok {
		r0 = returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetRandomnessFromBeacon_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetRandomnessFromBeacon'
type FullNode_StateGetRandomnessFromBeacon_Call struct {
	*mock.Call
}

// StateGetRandomnessFromBeacon is a helper method to define mock.On call
//   - ctx
//   - personalization
//   - randEpoch
//   - entropy
//   - tsk
func (_e *FullNode_Expecter) StateGetRandomnessFromBeacon(ctx interface{}, personalization interface{}, randEpoch interface{}, entropy interface{}, tsk interface{}) *FullNode_StateGetRandomnessFromBeacon_Call {
	return &FullNode_StateGetRandomnessFromBeacon_Call{Call: _e.mock.On("StateGetRandomnessFromBeacon", ctx, personalization, randEpoch, entropy, tsk)}
}

func (_c *FullNode_StateGetRandomnessFromBeacon_Call) Run(run func(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey)) *FullNode_StateGetRandomnessFromBeacon_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(crypto.DomainSeparationTag), args[2].(abi.ChainEpoch), args[3].([]byte), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetRandomnessFromBeacon_Call) Return(randomness abi.Randomness, err error) *FullNode_StateGetRandomnessFromBeacon_Call {
	_c.Call.Return(randomness, err)
	return _c
}

func (_c *FullNode_StateGetRandomnessFromBeacon_Call) RunAndReturn(run func(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error)) *FullNode_StateGetRandomnessFromBeacon_Call {
	_c.Call.Return(run)
	return _c
}

// StateGetRandomnessFromTickets provides a mock function for the type FullNode
func (_mock *FullNode) StateGetRandomnessFromTickets(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _mock.Called(ctx, personalization, randEpoch, entropy, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessFromTickets")
	}

	var r0 abi.Randomness
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) (abi.Randomness, error)); ok {
		return returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) abi.Randomness); ok {
		r0 = returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateGetRandomnessFromTickets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateGetRandomnessFromTickets'
type FullNode_StateGetRandomnessFromTickets_Call struct {
	*mock.Call
}

// StateGetRandomnessFromTickets is a helper method to define mock.On call
//   - ctx
//   - personalization
//   - randEpoch
//   - entropy
//   - tsk
func (_e *FullNode_Expecter) StateGetRandomnessFromTickets(ctx interface{}, personalization interface{}, randEpoch interface{}, entropy interface{}, tsk interface{}) *FullNode_StateGetRandomnessFromTickets_Call {
	return &FullNode_StateGetRandomnessFromTickets_Call{Call: _e.mock.On("StateGetRandomnessFromTickets", ctx, personalization, randEpoch, entropy, tsk)}
}

func (_c *FullNode_StateGetRandomnessFromTickets_Call) Run(run func(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey)) *FullNode_StateGetRandomnessFromTickets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(crypto.DomainSeparationTag), args[2].(abi.ChainEpoch), args[3].([]byte), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateGetRandomnessFromTickets_Call) Return(randomness abi.Randomness, err error) *FullNode_StateGetRandomnessFromTickets_Call {
	_c.Call.Return(randomness, err)
	return _c
}

func (_c *FullNode_StateGetRandomnessFromTickets_Call) RunAndReturn(run func(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error)) *FullNode_StateGetRandomnessFromTickets_Call {
	_c.Call.Return(run)
	return _c
}

// StateListActors provides a mock function for the type FullNode
func (_mock *FullNode) StateListActors(context1 context.Context, tipSetKey types.TipSetKey) ([]address.Address, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateListActors")
	}

	var r0 []address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]address.Address, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateListActors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateListActors'
type FullNode_StateListActors_Call struct {
	*mock.Call
}

// StateListActors is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateListActors(context1 interface{}, tipSetKey interface{}) *FullNode_StateListActors_Call {
	return &FullNode_StateListActors_Call{Call: _e.mock.On("StateListActors", context1, tipSetKey)}
}

func (_c *FullNode_StateListActors_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateListActors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateListActors_Call) Return(addresss []address.Address, err error) *FullNode_StateListActors_Call {
	_c.Call.Return(addresss, err)
	return _c
}

func (_c *FullNode_StateListActors_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) ([]address.Address, error)) *FullNode_StateListActors_Call {
	_c.Call.Return(run)
	return _c
}

// StateListMessages provides a mock function for the type FullNode
func (_mock *FullNode) StateListMessages(ctx context.Context, match *api.MessageMatch, tsk types.TipSetKey, toht abi.ChainEpoch) ([]cid.Cid, error) {
	ret := _mock.Called(ctx, match, tsk, toht)

	if len(ret) == 0 {
		panic("no return value specified for StateListMessages")
	}

	var r0 []cid.Cid
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) ([]cid.Cid, error)); ok {
		return returnFunc(ctx, match, tsk, toht)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) []cid.Cid); ok {
		r0 = returnFunc(ctx, match, tsk, toht)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) error); ok {
		r1 = returnFunc(ctx, match, tsk, toht)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateListMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateListMessages'
type FullNode_StateListMessages_Call struct {
	*mock.Call
}

// StateListMessages is a helper method to define mock.On call
//   - ctx
//   - match
//   - tsk
//   - toht
func (_e *FullNode_Expecter) StateListMessages(ctx interface{}, match interface{}, tsk interface{}, toht interface{}) *FullNode_StateListMessages_Call {
	return &FullNode_StateListMessages_Call{Call: _e.mock.On("StateListMessages", ctx, match, tsk, toht)}
}

func (_c *FullNode_StateListMessages_Call) Run(run func(ctx context.Context, match *api.MessageMatch, tsk types.TipSetKey, toht abi.ChainEpoch)) *FullNode_StateListMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api.MessageMatch), args[2].(types.TipSetKey), args[3].(abi.ChainEpoch))
	})
	return _c
}

func (_c *FullNode_StateListMessages_Call) Return(cids []cid.Cid, err error) *FullNode_StateListMessages_Call {
	_c.Call.Return(cids, err)
	return _c
}

func (_c *FullNode_StateListMessages_Call) RunAndReturn(run func(ctx context.Context, match *api.MessageMatch, tsk types.TipSetKey, toht abi.ChainEpoch) ([]cid.Cid, error)) *FullNode_StateListMessages_Call {
	_c.Call.Return(run)
	return _c
}

// StateListMiners provides a mock function for the type FullNode
func (_mock *FullNode) StateListMiners(context1 context.Context, tipSetKey types.TipSetKey) ([]address.Address, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateListMiners")
	}

	var r0 []address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]address.Address, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateListMiners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateListMiners'
type FullNode_StateListMiners_Call struct {
	*mock.Call
}

// StateListMiners is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateListMiners(context1 interface{}, tipSetKey interface{}) *FullNode_StateListMiners_Call {
	return &FullNode_StateListMiners_Call{Call: _e.mock.On("StateListMiners", context1, tipSetKey)}
}

func (_c *FullNode_StateListMiners_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateListMiners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateListMiners_Call) Return(addresss []address.Address, err error) *FullNode_StateListMiners_Call {
	_c.Call.Return(addresss, err)
	return _c
}

func (_c *FullNode_StateListMiners_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) ([]address.Address, error)) *FullNode_StateListMiners_Call {
	_c.Call.Return(run)
	return _c
}

// StateLookupID provides a mock function for the type FullNode
func (_mock *FullNode) StateLookupID(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateLookupID")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateLookupID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateLookupID'
type FullNode_StateLookupID_Call struct {
	*mock.Call
}

// StateLookupID is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateLookupID(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateLookupID_Call {
	return &FullNode_StateLookupID_Call{Call: _e.mock.On("StateLookupID", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateLookupID_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateLookupID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateLookupID_Call) Return(address11 address.Address, err error) *FullNode_StateLookupID_Call {
	_c.Call.Return(address11, err)
	return _c
}

func (_c *FullNode_StateLookupID_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error)) *FullNode_StateLookupID_Call {
	_c.Call.Return(run)
	return _c
}

// StateLookupRobustAddress provides a mock function for the type FullNode
func (_mock *FullNode) StateLookupRobustAddress(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateLookupRobustAddress")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateLookupRobustAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateLookupRobustAddress'
type FullNode_StateLookupRobustAddress_Call struct {
	*mock.Call
}

// StateLookupRobustAddress is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateLookupRobustAddress(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateLookupRobustAddress_Call {
	return &FullNode_StateLookupRobustAddress_Call{Call: _e.mock.On("StateLookupRobustAddress", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateLookupRobustAddress_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateLookupRobustAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateLookupRobustAddress_Call) Return(address11 address.Address, err error) *FullNode_StateLookupRobustAddress_Call {
	_c.Call.Return(address11, err)
	return _c
}

func (_c *FullNode_StateLookupRobustAddress_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (address.Address, error)) *FullNode_StateLookupRobustAddress_Call {
	_c.Call.Return(run)
	return _c
}

// StateMarketBalance provides a mock function for the type FullNode
func (_mock *FullNode) StateMarketBalance(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MarketBalance, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketBalance")
	}

	var r0 api.MarketBalance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MarketBalance, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MarketBalance); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.MarketBalance)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMarketBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMarketBalance'
type FullNode_StateMarketBalance_Call struct {
	*mock.Call
}

// StateMarketBalance is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMarketBalance(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMarketBalance_Call {
	return &FullNode_StateMarketBalance_Call{Call: _e.mock.On("StateMarketBalance", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMarketBalance_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMarketBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMarketBalance_Call) Return(marketBalance api.MarketBalance, err error) *FullNode_StateMarketBalance_Call {
	_c.Call.Return(marketBalance, err)
	return _c
}

func (_c *FullNode_StateMarketBalance_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MarketBalance, error)) *FullNode_StateMarketBalance_Call {
	_c.Call.Return(run)
	return _c
}

// StateMarketDeals provides a mock function for the type FullNode
func (_mock *FullNode) StateMarketDeals(context1 context.Context, tipSetKey types.TipSetKey) (map[string]*api.MarketDeal, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketDeals")
	}

	var r0 map[string]*api.MarketDeal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[string]*api.MarketDeal, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]*api.MarketDeal); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*api.MarketDeal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMarketDeals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMarketDeals'
type FullNode_StateMarketDeals_Call struct {
	*mock.Call
}

// StateMarketDeals is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMarketDeals(context1 interface{}, tipSetKey interface{}) *FullNode_StateMarketDeals_Call {
	return &FullNode_StateMarketDeals_Call{Call: _e.mock.On("StateMarketDeals", context1, tipSetKey)}
}

func (_c *FullNode_StateMarketDeals_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateMarketDeals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMarketDeals_Call) Return(stringToMarketDeal map[string]*api.MarketDeal, err error) *FullNode_StateMarketDeals_Call {
	_c.Call.Return(stringToMarketDeal, err)
	return _c
}

func (_c *FullNode_StateMarketDeals_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (map[string]*api.MarketDeal, error)) *FullNode_StateMarketDeals_Call {
	_c.Call.Return(run)
	return _c
}

// StateMarketParticipants provides a mock function for the type FullNode
func (_mock *FullNode) StateMarketParticipants(context1 context.Context, tipSetKey types.TipSetKey) (map[string]api.MarketBalance, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketParticipants")
	}

	var r0 map[string]api.MarketBalance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[string]api.MarketBalance, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]api.MarketBalance); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]api.MarketBalance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMarketParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMarketParticipants'
type FullNode_StateMarketParticipants_Call struct {
	*mock.Call
}

// StateMarketParticipants is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMarketParticipants(context1 interface{}, tipSetKey interface{}) *FullNode_StateMarketParticipants_Call {
	return &FullNode_StateMarketParticipants_Call{Call: _e.mock.On("StateMarketParticipants", context1, tipSetKey)}
}

func (_c *FullNode_StateMarketParticipants_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateMarketParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMarketParticipants_Call) Return(stringToMarketBalance map[string]api.MarketBalance, err error) *FullNode_StateMarketParticipants_Call {
	_c.Call.Return(stringToMarketBalance, err)
	return _c
}

func (_c *FullNode_StateMarketParticipants_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (map[string]api.MarketBalance, error)) *FullNode_StateMarketParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// StateMarketProposalPending provides a mock function for the type FullNode
func (_mock *FullNode) StateMarketProposalPending(ctx context.Context, proposalCid cid.Cid, tsk types.TipSetKey) (bool, error) {
	ret := _mock.Called(ctx, proposalCid, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketProposalPending")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, types.TipSetKey) (bool, error)); ok {
		return returnFunc(ctx, proposalCid, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, types.TipSetKey) bool); ok {
		r0 = returnFunc(ctx, proposalCid, tsk)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, proposalCid, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMarketProposalPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMarketProposalPending'
type FullNode_StateMarketProposalPending_Call struct {
	*mock.Call
}

// StateMarketProposalPending is a helper method to define mock.On call
//   - ctx
//   - proposalCid
//   - tsk
func (_e *FullNode_Expecter) StateMarketProposalPending(ctx interface{}, proposalCid interface{}, tsk interface{}) *FullNode_StateMarketProposalPending_Call {
	return &FullNode_StateMarketProposalPending_Call{Call: _e.mock.On("StateMarketProposalPending", ctx, proposalCid, tsk)}
}

func (_c *FullNode_StateMarketProposalPending_Call) Run(run func(ctx context.Context, proposalCid cid.Cid, tsk types.TipSetKey)) *FullNode_StateMarketProposalPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMarketProposalPending_Call) Return(b bool, err error) *FullNode_StateMarketProposalPending_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_StateMarketProposalPending_Call) RunAndReturn(run func(ctx context.Context, proposalCid cid.Cid, tsk types.TipSetKey) (bool, error)) *FullNode_StateMarketProposalPending_Call {
	_c.Call.Return(run)
	return _c
}

// StateMarketStorageDeal provides a mock function for the type FullNode
func (_mock *FullNode) StateMarketStorageDeal(context1 context.Context, dealID abi.DealID, tipSetKey types.TipSetKey) (*api.MarketDeal, error) {
	ret := _mock.Called(context1, dealID, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketStorageDeal")
	}

	var r0 *api.MarketDeal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (*api.MarketDeal, error)); ok {
		return returnFunc(context1, dealID, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) *api.MarketDeal); ok {
		r0 = returnFunc(context1, dealID, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MarketDeal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, dealID, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMarketStorageDeal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMarketStorageDeal'
type FullNode_StateMarketStorageDeal_Call struct {
	*mock.Call
}

// StateMarketStorageDeal is a helper method to define mock.On call
//   - context1
//   - dealID
//   - tipSetKey
func (_e *FullNode_Expecter) StateMarketStorageDeal(context1 interface{}, dealID interface{}, tipSetKey interface{}) *FullNode_StateMarketStorageDeal_Call {
	return &FullNode_StateMarketStorageDeal_Call{Call: _e.mock.On("StateMarketStorageDeal", context1, dealID, tipSetKey)}
}

func (_c *FullNode_StateMarketStorageDeal_Call) Run(run func(context1 context.Context, dealID abi.DealID, tipSetKey types.TipSetKey)) *FullNode_StateMarketStorageDeal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.DealID), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMarketStorageDeal_Call) Return(marketDeal *api.MarketDeal, err error) *FullNode_StateMarketStorageDeal_Call {
	_c.Call.Return(marketDeal, err)
	return _c
}

func (_c *FullNode_StateMarketStorageDeal_Call) RunAndReturn(run func(context1 context.Context, dealID abi.DealID, tipSetKey types.TipSetKey) (*api.MarketDeal, error)) *FullNode_StateMarketStorageDeal_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerActiveSectors provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerActiveSectors(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerActiveSectors")
	}

	var r0 []*miner.SectorOnChainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]*miner.SectorOnChainInfo, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []*miner.SectorOnChainInfo); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*miner.SectorOnChainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerActiveSectors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerActiveSectors'
type FullNode_StateMinerActiveSectors_Call struct {
	*mock.Call
}

// StateMinerActiveSectors is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerActiveSectors(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerActiveSectors_Call {
	return &FullNode_StateMinerActiveSectors_Call{Call: _e.mock.On("StateMinerActiveSectors", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerActiveSectors_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerActiveSectors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerActiveSectors_Call) Return(vs []*miner.SectorOnChainInfo, err error) *FullNode_StateMinerActiveSectors_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *FullNode_StateMinerActiveSectors_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]*miner.SectorOnChainInfo, error)) *FullNode_StateMinerActiveSectors_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerAllocated provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerAllocated(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*bitfield.BitField, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerAllocated")
	}

	var r0 *bitfield.BitField
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*bitfield.BitField, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *bitfield.BitField); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bitfield.BitField)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerAllocated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerAllocated'
type FullNode_StateMinerAllocated_Call struct {
	*mock.Call
}

// StateMinerAllocated is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerAllocated(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerAllocated_Call {
	return &FullNode_StateMinerAllocated_Call{Call: _e.mock.On("StateMinerAllocated", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerAllocated_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerAllocated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerAllocated_Call) Return(bitField *bitfield.BitField, err error) *FullNode_StateMinerAllocated_Call {
	_c.Call.Return(bitField, err)
	return _c
}

func (_c *FullNode_StateMinerAllocated_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*bitfield.BitField, error)) *FullNode_StateMinerAllocated_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerAvailableBalance provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerAvailableBalance(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerAvailableBalance")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerAvailableBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerAvailableBalance'
type FullNode_StateMinerAvailableBalance_Call struct {
	*mock.Call
}

// StateMinerAvailableBalance is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerAvailableBalance(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerAvailableBalance_Call {
	return &FullNode_StateMinerAvailableBalance_Call{Call: _e.mock.On("StateMinerAvailableBalance", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerAvailableBalance_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerAvailableBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerAvailableBalance_Call) Return(v types.BigInt, err error) *FullNode_StateMinerAvailableBalance_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateMinerAvailableBalance_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_StateMinerAvailableBalance_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerDeadlines provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerDeadlines(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]api.Deadline, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerDeadlines")
	}

	var r0 []api.Deadline
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]api.Deadline, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []api.Deadline); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Deadline)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerDeadlines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerDeadlines'
type FullNode_StateMinerDeadlines_Call struct {
	*mock.Call
}

// StateMinerDeadlines is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerDeadlines(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerDeadlines_Call {
	return &FullNode_StateMinerDeadlines_Call{Call: _e.mock.On("StateMinerDeadlines", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerDeadlines_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerDeadlines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerDeadlines_Call) Return(deadlines []api.Deadline, err error) *FullNode_StateMinerDeadlines_Call {
	_c.Call.Return(deadlines, err)
	return _c
}

func (_c *FullNode_StateMinerDeadlines_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) ([]api.Deadline, error)) *FullNode_StateMinerDeadlines_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerFaults provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerFaults(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (bitfield.BitField, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerFaults")
	}

	var r0 bitfield.BitField
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (bitfield.BitField, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) bitfield.BitField); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(bitfield.BitField)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerFaults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerFaults'
type FullNode_StateMinerFaults_Call struct {
	*mock.Call
}

// StateMinerFaults is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerFaults(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerFaults_Call {
	return &FullNode_StateMinerFaults_Call{Call: _e.mock.On("StateMinerFaults", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerFaults_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerFaults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerFaults_Call) Return(bitField bitfield.BitField, err error) *FullNode_StateMinerFaults_Call {
	_c.Call.Return(bitField, err)
	return _c
}

func (_c *FullNode_StateMinerFaults_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (bitfield.BitField, error)) *FullNode_StateMinerFaults_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerInfo provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerInfo(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MinerInfo, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInfo")
	}

	var r0 api.MinerInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MinerInfo, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerInfo); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.MinerInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerInfo'
type FullNode_StateMinerInfo_Call struct {
	*mock.Call
}

// StateMinerInfo is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerInfo(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerInfo_Call {
	return &FullNode_StateMinerInfo_Call{Call: _e.mock.On("StateMinerInfo", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerInfo_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerInfo_Call) Return(minerInfo api.MinerInfo, err error) *FullNode_StateMinerInfo_Call {
	_c.Call.Return(minerInfo, err)
	return _c
}

func (_c *FullNode_StateMinerInfo_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MinerInfo, error)) *FullNode_StateMinerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerInitialPledgeCollateral provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerInitialPledgeCollateral(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, v, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInitialPledgeCollateral")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, v, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, address1, v, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, v, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerInitialPledgeCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerInitialPledgeCollateral'
type FullNode_StateMinerInitialPledgeCollateral_Call struct {
	*mock.Call
}

// StateMinerInitialPledgeCollateral is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerInitialPledgeCollateral(context1 interface{}, address1 interface{}, v interface{}, tipSetKey interface{}) *FullNode_StateMinerInitialPledgeCollateral_Call {
	return &FullNode_StateMinerInitialPledgeCollateral_Call{Call: _e.mock.On("StateMinerInitialPledgeCollateral", context1, address1, v, tipSetKey)}
}

func (_c *FullNode_StateMinerInitialPledgeCollateral_Call) Run(run func(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey)) *FullNode_StateMinerInitialPledgeCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(miner.SectorPreCommitInfo), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerInitialPledgeCollateral_Call) Return(v1 types.BigInt, err error) *FullNode_StateMinerInitialPledgeCollateral_Call {
	_c.Call.Return(v1, err)
	return _c
}

func (_c *FullNode_StateMinerInitialPledgeCollateral_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_StateMinerInitialPledgeCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerInitialPledgeForSector provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerInitialPledgeForSector(ctx context.Context, sectorDuration abi.ChainEpoch, sectorSize abi.SectorSize, verifiedSize uint64, tsk types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(ctx, sectorDuration, sectorSize, verifiedSize, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInitialPledgeForSector")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerInitialPledgeForSector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerInitialPledgeForSector'
type FullNode_StateMinerInitialPledgeForSector_Call struct {
	*mock.Call
}

// StateMinerInitialPledgeForSector is a helper method to define mock.On call
//   - ctx
//   - sectorDuration
//   - sectorSize
//   - verifiedSize
//   - tsk
func (_e *FullNode_Expecter) StateMinerInitialPledgeForSector(ctx interface{}, sectorDuration interface{}, sectorSize interface{}, verifiedSize interface{}, tsk interface{}) *FullNode_StateMinerInitialPledgeForSector_Call {
	return &FullNode_StateMinerInitialPledgeForSector_Call{Call: _e.mock.On("StateMinerInitialPledgeForSector", ctx, sectorDuration, sectorSize, verifiedSize, tsk)}
}

func (_c *FullNode_StateMinerInitialPledgeForSector_Call) Run(run func(ctx context.Context, sectorDuration abi.ChainEpoch, sectorSize abi.SectorSize, verifiedSize uint64, tsk types.TipSetKey)) *FullNode_StateMinerInitialPledgeForSector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abi.ChainEpoch), args[2].(abi.SectorSize), args[3].(uint64), args[4].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerInitialPledgeForSector_Call) Return(v types.BigInt, err error) *FullNode_StateMinerInitialPledgeForSector_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateMinerInitialPledgeForSector_Call) RunAndReturn(run func(ctx context.Context, sectorDuration abi.ChainEpoch, sectorSize abi.SectorSize, verifiedSize uint64, tsk types.TipSetKey) (types.BigInt, error)) *FullNode_StateMinerInitialPledgeForSector_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerPartitions provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerPartitions(ctx context.Context, m address.Address, dlIdx uint64, tsk types.TipSetKey) ([]api.Partition, error) {
	ret := _mock.Called(ctx, m, dlIdx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPartitions")
	}

	var r0 []api.Partition
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, types.TipSetKey) ([]api.Partition, error)); ok {
		return returnFunc(ctx, m, dlIdx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, uint64, types.TipSetKey) []api.Partition); ok {
		r0 = returnFunc(ctx, m, dlIdx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Partition)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, uint64, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, m, dlIdx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerPartitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerPartitions'
type FullNode_StateMinerPartitions_Call struct {
	*mock.Call
}

// StateMinerPartitions is a helper method to define mock.On call
//   - ctx
//   - m
//   - dlIdx
//   - tsk
func (_e *FullNode_Expecter) StateMinerPartitions(ctx interface{}, m interface{}, dlIdx interface{}, tsk interface{}) *FullNode_StateMinerPartitions_Call {
	return &FullNode_StateMinerPartitions_Call{Call: _e.mock.On("StateMinerPartitions", ctx, m, dlIdx, tsk)}
}

func (_c *FullNode_StateMinerPartitions_Call) Run(run func(ctx context.Context, m address.Address, dlIdx uint64, tsk types.TipSetKey)) *FullNode_StateMinerPartitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(uint64), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerPartitions_Call) Return(partitions []api.Partition, err error) *FullNode_StateMinerPartitions_Call {
	_c.Call.Return(partitions, err)
	return _c
}

func (_c *FullNode_StateMinerPartitions_Call) RunAndReturn(run func(ctx context.Context, m address.Address, dlIdx uint64, tsk types.TipSetKey) ([]api.Partition, error)) *FullNode_StateMinerPartitions_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerPower provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerPower(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*api.MinerPower, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPower")
	}

	var r0 *api.MinerPower
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*api.MinerPower, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *api.MinerPower); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MinerPower)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerPower_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerPower'
type FullNode_StateMinerPower_Call struct {
	*mock.Call
}

// StateMinerPower is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerPower(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerPower_Call {
	return &FullNode_StateMinerPower_Call{Call: _e.mock.On("StateMinerPower", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerPower_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerPower_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerPower_Call) Return(minerPower *api.MinerPower, err error) *FullNode_StateMinerPower_Call {
	_c.Call.Return(minerPower, err)
	return _c
}

func (_c *FullNode_StateMinerPower_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*api.MinerPower, error)) *FullNode_StateMinerPower_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerPreCommitDepositForPower provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerPreCommitDepositForPower(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey) (types.BigInt, error) {
	ret := _mock.Called(context1, address1, v, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPreCommitDepositForPower")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) (types.BigInt, error)); ok {
		return returnFunc(context1, address1, v, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) types.BigInt); ok {
		r0 = returnFunc(context1, address1, v, tipSetKey)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, miner.SectorPreCommitInfo, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, v, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerPreCommitDepositForPower_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerPreCommitDepositForPower'
type FullNode_StateMinerPreCommitDepositForPower_Call struct {
	*mock.Call
}

// StateMinerPreCommitDepositForPower is a helper method to define mock.On call
//   - context1
//   - address1
//   - v
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerPreCommitDepositForPower(context1 interface{}, address1 interface{}, v interface{}, tipSetKey interface{}) *FullNode_StateMinerPreCommitDepositForPower_Call {
	return &FullNode_StateMinerPreCommitDepositForPower_Call{Call: _e.mock.On("StateMinerPreCommitDepositForPower", context1, address1, v, tipSetKey)}
}

func (_c *FullNode_StateMinerPreCommitDepositForPower_Call) Run(run func(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey)) *FullNode_StateMinerPreCommitDepositForPower_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(miner.SectorPreCommitInfo), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerPreCommitDepositForPower_Call) Return(v1 types.BigInt, err error) *FullNode_StateMinerPreCommitDepositForPower_Call {
	_c.Call.Return(v1, err)
	return _c
}

func (_c *FullNode_StateMinerPreCommitDepositForPower_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, v miner.SectorPreCommitInfo, tipSetKey types.TipSetKey) (types.BigInt, error)) *FullNode_StateMinerPreCommitDepositForPower_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerProvingDeadline provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerProvingDeadline(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*dline.Info, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerProvingDeadline")
	}

	var r0 *dline.Info
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*dline.Info, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *dline.Info); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dline.Info)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerProvingDeadline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerProvingDeadline'
type FullNode_StateMinerProvingDeadline_Call struct {
	*mock.Call
}

// StateMinerProvingDeadline is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerProvingDeadline(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerProvingDeadline_Call {
	return &FullNode_StateMinerProvingDeadline_Call{Call: _e.mock.On("StateMinerProvingDeadline", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerProvingDeadline_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerProvingDeadline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerProvingDeadline_Call) Return(info *dline.Info, err error) *FullNode_StateMinerProvingDeadline_Call {
	_c.Call.Return(info, err)
	return _c
}

func (_c *FullNode_StateMinerProvingDeadline_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (*dline.Info, error)) *FullNode_StateMinerProvingDeadline_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerRecoveries provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerRecoveries(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (bitfield.BitField, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerRecoveries")
	}

	var r0 bitfield.BitField
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (bitfield.BitField, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) bitfield.BitField); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(bitfield.BitField)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerRecoveries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerRecoveries'
type FullNode_StateMinerRecoveries_Call struct {
	*mock.Call
}

// StateMinerRecoveries is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerRecoveries(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerRecoveries_Call {
	return &FullNode_StateMinerRecoveries_Call{Call: _e.mock.On("StateMinerRecoveries", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerRecoveries_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerRecoveries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerRecoveries_Call) Return(bitField bitfield.BitField, err error) *FullNode_StateMinerRecoveries_Call {
	_c.Call.Return(bitField, err)
	return _c
}

func (_c *FullNode_StateMinerRecoveries_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (bitfield.BitField, error)) *FullNode_StateMinerRecoveries_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerSectorAllocated provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerSectorAllocated(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (bool, error) {
	ret := _mock.Called(context1, address1, sectorNumber, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectorAllocated")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (bool, error)); ok {
		return returnFunc(context1, address1, sectorNumber, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) bool); ok {
		r0 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerSectorAllocated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerSectorAllocated'
type FullNode_StateMinerSectorAllocated_Call struct {
	*mock.Call
}

// StateMinerSectorAllocated is a helper method to define mock.On call
//   - context1
//   - address1
//   - sectorNumber
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerSectorAllocated(context1 interface{}, address1 interface{}, sectorNumber interface{}, tipSetKey interface{}) *FullNode_StateMinerSectorAllocated_Call {
	return &FullNode_StateMinerSectorAllocated_Call{Call: _e.mock.On("StateMinerSectorAllocated", context1, address1, sectorNumber, tipSetKey)}
}

func (_c *FullNode_StateMinerSectorAllocated_Call) Run(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey)) *FullNode_StateMinerSectorAllocated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.SectorNumber), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerSectorAllocated_Call) Return(b bool, err error) *FullNode_StateMinerSectorAllocated_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_StateMinerSectorAllocated_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (bool, error)) *FullNode_StateMinerSectorAllocated_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerSectorCount provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerSectorCount(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MinerSectors, error) {
	ret := _mock.Called(context1, address1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectorCount")
	}

	var r0 api.MinerSectors
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MinerSectors, error)); ok {
		return returnFunc(context1, address1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerSectors); ok {
		r0 = returnFunc(context1, address1, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.MinerSectors)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerSectorCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerSectorCount'
type FullNode_StateMinerSectorCount_Call struct {
	*mock.Call
}

// StateMinerSectorCount is a helper method to define mock.On call
//   - context1
//   - address1
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerSectorCount(context1 interface{}, address1 interface{}, tipSetKey interface{}) *FullNode_StateMinerSectorCount_Call {
	return &FullNode_StateMinerSectorCount_Call{Call: _e.mock.On("StateMinerSectorCount", context1, address1, tipSetKey)}
}

func (_c *FullNode_StateMinerSectorCount_Call) Run(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey)) *FullNode_StateMinerSectorCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerSectorCount_Call) Return(minerSectors api.MinerSectors, err error) *FullNode_StateMinerSectorCount_Call {
	_c.Call.Return(minerSectors, err)
	return _c
}

func (_c *FullNode_StateMinerSectorCount_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, tipSetKey types.TipSetKey) (api.MinerSectors, error)) *FullNode_StateMinerSectorCount_Call {
	_c.Call.Return(run)
	return _c
}

// StateMinerSectors provides a mock function for the type FullNode
func (_mock *FullNode) StateMinerSectors(context1 context.Context, address1 address.Address, bitField *bitfield.BitField, tipSetKey types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	ret := _mock.Called(context1, address1, bitField, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectors")
	}

	var r0 []*miner.SectorOnChainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) ([]*miner.SectorOnChainInfo, error)); ok {
		return returnFunc(context1, address1, bitField, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) []*miner.SectorOnChainInfo); ok {
		r0 = returnFunc(context1, address1, bitField, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*miner.SectorOnChainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, bitField, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateMinerSectors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateMinerSectors'
type FullNode_StateMinerSectors_Call struct {
	*mock.Call
}

// StateMinerSectors is a helper method to define mock.On call
//   - context1
//   - address1
//   - bitField
//   - tipSetKey
func (_e *FullNode_Expecter) StateMinerSectors(context1 interface{}, address1 interface{}, bitField interface{}, tipSetKey interface{}) *FullNode_StateMinerSectors_Call {
	return &FullNode_StateMinerSectors_Call{Call: _e.mock.On("StateMinerSectors", context1, address1, bitField, tipSetKey)}
}

func (_c *FullNode_StateMinerSectors_Call) Run(run func(context1 context.Context, address1 address.Address, bitField *bitfield.BitField, tipSetKey types.TipSetKey)) *FullNode_StateMinerSectors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*bitfield.BitField), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateMinerSectors_Call) Return(vs []*miner.SectorOnChainInfo, err error) *FullNode_StateMinerSectors_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *FullNode_StateMinerSectors_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, bitField *bitfield.BitField, tipSetKey types.TipSetKey) ([]*miner.SectorOnChainInfo, error)) *FullNode_StateMinerSectors_Call {
	_c.Call.Return(run)
	return _c
}

// StateNetworkName provides a mock function for the type FullNode
func (_mock *FullNode) StateNetworkName(context1 context.Context) (dtypes.NetworkName, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for StateNetworkName")
	}

	var r0 dtypes.NetworkName
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (dtypes.NetworkName, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) dtypes.NetworkName); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(dtypes.NetworkName)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateNetworkName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateNetworkName'
type FullNode_StateNetworkName_Call struct {
	*mock.Call
}

// StateNetworkName is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) StateNetworkName(context1 interface{}) *FullNode_StateNetworkName_Call {
	return &FullNode_StateNetworkName_Call{Call: _e.mock.On("StateNetworkName", context1)}
}

func (_c *FullNode_StateNetworkName_Call) Run(run func(context1 context.Context)) *FullNode_StateNetworkName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_StateNetworkName_Call) Return(networkName dtypes.NetworkName, err error) *FullNode_StateNetworkName_Call {
	_c.Call.Return(networkName, err)
	return _c
}

func (_c *FullNode_StateNetworkName_Call) RunAndReturn(run func(context1 context.Context) (dtypes.NetworkName, error)) *FullNode_StateNetworkName_Call {
	_c.Call.Return(run)
	return _c
}

// StateNetworkVersion provides a mock function for the type FullNode
func (_mock *FullNode) StateNetworkVersion(context1 context.Context, tipSetKey types.TipSetKey) (apitypes.NetworkVersion, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateNetworkVersion")
	}

	var r0 apitypes.NetworkVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (apitypes.NetworkVersion, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) apitypes.NetworkVersion); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		r0 = ret.Get(0).(apitypes.NetworkVersion)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateNetworkVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateNetworkVersion'
type FullNode_StateNetworkVersion_Call struct {
	*mock.Call
}

// StateNetworkVersion is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateNetworkVersion(context1 interface{}, tipSetKey interface{}) *FullNode_StateNetworkVersion_Call {
	return &FullNode_StateNetworkVersion_Call{Call: _e.mock.On("StateNetworkVersion", context1, tipSetKey)}
}

func (_c *FullNode_StateNetworkVersion_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateNetworkVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateNetworkVersion_Call) Return(v apitypes.NetworkVersion, err error) *FullNode_StateNetworkVersion_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateNetworkVersion_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (apitypes.NetworkVersion, error)) *FullNode_StateNetworkVersion_Call {
	_c.Call.Return(run)
	return _c
}

// StateReadState provides a mock function for the type FullNode
func (_mock *FullNode) StateReadState(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*api.ActorState, error) {
	ret := _mock.Called(ctx, actor, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateReadState")
	}

	var r0 *api.ActorState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*api.ActorState, error)); ok {
		return returnFunc(ctx, actor, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *api.ActorState); ok {
		r0 = returnFunc(ctx, actor, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ActorState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, actor, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateReadState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateReadState'
type FullNode_StateReadState_Call struct {
	*mock.Call
}

// StateReadState is a helper method to define mock.On call
//   - ctx
//   - actor
//   - tsk
func (_e *FullNode_Expecter) StateReadState(ctx interface{}, actor interface{}, tsk interface{}) *FullNode_StateReadState_Call {
	return &FullNode_StateReadState_Call{Call: _e.mock.On("StateReadState", ctx, actor, tsk)}
}

func (_c *FullNode_StateReadState_Call) Run(run func(ctx context.Context, actor address.Address, tsk types.TipSetKey)) *FullNode_StateReadState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateReadState_Call) Return(actorState *api.ActorState, err error) *FullNode_StateReadState_Call {
	_c.Call.Return(actorState, err)
	return _c
}

func (_c *FullNode_StateReadState_Call) RunAndReturn(run func(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*api.ActorState, error)) *FullNode_StateReadState_Call {
	_c.Call.Return(run)
	return _c
}

// StateReplay provides a mock function for the type FullNode
func (_mock *FullNode) StateReplay(context1 context.Context, tipSetKey types.TipSetKey, cid1 cid.Cid) (*api.InvocResult, error) {
	ret := _mock.Called(context1, tipSetKey, cid1)

	if len(ret) == 0 {
		panic("no return value specified for StateReplay")
	}

	var r0 *api.InvocResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid) (*api.InvocResult, error)); ok {
		return returnFunc(context1, tipSetKey, cid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid) *api.InvocResult); ok {
		r0 = returnFunc(context1, tipSetKey, cid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey, cid.Cid) error); ok {
		r1 = returnFunc(context1, tipSetKey, cid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateReplay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateReplay'
type FullNode_StateReplay_Call struct {
	*mock.Call
}

// StateReplay is a helper method to define mock.On call
//   - context1
//   - tipSetKey
//   - cid1
func (_e *FullNode_Expecter) StateReplay(context1 interface{}, tipSetKey interface{}, cid1 interface{}) *FullNode_StateReplay_Call {
	return &FullNode_StateReplay_Call{Call: _e.mock.On("StateReplay", context1, tipSetKey, cid1)}
}

func (_c *FullNode_StateReplay_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey, cid1 cid.Cid)) *FullNode_StateReplay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey), args[2].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_StateReplay_Call) Return(invocResult *api.InvocResult, err error) *FullNode_StateReplay_Call {
	_c.Call.Return(invocResult, err)
	return _c
}

func (_c *FullNode_StateReplay_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey, cid1 cid.Cid) (*api.InvocResult, error)) *FullNode_StateReplay_Call {
	_c.Call.Return(run)
	return _c
}

// StateSearchMsg provides a mock function for the type FullNode
func (_mock *FullNode) StateSearchMsg(ctx context.Context, from types.TipSetKey, msg cid.Cid, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error) {
	ret := _mock.Called(ctx, from, msg, limit, allowReplaced)

	if len(ret) == 0 {
		panic("no return value specified for StateSearchMsg")
	}

	var r0 *api.MsgLookup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) (*api.MsgLookup, error)); ok {
		return returnFunc(ctx, from, msg, limit, allowReplaced)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) *api.MsgLookup); ok {
		r0 = returnFunc(ctx, from, msg, limit, allowReplaced)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) error); ok {
		r1 = returnFunc(ctx, from, msg, limit, allowReplaced)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateSearchMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateSearchMsg'
type FullNode_StateSearchMsg_Call struct {
	*mock.Call
}

// StateSearchMsg is a helper method to define mock.On call
//   - ctx
//   - from
//   - msg
//   - limit
//   - allowReplaced
func (_e *FullNode_Expecter) StateSearchMsg(ctx interface{}, from interface{}, msg interface{}, limit interface{}, allowReplaced interface{}) *FullNode_StateSearchMsg_Call {
	return &FullNode_StateSearchMsg_Call{Call: _e.mock.On("StateSearchMsg", ctx, from, msg, limit, allowReplaced)}
}

func (_c *FullNode_StateSearchMsg_Call) Run(run func(ctx context.Context, from types.TipSetKey, msg cid.Cid, limit abi.ChainEpoch, allowReplaced bool)) *FullNode_StateSearchMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey), args[2].(cid.Cid), args[3].(abi.ChainEpoch), args[4].(bool))
	})
	return _c
}

func (_c *FullNode_StateSearchMsg_Call) Return(msgLookup *api.MsgLookup, err error) *FullNode_StateSearchMsg_Call {
	_c.Call.Return(msgLookup, err)
	return _c
}

func (_c *FullNode_StateSearchMsg_Call) RunAndReturn(run func(ctx context.Context, from types.TipSetKey, msg cid.Cid, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error)) *FullNode_StateSearchMsg_Call {
	_c.Call.Return(run)
	return _c
}

// StateSectorExpiration provides a mock function for the type FullNode
func (_mock *FullNode) StateSectorExpiration(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorExpiration, error) {
	ret := _mock.Called(context1, address1, sectorNumber, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorExpiration")
	}

	var r0 *miner.SectorExpiration
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*miner.SectorExpiration, error)); ok {
		return returnFunc(context1, address1, sectorNumber, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorExpiration); ok {
		r0 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorExpiration)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateSectorExpiration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateSectorExpiration'
type FullNode_StateSectorExpiration_Call struct {
	*mock.Call
}

// StateSectorExpiration is a helper method to define mock.On call
//   - context1
//   - address1
//   - sectorNumber
//   - tipSetKey
func (_e *FullNode_Expecter) StateSectorExpiration(context1 interface{}, address1 interface{}, sectorNumber interface{}, tipSetKey interface{}) *FullNode_StateSectorExpiration_Call {
	return &FullNode_StateSectorExpiration_Call{Call: _e.mock.On("StateSectorExpiration", context1, address1, sectorNumber, tipSetKey)}
}

func (_c *FullNode_StateSectorExpiration_Call) Run(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey)) *FullNode_StateSectorExpiration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.SectorNumber), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateSectorExpiration_Call) Return(sectorExpiration *miner.SectorExpiration, err error) *FullNode_StateSectorExpiration_Call {
	_c.Call.Return(sectorExpiration, err)
	return _c
}

func (_c *FullNode_StateSectorExpiration_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorExpiration, error)) *FullNode_StateSectorExpiration_Call {
	_c.Call.Return(run)
	return _c
}

// StateSectorGetInfo provides a mock function for the type FullNode
func (_mock *FullNode) StateSectorGetInfo(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	ret := _mock.Called(context1, address1, sectorNumber, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorGetInfo")
	}

	var r0 *miner.SectorOnChainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*miner.SectorOnChainInfo, error)); ok {
		return returnFunc(context1, address1, sectorNumber, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorOnChainInfo); ok {
		r0 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorOnChainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateSectorGetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateSectorGetInfo'
type FullNode_StateSectorGetInfo_Call struct {
	*mock.Call
}

// StateSectorGetInfo is a helper method to define mock.On call
//   - context1
//   - address1
//   - sectorNumber
//   - tipSetKey
func (_e *FullNode_Expecter) StateSectorGetInfo(context1 interface{}, address1 interface{}, sectorNumber interface{}, tipSetKey interface{}) *FullNode_StateSectorGetInfo_Call {
	return &FullNode_StateSectorGetInfo_Call{Call: _e.mock.On("StateSectorGetInfo", context1, address1, sectorNumber, tipSetKey)}
}

func (_c *FullNode_StateSectorGetInfo_Call) Run(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey)) *FullNode_StateSectorGetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.SectorNumber), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateSectorGetInfo_Call) Return(v *miner.SectorOnChainInfo, err error) *FullNode_StateSectorGetInfo_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateSectorGetInfo_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorOnChainInfo, error)) *FullNode_StateSectorGetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// StateSectorPartition provides a mock function for the type FullNode
func (_mock *FullNode) StateSectorPartition(ctx context.Context, maddr address.Address, sectorNumber abi.SectorNumber, tok types.TipSetKey) (*miner.SectorLocation, error) {
	ret := _mock.Called(ctx, maddr, sectorNumber, tok)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorPartition")
	}

	var r0 *miner.SectorLocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*miner.SectorLocation, error)); ok {
		return returnFunc(ctx, maddr, sectorNumber, tok)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorLocation); ok {
		r0 = returnFunc(ctx, maddr, sectorNumber, tok)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorLocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, maddr, sectorNumber, tok)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateSectorPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateSectorPartition'
type FullNode_StateSectorPartition_Call struct {
	*mock.Call
}

// StateSectorPartition is a helper method to define mock.On call
//   - ctx
//   - maddr
//   - sectorNumber
//   - tok
func (_e *FullNode_Expecter) StateSectorPartition(ctx interface{}, maddr interface{}, sectorNumber interface{}, tok interface{}) *FullNode_StateSectorPartition_Call {
	return &FullNode_StateSectorPartition_Call{Call: _e.mock.On("StateSectorPartition", ctx, maddr, sectorNumber, tok)}
}

func (_c *FullNode_StateSectorPartition_Call) Run(run func(ctx context.Context, maddr address.Address, sectorNumber abi.SectorNumber, tok types.TipSetKey)) *FullNode_StateSectorPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.SectorNumber), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateSectorPartition_Call) Return(sectorLocation *miner.SectorLocation, err error) *FullNode_StateSectorPartition_Call {
	_c.Call.Return(sectorLocation, err)
	return _c
}

func (_c *FullNode_StateSectorPartition_Call) RunAndReturn(run func(ctx context.Context, maddr address.Address, sectorNumber abi.SectorNumber, tok types.TipSetKey) (*miner.SectorLocation, error)) *FullNode_StateSectorPartition_Call {
	_c.Call.Return(run)
	return _c
}

// StateSectorPreCommitInfo provides a mock function for the type FullNode
func (_mock *FullNode) StateSectorPreCommitInfo(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error) {
	ret := _mock.Called(context1, address1, sectorNumber, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorPreCommitInfo")
	}

	var r0 *miner.SectorPreCommitOnChainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error)); ok {
		return returnFunc(context1, address1, sectorNumber, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorPreCommitOnChainInfo); ok {
		r0 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorPreCommitOnChainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, address1, sectorNumber, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateSectorPreCommitInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateSectorPreCommitInfo'
type FullNode_StateSectorPreCommitInfo_Call struct {
	*mock.Call
}

// StateSectorPreCommitInfo is a helper method to define mock.On call
//   - context1
//   - address1
//   - sectorNumber
//   - tipSetKey
func (_e *FullNode_Expecter) StateSectorPreCommitInfo(context1 interface{}, address1 interface{}, sectorNumber interface{}, tipSetKey interface{}) *FullNode_StateSectorPreCommitInfo_Call {
	return &FullNode_StateSectorPreCommitInfo_Call{Call: _e.mock.On("StateSectorPreCommitInfo", context1, address1, sectorNumber, tipSetKey)}
}

func (_c *FullNode_StateSectorPreCommitInfo_Call) Run(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey)) *FullNode_StateSectorPreCommitInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(abi.SectorNumber), args[3].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateSectorPreCommitInfo_Call) Return(v *miner.SectorPreCommitOnChainInfo, err error) *FullNode_StateSectorPreCommitInfo_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateSectorPreCommitInfo_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, sectorNumber abi.SectorNumber, tipSetKey types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error)) *FullNode_StateSectorPreCommitInfo_Call {
	_c.Call.Return(run)
	return _c
}

// StateVMCirculatingSupplyInternal provides a mock function for the type FullNode
func (_mock *FullNode) StateVMCirculatingSupplyInternal(context1 context.Context, tipSetKey types.TipSetKey) (api.CirculatingSupply, error) {
	ret := _mock.Called(context1, tipSetKey)

	if len(ret) == 0 {
		panic("no return value specified for StateVMCirculatingSupplyInternal")
	}

	var r0 api.CirculatingSupply
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (api.CirculatingSupply, error)); ok {
		return returnFunc(context1, tipSetKey)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) api.CirculatingSupply); ok {
		r0 = returnFunc(context1, tipSetKey)
	} else {
		r0 = ret.Get(0).(api.CirculatingSupply)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(context1, tipSetKey)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateVMCirculatingSupplyInternal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateVMCirculatingSupplyInternal'
type FullNode_StateVMCirculatingSupplyInternal_Call struct {
	*mock.Call
}

// StateVMCirculatingSupplyInternal is a helper method to define mock.On call
//   - context1
//   - tipSetKey
func (_e *FullNode_Expecter) StateVMCirculatingSupplyInternal(context1 interface{}, tipSetKey interface{}) *FullNode_StateVMCirculatingSupplyInternal_Call {
	return &FullNode_StateVMCirculatingSupplyInternal_Call{Call: _e.mock.On("StateVMCirculatingSupplyInternal", context1, tipSetKey)}
}

func (_c *FullNode_StateVMCirculatingSupplyInternal_Call) Run(run func(context1 context.Context, tipSetKey types.TipSetKey)) *FullNode_StateVMCirculatingSupplyInternal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateVMCirculatingSupplyInternal_Call) Return(circulatingSupply api.CirculatingSupply, err error) *FullNode_StateVMCirculatingSupplyInternal_Call {
	_c.Call.Return(circulatingSupply, err)
	return _c
}

func (_c *FullNode_StateVMCirculatingSupplyInternal_Call) RunAndReturn(run func(context1 context.Context, tipSetKey types.TipSetKey) (api.CirculatingSupply, error)) *FullNode_StateVMCirculatingSupplyInternal_Call {
	_c.Call.Return(run)
	return _c
}

// StateVerifiedClientStatus provides a mock function for the type FullNode
func (_mock *FullNode) StateVerifiedClientStatus(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*abi.StoragePower, error) {
	ret := _mock.Called(ctx, addr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifiedClientStatus")
	}

	var r0 *abi.StoragePower
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*abi.StoragePower, error)); ok {
		return returnFunc(ctx, addr, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *abi.StoragePower); ok {
		r0 = returnFunc(ctx, addr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*abi.StoragePower)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, addr, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateVerifiedClientStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateVerifiedClientStatus'
type FullNode_StateVerifiedClientStatus_Call struct {
	*mock.Call
}

// StateVerifiedClientStatus is a helper method to define mock.On call
//   - ctx
//   - addr
//   - tsk
func (_e *FullNode_Expecter) StateVerifiedClientStatus(ctx interface{}, addr interface{}, tsk interface{}) *FullNode_StateVerifiedClientStatus_Call {
	return &FullNode_StateVerifiedClientStatus_Call{Call: _e.mock.On("StateVerifiedClientStatus", ctx, addr, tsk)}
}

func (_c *FullNode_StateVerifiedClientStatus_Call) Run(run func(ctx context.Context, addr address.Address, tsk types.TipSetKey)) *FullNode_StateVerifiedClientStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateVerifiedClientStatus_Call) Return(v *abi.StoragePower, err error) *FullNode_StateVerifiedClientStatus_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateVerifiedClientStatus_Call) RunAndReturn(run func(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*abi.StoragePower, error)) *FullNode_StateVerifiedClientStatus_Call {
	_c.Call.Return(run)
	return _c
}

// StateVerifiedRegistryRootKey provides a mock function for the type FullNode
func (_mock *FullNode) StateVerifiedRegistryRootKey(ctx context.Context, tsk types.TipSetKey) (address.Address, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifiedRegistryRootKey")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (address.Address, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) address.Address); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateVerifiedRegistryRootKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateVerifiedRegistryRootKey'
type FullNode_StateVerifiedRegistryRootKey_Call struct {
	*mock.Call
}

// StateVerifiedRegistryRootKey is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) StateVerifiedRegistryRootKey(ctx interface{}, tsk interface{}) *FullNode_StateVerifiedRegistryRootKey_Call {
	return &FullNode_StateVerifiedRegistryRootKey_Call{Call: _e.mock.On("StateVerifiedRegistryRootKey", ctx, tsk)}
}

func (_c *FullNode_StateVerifiedRegistryRootKey_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_StateVerifiedRegistryRootKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateVerifiedRegistryRootKey_Call) Return(address1 address.Address, err error) *FullNode_StateVerifiedRegistryRootKey_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_StateVerifiedRegistryRootKey_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (address.Address, error)) *FullNode_StateVerifiedRegistryRootKey_Call {
	_c.Call.Return(run)
	return _c
}

// StateVerifierStatus provides a mock function for the type FullNode
func (_mock *FullNode) StateVerifierStatus(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*abi.StoragePower, error) {
	ret := _mock.Called(ctx, addr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifierStatus")
	}

	var r0 *abi.StoragePower
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*abi.StoragePower, error)); ok {
		return returnFunc(ctx, addr, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *abi.StoragePower); ok {
		r0 = returnFunc(ctx, addr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*abi.StoragePower)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, addr, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateVerifierStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateVerifierStatus'
type FullNode_StateVerifierStatus_Call struct {
	*mock.Call
}

// StateVerifierStatus is a helper method to define mock.On call
//   - ctx
//   - addr
//   - tsk
func (_e *FullNode_Expecter) StateVerifierStatus(ctx interface{}, addr interface{}, tsk interface{}) *FullNode_StateVerifierStatus_Call {
	return &FullNode_StateVerifierStatus_Call{Call: _e.mock.On("StateVerifierStatus", ctx, addr, tsk)}
}

func (_c *FullNode_StateVerifierStatus_Call) Run(run func(ctx context.Context, addr address.Address, tsk types.TipSetKey)) *FullNode_StateVerifierStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_StateVerifierStatus_Call) Return(v *abi.StoragePower, err error) *FullNode_StateVerifierStatus_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_StateVerifierStatus_Call) RunAndReturn(run func(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*abi.StoragePower, error)) *FullNode_StateVerifierStatus_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitMsg provides a mock function for the type FullNode
func (_mock *FullNode) StateWaitMsg(ctx context.Context, cid1 cid.Cid, confidence uint64, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error) {
	ret := _mock.Called(ctx, cid1, confidence, limit, allowReplaced)

	if len(ret) == 0 {
		panic("no return value specified for StateWaitMsg")
	}

	var r0 *api.MsgLookup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) (*api.MsgLookup, error)); ok {
		return returnFunc(ctx, cid1, confidence, limit, allowReplaced)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) *api.MsgLookup); ok {
		r0 = returnFunc(ctx, cid1, confidence, limit, allowReplaced)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) error); ok {
		r1 = returnFunc(ctx, cid1, confidence, limit, allowReplaced)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_StateWaitMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitMsg'
type FullNode_StateWaitMsg_Call struct {
	*mock.Call
}

// StateWaitMsg is a helper method to define mock.On call
//   - ctx
//   - cid1
//   - confidence
//   - limit
//   - allowReplaced
func (_e *FullNode_Expecter) StateWaitMsg(ctx interface{}, cid1 interface{}, confidence interface{}, limit interface{}, allowReplaced interface{}) *FullNode_StateWaitMsg_Call {
	return &FullNode_StateWaitMsg_Call{Call: _e.mock.On("StateWaitMsg", ctx, cid1, confidence, limit, allowReplaced)}
}

func (_c *FullNode_StateWaitMsg_Call) Run(run func(ctx context.Context, cid1 cid.Cid, confidence uint64, limit abi.ChainEpoch, allowReplaced bool)) *FullNode_StateWaitMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(uint64), args[3].(abi.ChainEpoch), args[4].(bool))
	})
	return _c
}

func (_c *FullNode_StateWaitMsg_Call) Return(msgLookup *api.MsgLookup, err error) *FullNode_StateWaitMsg_Call {
	_c.Call.Return(msgLookup, err)
	return _c
}

func (_c *FullNode_StateWaitMsg_Call) RunAndReturn(run func(ctx context.Context, cid1 cid.Cid, confidence uint64, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error)) *FullNode_StateWaitMsg_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeActorEventsRaw provides a mock function for the type FullNode
func (_mock *FullNode) SubscribeActorEventsRaw(ctx context.Context, filter *types.ActorEventFilter) (<-chan *types.ActorEvent, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeActorEventsRaw")
	}

	var r0 <-chan *types.ActorEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) (<-chan *types.ActorEvent, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) <-chan *types.ActorEvent); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *types.ActorEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.ActorEventFilter) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_SubscribeActorEventsRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeActorEventsRaw'
type FullNode_SubscribeActorEventsRaw_Call struct {
	*mock.Call
}

// SubscribeActorEventsRaw is a helper method to define mock.On call
//   - ctx
//   - filter
func (_e *FullNode_Expecter) SubscribeActorEventsRaw(ctx interface{}, filter interface{}) *FullNode_SubscribeActorEventsRaw_Call {
	return &FullNode_SubscribeActorEventsRaw_Call{Call: _e.mock.On("SubscribeActorEventsRaw", ctx, filter)}
}

func (_c *FullNode_SubscribeActorEventsRaw_Call) Run(run func(ctx context.Context, filter *types.ActorEventFilter)) *FullNode_SubscribeActorEventsRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.ActorEventFilter))
	})
	return _c
}

func (_c *FullNode_SubscribeActorEventsRaw_Call) Return(actorEventCh <-chan *types.ActorEvent, err error) *FullNode_SubscribeActorEventsRaw_Call {
	_c.Call.Return(actorEventCh, err)
	return _c
}

func (_c *FullNode_SubscribeActorEventsRaw_Call) RunAndReturn(run func(ctx context.Context, filter *types.ActorEventFilter) (<-chan *types.ActorEvent, error)) *FullNode_SubscribeActorEventsRaw_Call {
	_c.Call.Return(run)
	return _c
}

// SyncCheckBad provides a mock function for the type FullNode
func (_mock *FullNode) SyncCheckBad(ctx context.Context, bcid cid.Cid) (string, error) {
	ret := _mock.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncCheckBad")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (string, error)); ok {
		return returnFunc(ctx, bcid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) string); ok {
		r0 = returnFunc(ctx, bcid)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, bcid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_SyncCheckBad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncCheckBad'
type FullNode_SyncCheckBad_Call struct {
	*mock.Call
}

// SyncCheckBad is a helper method to define mock.On call
//   - ctx
//   - bcid
func (_e *FullNode_Expecter) SyncCheckBad(ctx interface{}, bcid interface{}) *FullNode_SyncCheckBad_Call {
	return &FullNode_SyncCheckBad_Call{Call: _e.mock.On("SyncCheckBad", ctx, bcid)}
}

func (_c *FullNode_SyncCheckBad_Call) Run(run func(ctx context.Context, bcid cid.Cid)) *FullNode_SyncCheckBad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_SyncCheckBad_Call) Return(s string, err error) *FullNode_SyncCheckBad_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *FullNode_SyncCheckBad_Call) RunAndReturn(run func(ctx context.Context, bcid cid.Cid) (string, error)) *FullNode_SyncCheckBad_Call {
	_c.Call.Return(run)
	return _c
}

// SyncCheckpoint provides a mock function for the type FullNode
func (_mock *FullNode) SyncCheckpoint(ctx context.Context, tsk types.TipSetKey) error {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for SyncCheckpoint")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) error); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_SyncCheckpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncCheckpoint'
type FullNode_SyncCheckpoint_Call struct {
	*mock.Call
}

// SyncCheckpoint is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) SyncCheckpoint(ctx interface{}, tsk interface{}) *FullNode_SyncCheckpoint_Call {
	return &FullNode_SyncCheckpoint_Call{Call: _e.mock.On("SyncCheckpoint", ctx, tsk)}
}

func (_c *FullNode_SyncCheckpoint_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_SyncCheckpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_SyncCheckpoint_Call) Return(err error) *FullNode_SyncCheckpoint_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_SyncCheckpoint_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) error) *FullNode_SyncCheckpoint_Call {
	_c.Call.Return(run)
	return _c
}

// SyncIncomingBlocks provides a mock function for the type FullNode
func (_mock *FullNode) SyncIncomingBlocks(ctx context.Context) (<-chan *types.BlockHeader, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SyncIncomingBlocks")
	}

	var r0 <-chan *types.BlockHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan *types.BlockHeader, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan *types.BlockHeader); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *types.BlockHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_SyncIncomingBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncIncomingBlocks'
type FullNode_SyncIncomingBlocks_Call struct {
	*mock.Call
}

// SyncIncomingBlocks is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) SyncIncomingBlocks(ctx interface{}) *FullNode_SyncIncomingBlocks_Call {
	return &FullNode_SyncIncomingBlocks_Call{Call: _e.mock.On("SyncIncomingBlocks", ctx)}
}

func (_c *FullNode_SyncIncomingBlocks_Call) Run(run func(ctx context.Context)) *FullNode_SyncIncomingBlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_SyncIncomingBlocks_Call) Return(blockHeaderCh <-chan *types.BlockHeader, err error) *FullNode_SyncIncomingBlocks_Call {
	_c.Call.Return(blockHeaderCh, err)
	return _c
}

func (_c *FullNode_SyncIncomingBlocks_Call) RunAndReturn(run func(ctx context.Context) (<-chan *types.BlockHeader, error)) *FullNode_SyncIncomingBlocks_Call {
	_c.Call.Return(run)
	return _c
}

// SyncMarkBad provides a mock function for the type FullNode
func (_mock *FullNode) SyncMarkBad(ctx context.Context, bcid cid.Cid) error {
	ret := _mock.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncMarkBad")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = returnFunc(ctx, bcid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_SyncMarkBad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncMarkBad'
type FullNode_SyncMarkBad_Call struct {
	*mock.Call
}

// SyncMarkBad is a helper method to define mock.On call
//   - ctx
//   - bcid
func (_e *FullNode_Expecter) SyncMarkBad(ctx interface{}, bcid interface{}) *FullNode_SyncMarkBad_Call {
	return &FullNode_SyncMarkBad_Call{Call: _e.mock.On("SyncMarkBad", ctx, bcid)}
}

func (_c *FullNode_SyncMarkBad_Call) Run(run func(ctx context.Context, bcid cid.Cid)) *FullNode_SyncMarkBad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_SyncMarkBad_Call) Return(err error) *FullNode_SyncMarkBad_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_SyncMarkBad_Call) RunAndReturn(run func(ctx context.Context, bcid cid.Cid) error) *FullNode_SyncMarkBad_Call {
	_c.Call.Return(run)
	return _c
}

// SyncState provides a mock function for the type FullNode
func (_mock *FullNode) SyncState(context1 context.Context) (*api.SyncState, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for SyncState")
	}

	var r0 *api.SyncState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*api.SyncState, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *api.SyncState); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SyncState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_SyncState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncState'
type FullNode_SyncState_Call struct {
	*mock.Call
}

// SyncState is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) SyncState(context1 interface{}) *FullNode_SyncState_Call {
	return &FullNode_SyncState_Call{Call: _e.mock.On("SyncState", context1)}
}

func (_c *FullNode_SyncState_Call) Run(run func(context1 context.Context)) *FullNode_SyncState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_SyncState_Call) Return(syncState *api.SyncState, err error) *FullNode_SyncState_Call {
	_c.Call.Return(syncState, err)
	return _c
}

func (_c *FullNode_SyncState_Call) RunAndReturn(run func(context1 context.Context) (*api.SyncState, error)) *FullNode_SyncState_Call {
	_c.Call.Return(run)
	return _c
}

// SyncSubmitBlock provides a mock function for the type FullNode
func (_mock *FullNode) SyncSubmitBlock(ctx context.Context, blk *types.BlockMsg) error {
	ret := _mock.Called(ctx, blk)

	if len(ret) == 0 {
		panic("no return value specified for SyncSubmitBlock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.BlockMsg) error); ok {
		r0 = returnFunc(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_SyncSubmitBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncSubmitBlock'
type FullNode_SyncSubmitBlock_Call struct {
	*mock.Call
}

// SyncSubmitBlock is a helper method to define mock.On call
//   - ctx
//   - blk
func (_e *FullNode_Expecter) SyncSubmitBlock(ctx interface{}, blk interface{}) *FullNode_SyncSubmitBlock_Call {
	return &FullNode_SyncSubmitBlock_Call{Call: _e.mock.On("SyncSubmitBlock", ctx, blk)}
}

func (_c *FullNode_SyncSubmitBlock_Call) Run(run func(ctx context.Context, blk *types.BlockMsg)) *FullNode_SyncSubmitBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.BlockMsg))
	})
	return _c
}

func (_c *FullNode_SyncSubmitBlock_Call) Return(err error) *FullNode_SyncSubmitBlock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_SyncSubmitBlock_Call) RunAndReturn(run func(ctx context.Context, blk *types.BlockMsg) error) *FullNode_SyncSubmitBlock_Call {
	_c.Call.Return(run)
	return _c
}

// SyncUnmarkAllBad provides a mock function for the type FullNode
func (_mock *FullNode) SyncUnmarkAllBad(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SyncUnmarkAllBad")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_SyncUnmarkAllBad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncUnmarkAllBad'
type FullNode_SyncUnmarkAllBad_Call struct {
	*mock.Call
}

// SyncUnmarkAllBad is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) SyncUnmarkAllBad(ctx interface{}) *FullNode_SyncUnmarkAllBad_Call {
	return &FullNode_SyncUnmarkAllBad_Call{Call: _e.mock.On("SyncUnmarkAllBad", ctx)}
}

func (_c *FullNode_SyncUnmarkAllBad_Call) Run(run func(ctx context.Context)) *FullNode_SyncUnmarkAllBad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_SyncUnmarkAllBad_Call) Return(err error) *FullNode_SyncUnmarkAllBad_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_SyncUnmarkAllBad_Call) RunAndReturn(run func(ctx context.Context) error) *FullNode_SyncUnmarkAllBad_Call {
	_c.Call.Return(run)
	return _c
}

// SyncUnmarkBad provides a mock function for the type FullNode
func (_mock *FullNode) SyncUnmarkBad(ctx context.Context, bcid cid.Cid) error {
	ret := _mock.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncUnmarkBad")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = returnFunc(ctx, bcid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_SyncUnmarkBad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncUnmarkBad'
type FullNode_SyncUnmarkBad_Call struct {
	*mock.Call
}

// SyncUnmarkBad is a helper method to define mock.On call
//   - ctx
//   - bcid
func (_e *FullNode_Expecter) SyncUnmarkBad(ctx interface{}, bcid interface{}) *FullNode_SyncUnmarkBad_Call {
	return &FullNode_SyncUnmarkBad_Call{Call: _e.mock.On("SyncUnmarkBad", ctx, bcid)}
}

func (_c *FullNode_SyncUnmarkBad_Call) Run(run func(ctx context.Context, bcid cid.Cid)) *FullNode_SyncUnmarkBad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid))
	})
	return _c
}

func (_c *FullNode_SyncUnmarkBad_Call) Return(err error) *FullNode_SyncUnmarkBad_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_SyncUnmarkBad_Call) RunAndReturn(run func(ctx context.Context, bcid cid.Cid) error) *FullNode_SyncUnmarkBad_Call {
	_c.Call.Return(run)
	return _c
}

// SyncValidateTipset provides a mock function for the type FullNode
func (_mock *FullNode) SyncValidateTipset(ctx context.Context, tsk types.TipSetKey) (bool, error) {
	ret := _mock.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for SyncValidateTipset")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (bool, error)); ok {
		return returnFunc(ctx, tsk)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TipSetKey) bool); ok {
		r0 = returnFunc(ctx, tsk)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = returnFunc(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_SyncValidateTipset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncValidateTipset'
type FullNode_SyncValidateTipset_Call struct {
	*mock.Call
}

// SyncValidateTipset is a helper method to define mock.On call
//   - ctx
//   - tsk
func (_e *FullNode_Expecter) SyncValidateTipset(ctx interface{}, tsk interface{}) *FullNode_SyncValidateTipset_Call {
	return &FullNode_SyncValidateTipset_Call{Call: _e.mock.On("SyncValidateTipset", ctx, tsk)}
}

func (_c *FullNode_SyncValidateTipset_Call) Run(run func(ctx context.Context, tsk types.TipSetKey)) *FullNode_SyncValidateTipset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TipSetKey))
	})
	return _c
}

func (_c *FullNode_SyncValidateTipset_Call) Return(b bool, err error) *FullNode_SyncValidateTipset_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_SyncValidateTipset_Call) RunAndReturn(run func(ctx context.Context, tsk types.TipSetKey) (bool, error)) *FullNode_SyncValidateTipset_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function for the type FullNode
func (_mock *FullNode) Version(context1 context.Context) (api.APIVersion, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 api.APIVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (api.APIVersion, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) api.APIVersion); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(api.APIVersion)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type FullNode_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) Version(context1 interface{}) *FullNode_Version_Call {
	return &FullNode_Version_Call{Call: _e.mock.On("Version", context1)}
}

func (_c *FullNode_Version_Call) Run(run func(context1 context.Context)) *FullNode_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Version_Call) Return(aPIVersion api.APIVersion, err error) *FullNode_Version_Call {
	_c.Call.Return(aPIVersion, err)
	return _c
}

func (_c *FullNode_Version_Call) RunAndReturn(run func(context1 context.Context) (api.APIVersion, error)) *FullNode_Version_Call {
	_c.Call.Return(run)
	return _c
}

// WalletBalance provides a mock function for the type FullNode
func (_mock *FullNode) WalletBalance(context1 context.Context, address1 address.Address) (types.BigInt, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for WalletBalance")
	}

	var r0 types.BigInt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (types.BigInt, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) types.BigInt); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletBalance'
type FullNode_WalletBalance_Call struct {
	*mock.Call
}

// WalletBalance is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) WalletBalance(context1 interface{}, address1 interface{}) *FullNode_WalletBalance_Call {
	return &FullNode_WalletBalance_Call{Call: _e.mock.On("WalletBalance", context1, address1)}
}

func (_c *FullNode_WalletBalance_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_WalletBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_WalletBalance_Call) Return(v types.BigInt, err error) *FullNode_WalletBalance_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *FullNode_WalletBalance_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (types.BigInt, error)) *FullNode_WalletBalance_Call {
	_c.Call.Return(run)
	return _c
}

// WalletDefaultAddress provides a mock function for the type FullNode
func (_mock *FullNode) WalletDefaultAddress(context1 context.Context) (address.Address, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for WalletDefaultAddress")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (address.Address, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) address.Address); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletDefaultAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletDefaultAddress'
type FullNode_WalletDefaultAddress_Call struct {
	*mock.Call
}

// WalletDefaultAddress is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) WalletDefaultAddress(context1 interface{}) *FullNode_WalletDefaultAddress_Call {
	return &FullNode_WalletDefaultAddress_Call{Call: _e.mock.On("WalletDefaultAddress", context1)}
}

func (_c *FullNode_WalletDefaultAddress_Call) Run(run func(context1 context.Context)) *FullNode_WalletDefaultAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_WalletDefaultAddress_Call) Return(address1 address.Address, err error) *FullNode_WalletDefaultAddress_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_WalletDefaultAddress_Call) RunAndReturn(run func(context1 context.Context) (address.Address, error)) *FullNode_WalletDefaultAddress_Call {
	_c.Call.Return(run)
	return _c
}

// WalletDelete provides a mock function for the type FullNode
func (_mock *FullNode) WalletDelete(context1 context.Context, address1 address.Address) error {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for WalletDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_WalletDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletDelete'
type FullNode_WalletDelete_Call struct {
	*mock.Call
}

// WalletDelete is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) WalletDelete(context1 interface{}, address1 interface{}) *FullNode_WalletDelete_Call {
	return &FullNode_WalletDelete_Call{Call: _e.mock.On("WalletDelete", context1, address1)}
}

func (_c *FullNode_WalletDelete_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_WalletDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_WalletDelete_Call) Return(err error) *FullNode_WalletDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_WalletDelete_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) error) *FullNode_WalletDelete_Call {
	_c.Call.Return(run)
	return _c
}

// WalletExport provides a mock function for the type FullNode
func (_mock *FullNode) WalletExport(context1 context.Context, address1 address.Address) (*types.KeyInfo, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for WalletExport")
	}

	var r0 *types.KeyInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (*types.KeyInfo, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) *types.KeyInfo); ok {
		r0 = returnFunc(context1, address1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.KeyInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletExport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletExport'
type FullNode_WalletExport_Call struct {
	*mock.Call
}

// WalletExport is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) WalletExport(context1 interface{}, address1 interface{}) *FullNode_WalletExport_Call {
	return &FullNode_WalletExport_Call{Call: _e.mock.On("WalletExport", context1, address1)}
}

func (_c *FullNode_WalletExport_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_WalletExport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_WalletExport_Call) Return(keyInfo *types.KeyInfo, err error) *FullNode_WalletExport_Call {
	_c.Call.Return(keyInfo, err)
	return _c
}

func (_c *FullNode_WalletExport_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (*types.KeyInfo, error)) *FullNode_WalletExport_Call {
	_c.Call.Return(run)
	return _c
}

// WalletHas provides a mock function for the type FullNode
func (_mock *FullNode) WalletHas(context1 context.Context, address1 address.Address) (bool, error) {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for WalletHas")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) (bool, error)); ok {
		return returnFunc(context1, address1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) bool); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = returnFunc(context1, address1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletHas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletHas'
type FullNode_WalletHas_Call struct {
	*mock.Call
}

// WalletHas is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) WalletHas(context1 interface{}, address1 interface{}) *FullNode_WalletHas_Call {
	return &FullNode_WalletHas_Call{Call: _e.mock.On("WalletHas", context1, address1)}
}

func (_c *FullNode_WalletHas_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_WalletHas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_WalletHas_Call) Return(b bool, err error) *FullNode_WalletHas_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_WalletHas_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) (bool, error)) *FullNode_WalletHas_Call {
	_c.Call.Return(run)
	return _c
}

// WalletImport provides a mock function for the type FullNode
func (_mock *FullNode) WalletImport(context1 context.Context, keyInfo *types.KeyInfo) (address.Address, error) {
	ret := _mock.Called(context1, keyInfo)

	if len(ret) == 0 {
		panic("no return value specified for WalletImport")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) (address.Address, error)); ok {
		return returnFunc(context1, keyInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) address.Address); ok {
		r0 = returnFunc(context1, keyInfo)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.KeyInfo) error); ok {
		r1 = returnFunc(context1, keyInfo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletImport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletImport'
type FullNode_WalletImport_Call struct {
	*mock.Call
}

// WalletImport is a helper method to define mock.On call
//   - context1
//   - keyInfo
func (_e *FullNode_Expecter) WalletImport(context1 interface{}, keyInfo interface{}) *FullNode_WalletImport_Call {
	return &FullNode_WalletImport_Call{Call: _e.mock.On("WalletImport", context1, keyInfo)}
}

func (_c *FullNode_WalletImport_Call) Run(run func(context1 context.Context, keyInfo *types.KeyInfo)) *FullNode_WalletImport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.KeyInfo))
	})
	return _c
}

func (_c *FullNode_WalletImport_Call) Return(address1 address.Address, err error) *FullNode_WalletImport_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_WalletImport_Call) RunAndReturn(run func(context1 context.Context, keyInfo *types.KeyInfo) (address.Address, error)) *FullNode_WalletImport_Call {
	_c.Call.Return(run)
	return _c
}

// WalletList provides a mock function for the type FullNode
func (_mock *FullNode) WalletList(context1 context.Context) ([]address.Address, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for WalletList")
	}

	var r0 []address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]address.Address, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletList'
type FullNode_WalletList_Call struct {
	*mock.Call
}

// WalletList is a helper method to define mock.On call
//   - context1
func (_e *FullNode_Expecter) WalletList(context1 interface{}) *FullNode_WalletList_Call {
	return &FullNode_WalletList_Call{Call: _e.mock.On("WalletList", context1)}
}

func (_c *FullNode_WalletList_Call) Run(run func(context1 context.Context)) *FullNode_WalletList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_WalletList_Call) Return(addresss []address.Address, err error) *FullNode_WalletList_Call {
	_c.Call.Return(addresss, err)
	return _c
}

func (_c *FullNode_WalletList_Call) RunAndReturn(run func(context1 context.Context) ([]address.Address, error)) *FullNode_WalletList_Call {
	_c.Call.Return(run)
	return _c
}

// WalletNew provides a mock function for the type FullNode
func (_mock *FullNode) WalletNew(context1 context.Context, keyType types.KeyType) (address.Address, error) {
	ret := _mock.Called(context1, keyType)

	if len(ret) == 0 {
		panic("no return value specified for WalletNew")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.KeyType) (address.Address, error)); ok {
		return returnFunc(context1, keyType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.KeyType) address.Address); ok {
		r0 = returnFunc(context1, keyType)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.KeyType) error); ok {
		r1 = returnFunc(context1, keyType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletNew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletNew'
type FullNode_WalletNew_Call struct {
	*mock.Call
}

// WalletNew is a helper method to define mock.On call
//   - context1
//   - keyType
func (_e *FullNode_Expecter) WalletNew(context1 interface{}, keyType interface{}) *FullNode_WalletNew_Call {
	return &FullNode_WalletNew_Call{Call: _e.mock.On("WalletNew", context1, keyType)}
}

func (_c *FullNode_WalletNew_Call) Run(run func(context1 context.Context, keyType types.KeyType)) *FullNode_WalletNew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.KeyType))
	})
	return _c
}

func (_c *FullNode_WalletNew_Call) Return(address1 address.Address, err error) *FullNode_WalletNew_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_WalletNew_Call) RunAndReturn(run func(context1 context.Context, keyType types.KeyType) (address.Address, error)) *FullNode_WalletNew_Call {
	_c.Call.Return(run)
	return _c
}

// WalletSetDefault provides a mock function for the type FullNode
func (_mock *FullNode) WalletSetDefault(context1 context.Context, address1 address.Address) error {
	ret := _mock.Called(context1, address1)

	if len(ret) == 0 {
		panic("no return value specified for WalletSetDefault")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = returnFunc(context1, address1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FullNode_WalletSetDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletSetDefault'
type FullNode_WalletSetDefault_Call struct {
	*mock.Call
}

// WalletSetDefault is a helper method to define mock.On call
//   - context1
//   - address1
func (_e *FullNode_Expecter) WalletSetDefault(context1 interface{}, address1 interface{}) *FullNode_WalletSetDefault_Call {
	return &FullNode_WalletSetDefault_Call{Call: _e.mock.On("WalletSetDefault", context1, address1)}
}

func (_c *FullNode_WalletSetDefault_Call) Run(run func(context1 context.Context, address1 address.Address)) *FullNode_WalletSetDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address))
	})
	return _c
}

func (_c *FullNode_WalletSetDefault_Call) Return(err error) *FullNode_WalletSetDefault_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FullNode_WalletSetDefault_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address) error) *FullNode_WalletSetDefault_Call {
	_c.Call.Return(run)
	return _c
}

// WalletSign provides a mock function for the type FullNode
func (_mock *FullNode) WalletSign(context1 context.Context, address1 address.Address, bytes []byte) (*crypto.Signature, error) {
	ret := _mock.Called(context1, address1, bytes)

	if len(ret) == 0 {
		panic("no return value specified for WalletSign")
	}

	var r0 *crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, []byte) (*crypto.Signature, error)); ok {
		return returnFunc(context1, address1, bytes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, []byte) *crypto.Signature); ok {
		r0 = returnFunc(context1, address1, bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, []byte) error); ok {
		r1 = returnFunc(context1, address1, bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletSign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletSign'
type FullNode_WalletSign_Call struct {
	*mock.Call
}

// WalletSign is a helper method to define mock.On call
//   - context1
//   - address1
//   - bytes
func (_e *FullNode_Expecter) WalletSign(context1 interface{}, address1 interface{}, bytes interface{}) *FullNode_WalletSign_Call {
	return &FullNode_WalletSign_Call{Call: _e.mock.On("WalletSign", context1, address1, bytes)}
}

func (_c *FullNode_WalletSign_Call) Run(run func(context1 context.Context, address1 address.Address, bytes []byte)) *FullNode_WalletSign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].([]byte))
	})
	return _c
}

func (_c *FullNode_WalletSign_Call) Return(signature *crypto.Signature, err error) *FullNode_WalletSign_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *FullNode_WalletSign_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, bytes []byte) (*crypto.Signature, error)) *FullNode_WalletSign_Call {
	_c.Call.Return(run)
	return _c
}

// WalletSignMessage provides a mock function for the type FullNode
func (_mock *FullNode) WalletSignMessage(context1 context.Context, address1 address.Address, message *types.Message) (*types.SignedMessage, error) {
	ret := _mock.Called(context1, address1, message)

	if len(ret) == 0 {
		panic("no return value specified for WalletSignMessage")
	}

	var r0 *types.SignedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) (*types.SignedMessage, error)); ok {
		return returnFunc(context1, address1, message)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) *types.SignedMessage); ok {
		r0 = returnFunc(context1, address1, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, *types.Message) error); ok {
		r1 = returnFunc(context1, address1, message)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletSignMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletSignMessage'
type FullNode_WalletSignMessage_Call struct {
	*mock.Call
}

// WalletSignMessage is a helper method to define mock.On call
//   - context1
//   - address1
//   - message
func (_e *FullNode_Expecter) WalletSignMessage(context1 interface{}, address1 interface{}, message interface{}) *FullNode_WalletSignMessage_Call {
	return &FullNode_WalletSignMessage_Call{Call: _e.mock.On("WalletSignMessage", context1, address1, message)}
}

func (_c *FullNode_WalletSignMessage_Call) Run(run func(context1 context.Context, address1 address.Address, message *types.Message)) *FullNode_WalletSignMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].(*types.Message))
	})
	return _c
}

func (_c *FullNode_WalletSignMessage_Call) Return(signedMessage *types.SignedMessage, err error) *FullNode_WalletSignMessage_Call {
	_c.Call.Return(signedMessage, err)
	return _c
}

func (_c *FullNode_WalletSignMessage_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, message *types.Message) (*types.SignedMessage, error)) *FullNode_WalletSignMessage_Call {
	_c.Call.Return(run)
	return _c
}

// WalletValidateAddress provides a mock function for the type FullNode
func (_mock *FullNode) WalletValidateAddress(context1 context.Context, s string) (address.Address, error) {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for WalletValidateAddress")
	}

	var r0 address.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (address.Address, error)); ok {
		return returnFunc(context1, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) address.Address); ok {
		r0 = returnFunc(context1, s)
	} else {
		r0 = ret.Get(0).(address.Address)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(context1, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletValidateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletValidateAddress'
type FullNode_WalletValidateAddress_Call struct {
	*mock.Call
}

// WalletValidateAddress is a helper method to define mock.On call
//   - context1
//   - s
func (_e *FullNode_Expecter) WalletValidateAddress(context1 interface{}, s interface{}) *FullNode_WalletValidateAddress_Call {
	return &FullNode_WalletValidateAddress_Call{Call: _e.mock.On("WalletValidateAddress", context1, s)}
}

func (_c *FullNode_WalletValidateAddress_Call) Run(run func(context1 context.Context, s string)) *FullNode_WalletValidateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FullNode_WalletValidateAddress_Call) Return(address1 address.Address, err error) *FullNode_WalletValidateAddress_Call {
	_c.Call.Return(address1, err)
	return _c
}

func (_c *FullNode_WalletValidateAddress_Call) RunAndReturn(run func(context1 context.Context, s string) (address.Address, error)) *FullNode_WalletValidateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// WalletVerify provides a mock function for the type FullNode
func (_mock *FullNode) WalletVerify(context1 context.Context, address1 address.Address, bytes []byte, signature *crypto.Signature) (bool, error) {
	ret := _mock.Called(context1, address1, bytes, signature)

	if len(ret) == 0 {
		panic("no return value specified for WalletVerify")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, []byte, *crypto.Signature) (bool, error)); ok {
		return returnFunc(context1, address1, bytes, signature)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, address.Address, []byte, *crypto.Signature) bool); ok {
		r0 = returnFunc(context1, address1, bytes, signature)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, address.Address, []byte, *crypto.Signature) error); ok {
		r1 = returnFunc(context1, address1, bytes, signature)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_WalletVerify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletVerify'
type FullNode_WalletVerify_Call struct {
	*mock.Call
}

// WalletVerify is a helper method to define mock.On call
//   - context1
//   - address1
//   - bytes
//   - signature
func (_e *FullNode_Expecter) WalletVerify(context1 interface{}, address1 interface{}, bytes interface{}, signature interface{}) *FullNode_WalletVerify_Call {
	return &FullNode_WalletVerify_Call{Call: _e.mock.On("WalletVerify", context1, address1, bytes, signature)}
}

func (_c *FullNode_WalletVerify_Call) Run(run func(context1 context.Context, address1 address.Address, bytes []byte, signature *crypto.Signature)) *FullNode_WalletVerify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(address.Address), args[2].([]byte), args[3].(*crypto.Signature))
	})
	return _c
}

func (_c *FullNode_WalletVerify_Call) Return(b bool, err error) *FullNode_WalletVerify_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *FullNode_WalletVerify_Call) RunAndReturn(run func(context1 context.Context, address1 address.Address, bytes []byte, signature *crypto.Signature) (bool, error)) *FullNode_WalletVerify_Call {
	_c.Call.Return(run)
	return _c
}

// Web3ClientVersion provides a mock function for the type FullNode
func (_mock *FullNode) Web3ClientVersion(ctx context.Context) (string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Web3ClientVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// FullNode_Web3ClientVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Web3ClientVersion'
type FullNode_Web3ClientVersion_Call struct {
	*mock.Call
}

// Web3ClientVersion is a helper method to define mock.On call
//   - ctx
func (_e *FullNode_Expecter) Web3ClientVersion(ctx interface{}) *FullNode_Web3ClientVersion_Call {
	return &FullNode_Web3ClientVersion_Call{Call: _e.mock.On("Web3ClientVersion", ctx)}
}

func (_c *FullNode_Web3ClientVersion_Call) Run(run func(ctx context.Context)) *FullNode_Web3ClientVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FullNode_Web3ClientVersion_Call) Return(s string, err error) *FullNode_Web3ClientVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *FullNode_Web3ClientVersion_Call) RunAndReturn(run func(ctx context.Context) (string, error)) *FullNode_Web3ClientVersion_Call {
	_c.Call.Return(run)
	return _c
}
