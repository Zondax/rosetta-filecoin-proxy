// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	address "github.com/filecoin-project/go-address"
	abi "github.com/filecoin-project/go-state-types/abi"

	alerting "github.com/filecoin-project/lotus/journal/alerting"

	api "github.com/filecoin-project/lotus/api"

	apitypes "github.com/filecoin-project/lotus/api/types"

	auth "github.com/filecoin-project/go-jsonrpc/auth"

	big "github.com/filecoin-project/go-state-types/big"

	bitfield "github.com/filecoin-project/go-bitfield"

	blocks "github.com/ipfs/go-block-format"

	builtinminer "github.com/filecoin-project/lotus/chain/actors/builtin/miner"

	certs "github.com/filecoin-project/go-f3/certs"

	cid "github.com/ipfs/go-cid"

	context "context"

	crypto "github.com/filecoin-project/go-state-types/crypto"

	dline "github.com/filecoin-project/go-state-types/dline"

	dtypes "github.com/filecoin-project/lotus/node/modules/dtypes"

	ethtypes "github.com/filecoin-project/lotus/chain/types/ethtypes"

	go_state_typesnetwork "github.com/filecoin-project/go-state-types/network"

	gpbft "github.com/filecoin-project/go-f3/gpbft"

	json "encoding/json"

	jsonrpc "github.com/filecoin-project/go-jsonrpc"

	manifest "github.com/filecoin-project/go-f3/manifest"

	metrics "github.com/libp2p/go-libp2p/core/metrics"

	miner "github.com/filecoin-project/go-state-types/builtin/v17/miner"

	mock "github.com/stretchr/testify/mock"

	network "github.com/libp2p/go-libp2p/core/network"

	paych "github.com/filecoin-project/go-state-types/builtin/v8/paych"

	peer "github.com/libp2p/go-libp2p/core/peer"

	protocol "github.com/libp2p/go-libp2p/core/protocol"

	time "time"

	types "github.com/filecoin-project/lotus/chain/types"

	uuid "github.com/google/uuid"

	v9miner "github.com/filecoin-project/go-state-types/builtin/v9/miner"

	verifreg "github.com/filecoin-project/go-state-types/builtin/v9/verifreg"
)

// FullNode is an autogenerated mock type for the FullNode type
type FullNode struct {
	mock.Mock
}

// AuthNew provides a mock function with given fields: ctx, perms
func (_m *FullNode) AuthNew(ctx context.Context, perms []auth.Permission) ([]byte, error) {
	ret := _m.Called(ctx, perms)

	if len(ret) == 0 {
		panic("no return value specified for AuthNew")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []auth.Permission) ([]byte, error)); ok {
		return rf(ctx, perms)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []auth.Permission) []byte); ok {
		r0 = rf(ctx, perms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []auth.Permission) error); ok {
		r1 = rf(ctx, perms)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthVerify provides a mock function with given fields: ctx, token
func (_m *FullNode) AuthVerify(ctx context.Context, token string) ([]auth.Permission, error) {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for AuthVerify")
	}

	var r0 []auth.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]auth.Permission, error)); ok {
		return rf(ctx, token)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []auth.Permission); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]auth.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainBlockstoreInfo provides a mock function with given fields: _a0
func (_m *FullNode) ChainBlockstoreInfo(_a0 context.Context) (map[string]interface{}, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ChainBlockstoreInfo")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[string]interface{}, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainCheckBlockstore provides a mock function with given fields: _a0
func (_m *FullNode) ChainCheckBlockstore(_a0 context.Context) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ChainCheckBlockstore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainDeleteObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainDeleteObj(_a0 context.Context, _a1 cid.Cid) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainDeleteObj")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainExport provides a mock function with given fields: ctx, nroots, oldmsgskip, tsk
func (_m *FullNode) ChainExport(ctx context.Context, nroots abi.ChainEpoch, oldmsgskip bool, tsk types.TipSetKey) (<-chan []byte, error) {
	ret := _m.Called(ctx, nroots, oldmsgskip, tsk)

	if len(ret) == 0 {
		panic("no return value specified for ChainExport")
	}

	var r0 <-chan []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) (<-chan []byte, error)); ok {
		return rf(ctx, nroots, oldmsgskip, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) <-chan []byte); ok {
		r0 = rf(ctx, nroots, oldmsgskip, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, bool, types.TipSetKey) error); ok {
		r1 = rf(ctx, nroots, oldmsgskip, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainExportRangeInternal provides a mock function with given fields: ctx, head, tail, cfg
func (_m *FullNode) ChainExportRangeInternal(ctx context.Context, head types.TipSetKey, tail types.TipSetKey, cfg api.ChainExportConfig) error {
	ret := _m.Called(ctx, head, tail, cfg)

	if len(ret) == 0 {
		panic("no return value specified for ChainExportRangeInternal")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey, api.ChainExportConfig) error); ok {
		r0 = rf(ctx, head, tail, cfg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainGetBlock provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetBlock(_a0 context.Context, _a1 cid.Cid) (*types.BlockHeader, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetBlock")
	}

	var r0 *types.BlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (*types.BlockHeader, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.BlockHeader); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetBlockMessages provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetBlockMessages(ctx context.Context, blockCid cid.Cid) (*api.BlockMessages, error) {
	ret := _m.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetBlockMessages")
	}

	var r0 *api.BlockMessages
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (*api.BlockMessages, error)); ok {
		return rf(ctx, blockCid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.BlockMessages); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BlockMessages)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetEvents provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetEvents(_a0 context.Context, _a1 cid.Cid) ([]types.Event, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetEvents")
	}

	var r0 []types.Event
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]types.Event, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []types.Event); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetFinalizedTipSet provides a mock function with given fields: ctx
func (_m *FullNode) ChainGetFinalizedTipSet(ctx context.Context) (*types.TipSet, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetFinalizedTipSet")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.TipSet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetGenesis provides a mock function with given fields: _a0
func (_m *FullNode) ChainGetGenesis(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetGenesis")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.TipSet, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetMessage provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetMessage(_a0 context.Context, _a1 cid.Cid) (*types.Message, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetMessage")
	}

	var r0 *types.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (*types.Message, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.Message); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetMessagesInTipset provides a mock function with given fields: ctx, tsk
func (_m *FullNode) ChainGetMessagesInTipset(ctx context.Context, tsk types.TipSetKey) ([]api.Message, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetMessagesInTipset")
	}

	var r0 []api.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]api.Message, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []api.Message); ok {
		r0 = rf(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetNode provides a mock function with given fields: ctx, p
func (_m *FullNode) ChainGetNode(ctx context.Context, p string) (*api.IpldObject, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetNode")
	}

	var r0 *api.IpldObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.IpldObject, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.IpldObject); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.IpldObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentMessages provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetParentMessages(ctx context.Context, blockCid cid.Cid) ([]api.Message, error) {
	ret := _m.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetParentMessages")
	}

	var r0 []api.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]api.Message, error)); ok {
		return rf(ctx, blockCid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.Message); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentReceipts provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetParentReceipts(ctx context.Context, blockCid cid.Cid) ([]*types.MessageReceipt, error) {
	ret := _m.Called(ctx, blockCid)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetParentReceipts")
	}

	var r0 []*types.MessageReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]*types.MessageReceipt, error)); ok {
		return rf(ctx, blockCid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []*types.MessageReceipt); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.MessageReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetPath provides a mock function with given fields: ctx, from, to
func (_m *FullNode) ChainGetPath(ctx context.Context, from types.TipSetKey, to types.TipSetKey) ([]*api.HeadChange, error) {
	ret := _m.Called(ctx, from, to)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetPath")
	}

	var r0 []*api.HeadChange
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey) ([]*api.HeadChange, error)); ok {
		return rf(ctx, from, to)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey) []*api.HeadChange); ok {
		r0 = rf(ctx, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.HeadChange)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, types.TipSetKey) error); ok {
		r1 = rf(ctx, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSet provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetTipSet(_a0 context.Context, _a1 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSet")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (*types.TipSet, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSetAfterHeight provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) ChainGetTipSetAfterHeight(_a0 context.Context, _a1 abi.ChainEpoch, _a2 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSetAfterHeight")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (*types.TipSet, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSetByHeight provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) ChainGetTipSetByHeight(_a0 context.Context, _a1 abi.ChainEpoch, _a2 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetTipSetByHeight")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (*types.TipSet, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHasObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainHasObj(_a0 context.Context, _a1 cid.Cid) (bool, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainHasObj")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (bool, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHead provides a mock function with given fields: _a0
func (_m *FullNode) ChainHead(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ChainHead")
	}

	var r0 *types.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.TipSet, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHotGC provides a mock function with given fields: ctx, opts
func (_m *FullNode) ChainHotGC(ctx context.Context, opts api.HotGCOpts) error {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ChainHotGC")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.HotGCOpts) error); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainNotify provides a mock function with given fields: _a0
func (_m *FullNode) ChainNotify(_a0 context.Context) (<-chan []*api.HeadChange, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ChainNotify")
	}

	var r0 <-chan []*api.HeadChange
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (<-chan []*api.HeadChange, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan []*api.HeadChange); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []*api.HeadChange)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainPrune provides a mock function with given fields: ctx, opts
func (_m *FullNode) ChainPrune(ctx context.Context, opts api.PruneOpts) error {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ChainPrune")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.PruneOpts) error); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainPutObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainPutObj(_a0 context.Context, _a1 blocks.Block) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainPutObj")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, blocks.Block) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainReadObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainReadObj(_a0 context.Context, _a1 cid.Cid) ([]byte, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainReadObj")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) ([]byte, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainSetHead provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainSetHead(_a0 context.Context, _a1 types.TipSetKey) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainSetHead")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainStatObj provides a mock function with given fields: ctx, obj, base
func (_m *FullNode) ChainStatObj(ctx context.Context, obj cid.Cid, base cid.Cid) (api.ObjStat, error) {
	ret := _m.Called(ctx, obj, base)

	if len(ret) == 0 {
		panic("no return value specified for ChainStatObj")
	}

	var r0 api.ObjStat
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) (api.ObjStat, error)); ok {
		return rf(ctx, obj, base)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) api.ObjStat); ok {
		r0 = rf(ctx, obj, base)
	} else {
		r0 = ret.Get(0).(api.ObjStat)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = rf(ctx, obj, base)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainTipSetWeight provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainTipSetWeight(_a0 context.Context, _a1 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ChainTipSetWeight")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainValidateIndex provides a mock function with given fields: ctx, epoch, backfill
func (_m *FullNode) ChainValidateIndex(ctx context.Context, epoch abi.ChainEpoch, backfill bool) (*types.IndexValidation, error) {
	ret := _m.Called(ctx, epoch, backfill)

	if len(ret) == 0 {
		panic("no return value specified for ChainValidateIndex")
	}

	var r0 *types.IndexValidation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool) (*types.IndexValidation, error)); ok {
		return rf(ctx, epoch, backfill)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, bool) *types.IndexValidation); ok {
		r0 = rf(ctx, epoch, backfill)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.IndexValidation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, bool) error); ok {
		r1 = rf(ctx, epoch, backfill)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Closing provides a mock function with given fields: _a0
func (_m *FullNode) Closing(_a0 context.Context) (<-chan struct{}, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Closing")
	}

	var r0 <-chan struct{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (<-chan struct{}, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan struct{}); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBackup provides a mock function with given fields: ctx, fpath
func (_m *FullNode) CreateBackup(ctx context.Context, fpath string) error {
	ret := _m.Called(ctx, fpath)

	if len(ret) == 0 {
		panic("no return value specified for CreateBackup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, fpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Discover provides a mock function with given fields: ctx
func (_m *FullNode) Discover(ctx context.Context) (apitypes.OpenRPCDocument, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Discover")
	}

	var r0 apitypes.OpenRPCDocument
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (apitypes.OpenRPCDocument, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) apitypes.OpenRPCDocument); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(apitypes.OpenRPCDocument)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthAccounts provides a mock function with given fields: ctx
func (_m *FullNode) EthAccounts(ctx context.Context) ([]ethtypes.EthAddress, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthAccounts")
	}

	var r0 []ethtypes.EthAddress
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]ethtypes.EthAddress, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []ethtypes.EthAddress); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ethtypes.EthAddress)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthAddressToFilecoinAddress provides a mock function with given fields: ctx, ethAddress
func (_m *FullNode) EthAddressToFilecoinAddress(ctx context.Context, ethAddress ethtypes.EthAddress) (address.Address, error) {
	ret := _m.Called(ctx, ethAddress)

	if len(ret) == 0 {
		panic("no return value specified for EthAddressToFilecoinAddress")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress) (address.Address, error)); ok {
		return rf(ctx, ethAddress)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress) address.Address); ok {
		r0 = rf(ctx, ethAddress)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress) error); ok {
		r1 = rf(ctx, ethAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthBlockNumber provides a mock function with given fields: ctx
func (_m *FullNode) EthBlockNumber(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthBlockNumber")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthCall provides a mock function with given fields: ctx, tx, blkParam
func (_m *FullNode) EthCall(ctx context.Context, tx ethtypes.EthCall, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _m.Called(ctx, tx, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthCall")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return rf(ctx, tx, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = rf(ctx, tx, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthCall, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, tx, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthChainId provides a mock function with given fields: ctx
func (_m *FullNode) EthChainId(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthChainId")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthEstimateGas provides a mock function with given fields: ctx, p
func (_m *FullNode) EthEstimateGas(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for EthEstimateGas")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthUint64, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthUint64); ok {
		r0 = rf(ctx, p)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthFeeHistory provides a mock function with given fields: ctx, p
func (_m *FullNode) EthFeeHistory(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthFeeHistory, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for EthFeeHistory")
	}

	var r0 ethtypes.EthFeeHistory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthFeeHistory, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthFeeHistory); ok {
		r0 = rf(ctx, p)
	} else {
		r0 = ret.Get(0).(ethtypes.EthFeeHistory)
	}

	if rf, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGasPrice provides a mock function with given fields: ctx
func (_m *FullNode) EthGasPrice(ctx context.Context) (ethtypes.EthBigInt, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthGasPrice")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthBigInt, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthBigInt); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBalance provides a mock function with given fields: ctx, _a1, blkParam
func (_m *FullNode) EthGetBalance(ctx context.Context, _a1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBigInt, error) {
	ret := _m.Called(ctx, _a1, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBalance")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBigInt, error)); ok {
		return rf(ctx, _a1, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthBigInt); ok {
		r0 = rf(ctx, _a1, blkParam)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, _a1, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockByHash provides a mock function with given fields: ctx, blkHash, fullTxInfo
func (_m *FullNode) EthGetBlockByHash(ctx context.Context, blkHash ethtypes.EthHash, fullTxInfo bool) (ethtypes.EthBlock, error) {
	ret := _m.Called(ctx, blkHash, fullTxInfo)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockByHash")
	}

	var r0 ethtypes.EthBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, bool) (ethtypes.EthBlock, error)); ok {
		return rf(ctx, blkHash, fullTxInfo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, bool) ethtypes.EthBlock); ok {
		r0 = rf(ctx, blkHash, fullTxInfo)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBlock)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, bool) error); ok {
		r1 = rf(ctx, blkHash, fullTxInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockByNumber provides a mock function with given fields: ctx, blkNum, fullTxInfo
func (_m *FullNode) EthGetBlockByNumber(ctx context.Context, blkNum string, fullTxInfo bool) (ethtypes.EthBlock, error) {
	ret := _m.Called(ctx, blkNum, fullTxInfo)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockByNumber")
	}

	var r0 ethtypes.EthBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (ethtypes.EthBlock, error)); ok {
		return rf(ctx, blkNum, fullTxInfo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) ethtypes.EthBlock); ok {
		r0 = rf(ctx, blkNum, fullTxInfo)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBlock)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, blkNum, fullTxInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockReceipts provides a mock function with given fields: ctx, blkParam
func (_m *FullNode) EthGetBlockReceipts(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash) ([]*ethtypes.EthTxReceipt, error) {
	ret := _m.Called(ctx, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockReceipts")
	}

	var r0 []*ethtypes.EthTxReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash) ([]*ethtypes.EthTxReceipt, error)); ok {
		return rf(ctx, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash) []*ethtypes.EthTxReceipt); ok {
		r0 = rf(ctx, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTxReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockReceiptsLimited provides a mock function with given fields: ctx, blkParam, limit
func (_m *FullNode) EthGetBlockReceiptsLimited(ctx context.Context, blkParam ethtypes.EthBlockNumberOrHash, limit abi.ChainEpoch) ([]*ethtypes.EthTxReceipt, error) {
	ret := _m.Called(ctx, blkParam, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockReceiptsLimited")
	}

	var r0 []*ethtypes.EthTxReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) ([]*ethtypes.EthTxReceipt, error)); ok {
		return rf(ctx, blkParam, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) []*ethtypes.EthTxReceipt); ok {
		r0 = rf(ctx, blkParam, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTxReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthBlockNumberOrHash, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, blkParam, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockTransactionCountByHash provides a mock function with given fields: ctx, blkHash
func (_m *FullNode) EthGetBlockTransactionCountByHash(ctx context.Context, blkHash ethtypes.EthHash) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx, blkHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockTransactionCountByHash")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) (ethtypes.EthUint64, error)); ok {
		return rf(ctx, blkHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) ethtypes.EthUint64); ok {
		r0 = rf(ctx, blkHash)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash) error); ok {
		r1 = rf(ctx, blkHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetBlockTransactionCountByNumber provides a mock function with given fields: ctx, blkNum
func (_m *FullNode) EthGetBlockTransactionCountByNumber(ctx context.Context, blkNum string) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx, blkNum)

	if len(ret) == 0 {
		panic("no return value specified for EthGetBlockTransactionCountByNumber")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (ethtypes.EthUint64, error)); ok {
		return rf(ctx, blkNum)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) ethtypes.EthUint64); ok {
		r0 = rf(ctx, blkNum)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blkNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetCode provides a mock function with given fields: ctx, _a1, blkParam
func (_m *FullNode) EthGetCode(ctx context.Context, _a1 ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _m.Called(ctx, _a1, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetCode")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return rf(ctx, _a1, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = rf(ctx, _a1, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, _a1, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetFilterChanges provides a mock function with given fields: ctx, id
func (_m *FullNode) EthGetFilterChanges(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthGetFilterChanges")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) *ethtypes.EthFilterResult); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetFilterLogs provides a mock function with given fields: ctx, id
func (_m *FullNode) EthGetFilterLogs(ctx context.Context, id ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthGetFilterLogs")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (*ethtypes.EthFilterResult, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) *ethtypes.EthFilterResult); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetLogs provides a mock function with given fields: ctx, filter
func (_m *FullNode) EthGetLogs(ctx context.Context, filter *ethtypes.EthFilterSpec) (*ethtypes.EthFilterResult, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthGetLogs")
	}

	var r0 *ethtypes.EthFilterResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) (*ethtypes.EthFilterResult, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) *ethtypes.EthFilterResult); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthFilterResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ethtypes.EthFilterSpec) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetMessageCidByTransactionHash provides a mock function with given fields: ctx, txHash
func (_m *FullNode) EthGetMessageCidByTransactionHash(ctx context.Context, txHash *ethtypes.EthHash) (*cid.Cid, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetMessageCidByTransactionHash")
	}

	var r0 *cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) (*cid.Cid, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) *cid.Cid); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cid.Cid)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetStorageAt provides a mock function with given fields: ctx, _a1, position, blkParam
func (_m *FullNode) EthGetStorageAt(ctx context.Context, _a1 ethtypes.EthAddress, position ethtypes.EthBytes, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error) {
	ret := _m.Called(ctx, _a1, position, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetStorageAt")
	}

	var r0 ethtypes.EthBytes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) (ethtypes.EthBytes, error)); ok {
		return rf(ctx, _a1, position, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) ethtypes.EthBytes); ok {
		r0 = rf(ctx, _a1, position, blkParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthBytes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBytes, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, _a1, position, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionByBlockHashAndIndex provides a mock function with given fields: ctx, blkHash, txIndex
func (_m *FullNode) EthGetTransactionByBlockHashAndIndex(ctx context.Context, blkHash ethtypes.EthHash, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error) {
	ret := _m.Called(ctx, blkHash, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByBlockHashAndIndex")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) (*ethtypes.EthTx, error)); ok {
		return rf(ctx, blkHash, txIndex)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) *ethtypes.EthTx); ok {
		r0 = rf(ctx, blkHash, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, ethtypes.EthUint64) error); ok {
		r1 = rf(ctx, blkHash, txIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionByBlockNumberAndIndex provides a mock function with given fields: ctx, blkNum, txIndex
func (_m *FullNode) EthGetTransactionByBlockNumberAndIndex(ctx context.Context, blkNum string, txIndex ethtypes.EthUint64) (*ethtypes.EthTx, error) {
	ret := _m.Called(ctx, blkNum, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByBlockNumberAndIndex")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ethtypes.EthUint64) (*ethtypes.EthTx, error)); ok {
		return rf(ctx, blkNum, txIndex)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ethtypes.EthUint64) *ethtypes.EthTx); ok {
		r0 = rf(ctx, blkNum, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ethtypes.EthUint64) error); ok {
		r1 = rf(ctx, blkNum, txIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionByHash provides a mock function with given fields: ctx, txHash
func (_m *FullNode) EthGetTransactionByHash(ctx context.Context, txHash *ethtypes.EthHash) (*ethtypes.EthTx, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByHash")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) (*ethtypes.EthTx, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash) *ethtypes.EthTx); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionByHashLimited provides a mock function with given fields: ctx, txHash, limit
func (_m *FullNode) EthGetTransactionByHashLimited(ctx context.Context, txHash *ethtypes.EthHash, limit abi.ChainEpoch) (*ethtypes.EthTx, error) {
	ret := _m.Called(ctx, txHash, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionByHashLimited")
	}

	var r0 *ethtypes.EthTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) (*ethtypes.EthTx, error)); ok {
		return rf(ctx, txHash, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) *ethtypes.EthTx); ok {
		r0 = rf(ctx, txHash, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ethtypes.EthHash, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, txHash, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionCount provides a mock function with given fields: ctx, sender, blkParam
func (_m *FullNode) EthGetTransactionCount(ctx context.Context, sender ethtypes.EthAddress, blkParam ethtypes.EthBlockNumberOrHash) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx, sender, blkParam)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionCount")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) (ethtypes.EthUint64, error)); ok {
		return rf(ctx, sender, blkParam)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) ethtypes.EthUint64); ok {
		r0 = rf(ctx, sender, blkParam)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthAddress, ethtypes.EthBlockNumberOrHash) error); ok {
		r1 = rf(ctx, sender, blkParam)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionHashByCid provides a mock function with given fields: ctx, _a1
func (_m *FullNode) EthGetTransactionHashByCid(ctx context.Context, _a1 cid.Cid) (*ethtypes.EthHash, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionHashByCid")
	}

	var r0 *ethtypes.EthHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (*ethtypes.EthHash, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *ethtypes.EthHash); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionReceipt provides a mock function with given fields: ctx, txHash
func (_m *FullNode) EthGetTransactionReceipt(ctx context.Context, txHash ethtypes.EthHash) (*ethtypes.EthTxReceipt, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionReceipt")
	}

	var r0 *ethtypes.EthTxReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) (*ethtypes.EthTxReceipt, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash) *ethtypes.EthTxReceipt); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTxReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthGetTransactionReceiptLimited provides a mock function with given fields: ctx, txHash, limit
func (_m *FullNode) EthGetTransactionReceiptLimited(ctx context.Context, txHash ethtypes.EthHash, limit abi.ChainEpoch) (*ethtypes.EthTxReceipt, error) {
	ret := _m.Called(ctx, txHash, limit)

	if len(ret) == 0 {
		panic("no return value specified for EthGetTransactionReceiptLimited")
	}

	var r0 *ethtypes.EthTxReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) (*ethtypes.EthTxReceipt, error)); ok {
		return rf(ctx, txHash, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) *ethtypes.EthTxReceipt); ok {
		r0 = rf(ctx, txHash, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethtypes.EthTxReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthHash, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, txHash, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthMaxPriorityFeePerGas provides a mock function with given fields: ctx
func (_m *FullNode) EthMaxPriorityFeePerGas(ctx context.Context) (ethtypes.EthBigInt, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthMaxPriorityFeePerGas")
	}

	var r0 ethtypes.EthBigInt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthBigInt, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthBigInt); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthBigInt)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthNewBlockFilter provides a mock function with given fields: ctx
func (_m *FullNode) EthNewBlockFilter(ctx context.Context) (ethtypes.EthFilterID, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthNewBlockFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthFilterID, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthFilterID); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthNewFilter provides a mock function with given fields: ctx, filter
func (_m *FullNode) EthNewFilter(ctx context.Context, filter *ethtypes.EthFilterSpec) (ethtypes.EthFilterID, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthNewFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) (ethtypes.EthFilterID, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ethtypes.EthFilterSpec) ethtypes.EthFilterID); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ethtypes.EthFilterSpec) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthNewPendingTransactionFilter provides a mock function with given fields: ctx
func (_m *FullNode) EthNewPendingTransactionFilter(ctx context.Context) (ethtypes.EthFilterID, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthNewPendingTransactionFilter")
	}

	var r0 ethtypes.EthFilterID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthFilterID, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthFilterID); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthFilterID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthProtocolVersion provides a mock function with given fields: ctx
func (_m *FullNode) EthProtocolVersion(ctx context.Context) (ethtypes.EthUint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthProtocolVersion")
	}

	var r0 ethtypes.EthUint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthUint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthUint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthUint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthSendRawTransaction provides a mock function with given fields: ctx, rawTx
func (_m *FullNode) EthSendRawTransaction(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error) {
	ret := _m.Called(ctx, rawTx)

	if len(ret) == 0 {
		panic("no return value specified for EthSendRawTransaction")
	}

	var r0 ethtypes.EthHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) (ethtypes.EthHash, error)); ok {
		return rf(ctx, rawTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) ethtypes.EthHash); ok {
		r0 = rf(ctx, rawTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthBytes) error); ok {
		r1 = rf(ctx, rawTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthSendRawTransactionUntrusted provides a mock function with given fields: ctx, rawTx
func (_m *FullNode) EthSendRawTransactionUntrusted(ctx context.Context, rawTx ethtypes.EthBytes) (ethtypes.EthHash, error) {
	ret := _m.Called(ctx, rawTx)

	if len(ret) == 0 {
		panic("no return value specified for EthSendRawTransactionUntrusted")
	}

	var r0 ethtypes.EthHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) (ethtypes.EthHash, error)); ok {
		return rf(ctx, rawTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthBytes) ethtypes.EthHash); ok {
		r0 = rf(ctx, rawTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthBytes) error); ok {
		r1 = rf(ctx, rawTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthSubscribe provides a mock function with given fields: ctx, params
func (_m *FullNode) EthSubscribe(ctx context.Context, params jsonrpc.RawParams) (ethtypes.EthSubscriptionID, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for EthSubscribe")
	}

	var r0 ethtypes.EthSubscriptionID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthSubscriptionID, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthSubscriptionID); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthSubscriptionID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthSyncing provides a mock function with given fields: ctx
func (_m *FullNode) EthSyncing(ctx context.Context) (ethtypes.EthSyncingResult, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EthSyncing")
	}

	var r0 ethtypes.EthSyncingResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ethtypes.EthSyncingResult, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ethtypes.EthSyncingResult); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ethtypes.EthSyncingResult)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthTraceBlock provides a mock function with given fields: ctx, blkNum
func (_m *FullNode) EthTraceBlock(ctx context.Context, blkNum string) ([]*ethtypes.EthTraceBlock, error) {
	ret := _m.Called(ctx, blkNum)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceBlock")
	}

	var r0 []*ethtypes.EthTraceBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*ethtypes.EthTraceBlock, error)); ok {
		return rf(ctx, blkNum)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*ethtypes.EthTraceBlock); ok {
		r0 = rf(ctx, blkNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blkNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthTraceFilter provides a mock function with given fields: ctx, filter
func (_m *FullNode) EthTraceFilter(ctx context.Context, filter ethtypes.EthTraceFilterCriteria) ([]*ethtypes.EthTraceFilterResult, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceFilter")
	}

	var r0 []*ethtypes.EthTraceFilterResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthTraceFilterCriteria) ([]*ethtypes.EthTraceFilterResult, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthTraceFilterCriteria) []*ethtypes.EthTraceFilterResult); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceFilterResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthTraceFilterCriteria) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthTraceReplayBlockTransactions provides a mock function with given fields: ctx, blkNum, traceTypes
func (_m *FullNode) EthTraceReplayBlockTransactions(ctx context.Context, blkNum string, traceTypes []string) ([]*ethtypes.EthTraceReplayBlockTransaction, error) {
	ret := _m.Called(ctx, blkNum, traceTypes)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceReplayBlockTransactions")
	}

	var r0 []*ethtypes.EthTraceReplayBlockTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*ethtypes.EthTraceReplayBlockTransaction, error)); ok {
		return rf(ctx, blkNum, traceTypes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*ethtypes.EthTraceReplayBlockTransaction); ok {
		r0 = rf(ctx, blkNum, traceTypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceReplayBlockTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, blkNum, traceTypes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthTraceTransaction provides a mock function with given fields: ctx, txHash
func (_m *FullNode) EthTraceTransaction(ctx context.Context, txHash string) ([]*ethtypes.EthTraceTransaction, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for EthTraceTransaction")
	}

	var r0 []*ethtypes.EthTraceTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*ethtypes.EthTraceTransaction, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*ethtypes.EthTraceTransaction); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ethtypes.EthTraceTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthUninstallFilter provides a mock function with given fields: ctx, id
func (_m *FullNode) EthUninstallFilter(ctx context.Context, id ethtypes.EthFilterID) (bool, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthUninstallFilter")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) (bool, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthFilterID) bool); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthFilterID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EthUnsubscribe provides a mock function with given fields: ctx, id
func (_m *FullNode) EthUnsubscribe(ctx context.Context, id ethtypes.EthSubscriptionID) (bool, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for EthUnsubscribe")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthSubscriptionID) (bool, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ethtypes.EthSubscriptionID) bool); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ethtypes.EthSubscriptionID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetCertificate provides a mock function with given fields: ctx, instance
func (_m *FullNode) F3GetCertificate(ctx context.Context, instance uint64) (*certs.FinalityCertificate, error) {
	ret := _m.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for F3GetCertificate")
	}

	var r0 *certs.FinalityCertificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (*certs.FinalityCertificate, error)); ok {
		return rf(ctx, instance)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *certs.FinalityCertificate); ok {
		r0 = rf(ctx, instance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*certs.FinalityCertificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, instance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetECPowerTable provides a mock function with given fields: ctx, tsk
func (_m *FullNode) F3GetECPowerTable(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for F3GetECPowerTable")
	}

	var r0 gpbft.PowerEntries
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (gpbft.PowerEntries, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) gpbft.PowerEntries); ok {
		r0 = rf(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gpbft.PowerEntries)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetF3PowerTable provides a mock function with given fields: ctx, tsk
func (_m *FullNode) F3GetF3PowerTable(ctx context.Context, tsk types.TipSetKey) (gpbft.PowerEntries, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for F3GetF3PowerTable")
	}

	var r0 gpbft.PowerEntries
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (gpbft.PowerEntries, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) gpbft.PowerEntries); ok {
		r0 = rf(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gpbft.PowerEntries)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetLatestCertificate provides a mock function with given fields: ctx
func (_m *FullNode) F3GetLatestCertificate(ctx context.Context) (*certs.FinalityCertificate, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetLatestCertificate")
	}

	var r0 *certs.FinalityCertificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*certs.FinalityCertificate, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *certs.FinalityCertificate); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*certs.FinalityCertificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetManifest provides a mock function with given fields: ctx
func (_m *FullNode) F3GetManifest(ctx context.Context) (*manifest.Manifest, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetManifest")
	}

	var r0 *manifest.Manifest
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*manifest.Manifest, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *manifest.Manifest); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*manifest.Manifest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetOrRenewParticipationTicket provides a mock function with given fields: ctx, minerID, previous, instances
func (_m *FullNode) F3GetOrRenewParticipationTicket(ctx context.Context, minerID address.Address, previous api.F3ParticipationTicket, instances uint64) (api.F3ParticipationTicket, error) {
	ret := _m.Called(ctx, minerID, previous, instances)

	if len(ret) == 0 {
		panic("no return value specified for F3GetOrRenewParticipationTicket")
	}

	var r0 api.F3ParticipationTicket
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) (api.F3ParticipationTicket, error)); ok {
		return rf(ctx, minerID, previous, instances)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) api.F3ParticipationTicket); ok {
		r0 = rf(ctx, minerID, previous, instances)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(api.F3ParticipationTicket)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, api.F3ParticipationTicket, uint64) error); ok {
		r1 = rf(ctx, minerID, previous, instances)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetPowerTableByInstance provides a mock function with given fields: ctx, instance
func (_m *FullNode) F3GetPowerTableByInstance(ctx context.Context, instance uint64) (gpbft.PowerEntries, error) {
	ret := _m.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for F3GetPowerTableByInstance")
	}

	var r0 gpbft.PowerEntries
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (gpbft.PowerEntries, error)); ok {
		return rf(ctx, instance)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) gpbft.PowerEntries); ok {
		r0 = rf(ctx, instance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gpbft.PowerEntries)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, instance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3GetProgress provides a mock function with given fields: ctx
func (_m *FullNode) F3GetProgress(ctx context.Context) (gpbft.InstanceProgress, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3GetProgress")
	}

	var r0 gpbft.InstanceProgress
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (gpbft.InstanceProgress, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) gpbft.InstanceProgress); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(gpbft.InstanceProgress)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3IsRunning provides a mock function with given fields: ctx
func (_m *FullNode) F3IsRunning(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3IsRunning")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3ListParticipants provides a mock function with given fields: ctx
func (_m *FullNode) F3ListParticipants(ctx context.Context) ([]api.F3Participant, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for F3ListParticipants")
	}

	var r0 []api.F3Participant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]api.F3Participant, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []api.F3Participant); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.F3Participant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// F3Participate provides a mock function with given fields: ctx, ticket
func (_m *FullNode) F3Participate(ctx context.Context, ticket api.F3ParticipationTicket) (api.F3ParticipationLease, error) {
	ret := _m.Called(ctx, ticket)

	if len(ret) == 0 {
		panic("no return value specified for F3Participate")
	}

	var r0 api.F3ParticipationLease
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.F3ParticipationTicket) (api.F3ParticipationLease, error)); ok {
		return rf(ctx, ticket)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.F3ParticipationTicket) api.F3ParticipationLease); ok {
		r0 = rf(ctx, ticket)
	} else {
		r0 = ret.Get(0).(api.F3ParticipationLease)
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.F3ParticipationTicket) error); ok {
		r1 = rf(ctx, ticket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilecoinAddressToEthAddress provides a mock function with given fields: ctx, p
func (_m *FullNode) FilecoinAddressToEthAddress(ctx context.Context, p jsonrpc.RawParams) (ethtypes.EthAddress, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for FilecoinAddressToEthAddress")
	}

	var r0 ethtypes.EthAddress
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) (ethtypes.EthAddress, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jsonrpc.RawParams) ethtypes.EthAddress); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ethtypes.EthAddress)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jsonrpc.RawParams) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasEstimateFeeCap provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) GasEstimateFeeCap(_a0 context.Context, _a1 *types.Message, _a2 int64, _a3 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateFeeCap")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, int64, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, int64, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, int64, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasEstimateGasLimit provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) GasEstimateGasLimit(_a0 context.Context, _a1 *types.Message, _a2 types.TipSetKey) (int64, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateGasLimit")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) (int64, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) int64); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasEstimateGasPremium provides a mock function with given fields: _a0, nblocksincl, sender, gaslimit, tsk
func (_m *FullNode) GasEstimateGasPremium(_a0 context.Context, nblocksincl uint64, sender address.Address, gaslimit int64, tsk types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, nblocksincl, sender, gaslimit, tsk)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateGasPremium")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, nblocksincl, sender, gaslimit, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, nblocksincl, sender, gaslimit, tsk)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) error); ok {
		r1 = rf(_a0, nblocksincl, sender, gaslimit, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasEstimateMessageGas provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) GasEstimateMessageGas(_a0 context.Context, _a1 *types.Message, _a2 *api.MessageSendSpec, _a3 types.TipSetKey) (*types.Message, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for GasEstimateMessageGas")
	}

	var r0 *types.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) (*types.Message, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) *types.Message); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, *api.MessageSendSpec, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActorEventsRaw provides a mock function with given fields: ctx, filter
func (_m *FullNode) GetActorEventsRaw(ctx context.Context, filter *types.ActorEventFilter) ([]*types.ActorEvent, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetActorEventsRaw")
	}

	var r0 []*types.ActorEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) ([]*types.ActorEvent, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) []*types.ActorEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.ActorEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ActorEventFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ID provides a mock function with given fields: _a0
func (_m *FullNode) ID(_a0 context.Context) (peer.ID, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 peer.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (peer.ID, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) peer.ID); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogAlerts provides a mock function with given fields: ctx
func (_m *FullNode) LogAlerts(ctx context.Context) ([]alerting.Alert, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LogAlerts")
	}

	var r0 []alerting.Alert
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]alerting.Alert, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []alerting.Alert); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]alerting.Alert)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogList provides a mock function with given fields: _a0
func (_m *FullNode) LogList(_a0 context.Context) ([]string, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for LogList")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogSetLevel provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) LogSetLevel(_a0 context.Context, _a1 string, _a2 string) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LogSetLevel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarketAddBalance provides a mock function with given fields: ctx, wallet, addr, amt
func (_m *FullNode) MarketAddBalance(ctx context.Context, wallet address.Address, addr address.Address, amt big.Int) (cid.Cid, error) {
	ret := _m.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketAddBalance")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) (cid.Cid, error)); ok {
		return rf(ctx, wallet, addr, amt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) cid.Cid); ok {
		r0 = rf(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketGetReserved provides a mock function with given fields: ctx, addr
func (_m *FullNode) MarketGetReserved(ctx context.Context, addr address.Address) (big.Int, error) {
	ret := _m.Called(ctx, addr)

	if len(ret) == 0 {
		panic("no return value specified for MarketGetReserved")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (big.Int, error)); ok {
		return rf(ctx, addr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) big.Int); ok {
		r0 = rf(ctx, addr)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketReleaseFunds provides a mock function with given fields: ctx, addr, amt
func (_m *FullNode) MarketReleaseFunds(ctx context.Context, addr address.Address, amt big.Int) error {
	ret := _m.Called(ctx, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketReleaseFunds")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, big.Int) error); ok {
		r0 = rf(ctx, addr, amt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarketReserveFunds provides a mock function with given fields: ctx, wallet, addr, amt
func (_m *FullNode) MarketReserveFunds(ctx context.Context, wallet address.Address, addr address.Address, amt big.Int) (cid.Cid, error) {
	ret := _m.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketReserveFunds")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) (cid.Cid, error)); ok {
		return rf(ctx, wallet, addr, amt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) cid.Cid); ok {
		r0 = rf(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketWithdraw provides a mock function with given fields: ctx, wallet, addr, amt
func (_m *FullNode) MarketWithdraw(ctx context.Context, wallet address.Address, addr address.Address, amt big.Int) (cid.Cid, error) {
	ret := _m.Called(ctx, wallet, addr, amt)

	if len(ret) == 0 {
		panic("no return value specified for MarketWithdraw")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) (cid.Cid, error)); ok {
		return rf(ctx, wallet, addr, amt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) cid.Cid); ok {
		r0 = rf(ctx, wallet, addr, amt)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(ctx, wallet, addr, amt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerCreateBlock provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MinerCreateBlock(_a0 context.Context, _a1 *api.BlockTemplate) (*types.BlockMsg, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MinerCreateBlock")
	}

	var r0 *types.BlockMsg
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.BlockTemplate) (*types.BlockMsg, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.BlockTemplate) *types.BlockMsg); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockMsg)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.BlockTemplate) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerGetBaseInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MinerGetBaseInfo(_a0 context.Context, _a1 address.Address, _a2 abi.ChainEpoch, _a3 types.TipSetKey) (*api.MiningBaseInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for MinerGetBaseInfo")
	}

	var r0 *api.MiningBaseInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) (*api.MiningBaseInfo, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) *api.MiningBaseInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MiningBaseInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolBatchPush provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolBatchPush(_a0 context.Context, _a1 []*types.SignedMessage) ([]cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPush")
	}

	var r0 []cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) ([]cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) []cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*types.SignedMessage) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolBatchPushMessage provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MpoolBatchPushMessage(_a0 context.Context, _a1 []*types.Message, _a2 *api.MessageSendSpec) ([]*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPushMessage")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Message, *api.MessageSendSpec) ([]*types.SignedMessage, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Message, *api.MessageSendSpec) []*types.SignedMessage); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*types.Message, *api.MessageSendSpec) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolBatchPushUntrusted provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolBatchPushUntrusted(_a0 context.Context, _a1 []*types.SignedMessage) ([]cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolBatchPushUntrusted")
	}

	var r0 []cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) ([]cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*types.SignedMessage) []cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*types.SignedMessage) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolCheckMessages provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolCheckMessages(_a0 context.Context, _a1 []*api.MessagePrototype) ([][]api.MessageCheckStatus, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*api.MessagePrototype) ([][]api.MessageCheckStatus, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*api.MessagePrototype) [][]api.MessageCheckStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*api.MessagePrototype) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolCheckPendingMessages provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolCheckPendingMessages(_a0 context.Context, _a1 address.Address) ([][]api.MessageCheckStatus, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckPendingMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) ([][]api.MessageCheckStatus, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) [][]api.MessageCheckStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolCheckReplaceMessages provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolCheckReplaceMessages(_a0 context.Context, _a1 []*types.Message) ([][]api.MessageCheckStatus, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolCheckReplaceMessages")
	}

	var r0 [][]api.MessageCheckStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Message) ([][]api.MessageCheckStatus, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Message) [][]api.MessageCheckStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]api.MessageCheckStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*types.Message) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolClear provides a mock function with given fields: ctx, clearLocal
func (_m *FullNode) MpoolClear(ctx context.Context, clearLocal bool) error {
	ret := _m.Called(ctx, clearLocal)

	if len(ret) == 0 {
		panic("no return value specified for MpoolClear")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) error); ok {
		r0 = rf(ctx, clearLocal)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MpoolGetConfig provides a mock function with given fields: _a0
func (_m *FullNode) MpoolGetConfig(_a0 context.Context) (*types.MpoolConfig, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MpoolGetConfig")
	}

	var r0 *types.MpoolConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.MpoolConfig, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.MpoolConfig); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MpoolConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolGetNonce provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolGetNonce(_a0 context.Context, _a1 address.Address) (uint64, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolGetNonce")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (uint64, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPending provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPending(_a0 context.Context, _a1 types.TipSetKey) ([]*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPending")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]*types.SignedMessage, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []*types.SignedMessage); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPush provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPush(_a0 context.Context, _a1 *types.SignedMessage) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPush")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) (cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.SignedMessage) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPushMessage provides a mock function with given fields: ctx, msg, spec
func (_m *FullNode) MpoolPushMessage(ctx context.Context, msg *types.Message, spec *api.MessageSendSpec) (*types.SignedMessage, error) {
	ret := _m.Called(ctx, msg, spec)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPushMessage")
	}

	var r0 *types.SignedMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec) (*types.SignedMessage, error)); ok {
		return rf(ctx, msg, spec)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, *api.MessageSendSpec) *types.SignedMessage); ok {
		r0 = rf(ctx, msg, spec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, *api.MessageSendSpec) error); ok {
		r1 = rf(ctx, msg, spec)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPushUntrusted provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPushUntrusted(_a0 context.Context, _a1 *types.SignedMessage) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolPushUntrusted")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) (cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.SignedMessage) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolSelect provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MpoolSelect(_a0 context.Context, _a1 types.TipSetKey, _a2 float64) ([]*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSelect")
	}

	var r0 []*types.SignedMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, float64) ([]*types.SignedMessage, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, float64) []*types.SignedMessage); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, float64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolSetConfig provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolSetConfig(_a0 context.Context, _a1 *types.MpoolConfig) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.MpoolConfig) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MpoolSub provides a mock function with given fields: _a0
func (_m *FullNode) MpoolSub(_a0 context.Context) (<-chan api.MpoolUpdate, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MpoolSub")
	}

	var r0 <-chan api.MpoolUpdate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (<-chan api.MpoolUpdate, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan api.MpoolUpdate); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan api.MpoolUpdate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigAddApprove provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MsigAddApprove(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 uint64, _a4 address.Address, _a5 address.Address, _a6 bool) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, bool) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigAddCancel provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5
func (_m *FullNode) MsigAddCancel(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 uint64, _a4 address.Address, _a5 bool) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, bool) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigAddPropose provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) MsigAddPropose(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 address.Address, _a4 bool) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for MsigAddPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, bool) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigApprove provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MsigApprove(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for MsigApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigApproveTxnHash provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8
func (_m *FullNode) MsigApproveTxnHash(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address, _a4 address.Address, _a5 big.Int, _a6 address.Address, _a7 uint64, _a8 []byte) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)

	if len(ret) == 0 {
		panic("no return value specified for MsigApproveTxnHash")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigCancel provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MsigCancel(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for MsigCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigCancelTxnHash provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7
func (_m *FullNode) MsigCancelTxnHash(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address, _a4 big.Int, _a5 address.Address, _a6 uint64, _a7 []byte) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7)

	if len(ret) == 0 {
		panic("no return value specified for MsigCancelTxnHash")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, big.Int, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, big.Int, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigCreate provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MsigCreate(_a0 context.Context, _a1 uint64, _a2 []address.Address, _a3 abi.ChainEpoch, _a4 big.Int, _a5 address.Address, _a6 big.Int) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for MsigCreate")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, big.Int, address.Address, big.Int) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, big.Int, address.Address, big.Int) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, []address.Address, abi.ChainEpoch, big.Int, address.Address, big.Int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigGetAvailableBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MsigGetAvailableBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetAvailableBalance")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigGetPending provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MsigGetPending(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) ([]*api.MsigTransaction, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetPending")
	}

	var r0 []*api.MsigTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]*api.MsigTransaction, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []*api.MsigTransaction); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.MsigTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigGetVested provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MsigGetVested(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey, _a3 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetVested")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigGetVestingSchedule provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MsigGetVestingSchedule(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MsigVesting, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for MsigGetVestingSchedule")
	}

	var r0 api.MsigVesting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MsigVesting, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MsigVesting); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MsigVesting)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigPropose provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MsigPropose(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 big.Int, _a4 address.Address, _a5 uint64, _a6 []byte) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for MsigPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int, address.Address, uint64, []byte) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int, address.Address, uint64, []byte) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigRemoveSigner provides a mock function with given fields: ctx, msig, proposer, toRemove, decrease
func (_m *FullNode) MsigRemoveSigner(ctx context.Context, msig address.Address, proposer address.Address, toRemove address.Address, decrease bool) (*api.MessagePrototype, error) {
	ret := _m.Called(ctx, msig, proposer, toRemove, decrease)

	if len(ret) == 0 {
		panic("no return value specified for MsigRemoveSigner")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) (*api.MessagePrototype, error)); ok {
		return rf(ctx, msig, proposer, toRemove, decrease)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, bool) *api.MessagePrototype); ok {
		r0 = rf(ctx, msig, proposer, toRemove, decrease)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, bool) error); ok {
		r1 = rf(ctx, msig, proposer, toRemove, decrease)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigSwapApprove provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MsigSwapApprove(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 uint64, _a4 address.Address, _a5 address.Address, _a6 address.Address) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapApprove")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address, address.Address) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigSwapCancel provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5
func (_m *FullNode) MsigSwapCancel(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 uint64, _a4 address.Address, _a5 address.Address) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapCancel")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, uint64, address.Address, address.Address) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigSwapPropose provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) MsigSwapPropose(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 address.Address, _a4 address.Address) (*api.MessagePrototype, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for MsigSwapPropose")
	}

	var r0 *api.MessagePrototype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, address.Address) (*api.MessagePrototype, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, address.Address, address.Address) *api.MessagePrototype); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MessagePrototype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, address.Address, address.Address) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetAddrsListen provides a mock function with given fields: _a0
func (_m *FullNode) NetAddrsListen(_a0 context.Context) (peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NetAddrsListen")
	}

	var r0 peer.AddrInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (peer.AddrInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetAgentVersion provides a mock function with given fields: ctx, p
func (_m *FullNode) NetAgentVersion(ctx context.Context, p peer.ID) (string, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for NetAgentVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) (string, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) string); ok {
		r0 = rf(ctx, p)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetAutoNatStatus provides a mock function with given fields: _a0
func (_m *FullNode) NetAutoNatStatus(_a0 context.Context) (api.NatInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NetAutoNatStatus")
	}

	var r0 api.NatInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (api.NatInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) api.NatInfo); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(api.NatInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetBandwidthStats provides a mock function with given fields: ctx
func (_m *FullNode) NetBandwidthStats(ctx context.Context) (metrics.Stats, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStats")
	}

	var r0 metrics.Stats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (metrics.Stats, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) metrics.Stats); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(metrics.Stats)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetBandwidthStatsByPeer provides a mock function with given fields: ctx
func (_m *FullNode) NetBandwidthStatsByPeer(ctx context.Context) (map[string]metrics.Stats, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStatsByPeer")
	}

	var r0 map[string]metrics.Stats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[string]metrics.Stats, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]metrics.Stats); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]metrics.Stats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetBandwidthStatsByProtocol provides a mock function with given fields: ctx
func (_m *FullNode) NetBandwidthStatsByProtocol(ctx context.Context) (map[protocol.ID]metrics.Stats, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBandwidthStatsByProtocol")
	}

	var r0 map[protocol.ID]metrics.Stats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[protocol.ID]metrics.Stats, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[protocol.ID]metrics.Stats); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[protocol.ID]metrics.Stats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetBlockAdd provides a mock function with given fields: ctx, acl
func (_m *FullNode) NetBlockAdd(ctx context.Context, acl api.NetBlockList) error {
	ret := _m.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.NetBlockList) error); ok {
		r0 = rf(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetBlockList provides a mock function with given fields: ctx
func (_m *FullNode) NetBlockList(ctx context.Context) (api.NetBlockList, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockList")
	}

	var r0 api.NetBlockList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (api.NetBlockList, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) api.NetBlockList); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(api.NetBlockList)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetBlockRemove provides a mock function with given fields: ctx, acl
func (_m *FullNode) NetBlockRemove(ctx context.Context, acl api.NetBlockList) error {
	ret := _m.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetBlockRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.NetBlockList) error); ok {
		r0 = rf(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetConnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnect(_a0 context.Context, _a1 peer.AddrInfo) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetConnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetConnectedness provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnectedness(_a0 context.Context, _a1 peer.ID) (network.Connectedness, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetConnectedness")
	}

	var r0 network.Connectedness
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) (network.Connectedness, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) network.Connectedness); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(network.Connectedness)
	}

	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetDisconnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetDisconnect(_a0 context.Context, _a1 peer.ID) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetDisconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetFindPeer provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetFindPeer(_a0 context.Context, _a1 peer.ID) (peer.AddrInfo, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetFindPeer")
	}

	var r0 peer.AddrInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) (peer.AddrInfo, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) peer.AddrInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetLimit provides a mock function with given fields: ctx, scope
func (_m *FullNode) NetLimit(ctx context.Context, scope string) (api.NetLimit, error) {
	ret := _m.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for NetLimit")
	}

	var r0 api.NetLimit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (api.NetLimit, error)); ok {
		return rf(ctx, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) api.NetLimit); ok {
		r0 = rf(ctx, scope)
	} else {
		r0 = ret.Get(0).(api.NetLimit)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetListening provides a mock function with given fields: ctx
func (_m *FullNode) NetListening(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetListening")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetPeerInfo provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetPeerInfo(_a0 context.Context, _a1 peer.ID) (*api.ExtendedPeerInfo, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetPeerInfo")
	}

	var r0 *api.ExtendedPeerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) (*api.ExtendedPeerInfo, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) *api.ExtendedPeerInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ExtendedPeerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetPeers provides a mock function with given fields: _a0
func (_m *FullNode) NetPeers(_a0 context.Context) ([]peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NetPeers")
	}

	var r0 []peer.AddrInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]peer.AddrInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.AddrInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetPing provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetPing(_a0 context.Context, _a1 peer.ID) (time.Duration, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetPing")
	}

	var r0 time.Duration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) (time.Duration, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) time.Duration); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetProtectAdd provides a mock function with given fields: ctx, acl
func (_m *FullNode) NetProtectAdd(ctx context.Context, acl []peer.ID) error {
	ret := _m.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []peer.ID) error); ok {
		r0 = rf(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetProtectList provides a mock function with given fields: ctx
func (_m *FullNode) NetProtectList(ctx context.Context) ([]peer.ID, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectList")
	}

	var r0 []peer.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]peer.ID, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []peer.ID); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetProtectRemove provides a mock function with given fields: ctx, acl
func (_m *FullNode) NetProtectRemove(ctx context.Context, acl []peer.ID) error {
	ret := _m.Called(ctx, acl)

	if len(ret) == 0 {
		panic("no return value specified for NetProtectRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []peer.ID) error); ok {
		r0 = rf(ctx, acl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetPubsubScores provides a mock function with given fields: _a0
func (_m *FullNode) NetPubsubScores(_a0 context.Context) ([]api.PubsubScore, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NetPubsubScores")
	}

	var r0 []api.PubsubScore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]api.PubsubScore, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []api.PubsubScore); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.PubsubScore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetSetLimit provides a mock function with given fields: ctx, scope, limit
func (_m *FullNode) NetSetLimit(ctx context.Context, scope string, limit api.NetLimit) error {
	ret := _m.Called(ctx, scope, limit)

	if len(ret) == 0 {
		panic("no return value specified for NetSetLimit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, api.NetLimit) error); ok {
		r0 = rf(ctx, scope, limit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetStat provides a mock function with given fields: ctx, scope
func (_m *FullNode) NetStat(ctx context.Context, scope string) (api.NetStat, error) {
	ret := _m.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for NetStat")
	}

	var r0 api.NetStat
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (api.NetStat, error)); ok {
		return rf(ctx, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) api.NetStat); ok {
		r0 = rf(ctx, scope)
	} else {
		r0 = ret.Get(0).(api.NetStat)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetVersion provides a mock function with given fields: ctx
func (_m *FullNode) NetVersion(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NetVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeStatus provides a mock function with given fields: ctx, inclChainStatus
func (_m *FullNode) NodeStatus(ctx context.Context, inclChainStatus bool) (api.NodeStatus, error) {
	ret := _m.Called(ctx, inclChainStatus)

	if len(ret) == 0 {
		panic("no return value specified for NodeStatus")
	}

	var r0 api.NodeStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) (api.NodeStatus, error)); ok {
		return rf(ctx, inclChainStatus)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) api.NodeStatus); ok {
		r0 = rf(ctx, inclChainStatus)
	} else {
		r0 = ret.Get(0).(api.NodeStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, inclChainStatus)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychAllocateLane provides a mock function with given fields: ctx, ch
func (_m *FullNode) PaychAllocateLane(ctx context.Context, ch address.Address) (uint64, error) {
	ret := _m.Called(ctx, ch)

	if len(ret) == 0 {
		panic("no return value specified for PaychAllocateLane")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (uint64, error)); ok {
		return rf(ctx, ch)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(ctx, ch)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychAvailableFunds provides a mock function with given fields: ctx, ch
func (_m *FullNode) PaychAvailableFunds(ctx context.Context, ch address.Address) (*api.ChannelAvailableFunds, error) {
	ret := _m.Called(ctx, ch)

	if len(ret) == 0 {
		panic("no return value specified for PaychAvailableFunds")
	}

	var r0 *api.ChannelAvailableFunds
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (*api.ChannelAvailableFunds, error)); ok {
		return rf(ctx, ch)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *api.ChannelAvailableFunds); ok {
		r0 = rf(ctx, ch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelAvailableFunds)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychAvailableFundsByFromTo provides a mock function with given fields: ctx, from, to
func (_m *FullNode) PaychAvailableFundsByFromTo(ctx context.Context, from address.Address, to address.Address) (*api.ChannelAvailableFunds, error) {
	ret := _m.Called(ctx, from, to)

	if len(ret) == 0 {
		panic("no return value specified for PaychAvailableFundsByFromTo")
	}

	var r0 *api.ChannelAvailableFunds
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address) (*api.ChannelAvailableFunds, error)); ok {
		return rf(ctx, from, to)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address) *api.ChannelAvailableFunds); ok {
		r0 = rf(ctx, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelAvailableFunds)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address) error); ok {
		r1 = rf(ctx, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychCollect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychCollect(_a0 context.Context, _a1 address.Address) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for PaychCollect")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychFund provides a mock function with given fields: ctx, from, to, amt
func (_m *FullNode) PaychFund(ctx context.Context, from address.Address, to address.Address, amt big.Int) (*api.ChannelInfo, error) {
	ret := _m.Called(ctx, from, to, amt)

	if len(ret) == 0 {
		panic("no return value specified for PaychFund")
	}

	var r0 *api.ChannelInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) (*api.ChannelInfo, error)); ok {
		return rf(ctx, from, to, amt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) *api.ChannelInfo); ok {
		r0 = rf(ctx, from, to, amt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(ctx, from, to, amt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychGet provides a mock function with given fields: ctx, from, to, amt, opts
func (_m *FullNode) PaychGet(ctx context.Context, from address.Address, to address.Address, amt big.Int, opts api.PaychGetOpts) (*api.ChannelInfo, error) {
	ret := _m.Called(ctx, from, to, amt, opts)

	if len(ret) == 0 {
		panic("no return value specified for PaychGet")
	}

	var r0 *api.ChannelInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int, api.PaychGetOpts) (*api.ChannelInfo, error)); ok {
		return rf(ctx, from, to, amt, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int, api.PaychGetOpts) *api.ChannelInfo); ok {
		r0 = rf(ctx, from, to, amt, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int, api.PaychGetOpts) error); ok {
		r1 = rf(ctx, from, to, amt, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychGetWaitReady provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychGetWaitReady(_a0 context.Context, _a1 cid.Cid) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for PaychGetWaitReady")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychList provides a mock function with given fields: _a0
func (_m *FullNode) PaychList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for PaychList")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]address.Address, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychNewPayment provides a mock function with given fields: ctx, from, to, vouchers
func (_m *FullNode) PaychNewPayment(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec) (*api.PaymentInfo, error) {
	ret := _m.Called(ctx, from, to, vouchers)

	if len(ret) == 0 {
		panic("no return value specified for PaychNewPayment")
	}

	var r0 *api.PaymentInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) (*api.PaymentInfo, error)); ok {
		return rf(ctx, from, to, vouchers)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) *api.PaymentInfo); ok {
		r0 = rf(ctx, from, to, vouchers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaymentInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) error); ok {
		r1 = rf(ctx, from, to, vouchers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychSettle provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychSettle(_a0 context.Context, _a1 address.Address) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for PaychSettle")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychStatus provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychStatus(_a0 context.Context, _a1 address.Address) (*api.PaychStatus, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for PaychStatus")
	}

	var r0 *api.PaychStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (*api.PaychStatus, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *api.PaychStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaychStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherAdd provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherAdd(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher, _a3 []byte, _a4 big.Int) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherAdd")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, big.Int) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, big.Int) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, big.Int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckSpendable provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherCheckSpendable(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher, _a3 []byte, _a4 []byte) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCheckSpendable")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) (bool, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckValid provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) PaychVoucherCheckValid(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCheckValid")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PaychVoucherCreate provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) PaychVoucherCreate(_a0 context.Context, _a1 address.Address, _a2 big.Int, _a3 uint64) (*api.VoucherCreateResult, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherCreate")
	}

	var r0 *api.VoucherCreateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, big.Int, uint64) (*api.VoucherCreateResult, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, big.Int, uint64) *api.VoucherCreateResult); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.VoucherCreateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, big.Int, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherList provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychVoucherList(_a0 context.Context, _a1 address.Address) ([]*paych.SignedVoucher, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherList")
	}

	var r0 []*paych.SignedVoucher
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) ([]*paych.SignedVoucher, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) []*paych.SignedVoucher); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*paych.SignedVoucher)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherSubmit provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherSubmit(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher, _a3 []byte, _a4 []byte) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for PaychVoucherSubmit")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) (cid.Cid, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Session provides a mock function with given fields: _a0
func (_m *FullNode) Session(_a0 context.Context) (uuid.UUID, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Session")
	}

	var r0 uuid.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uuid.UUID, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uuid.UUID); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Shutdown provides a mock function with given fields: _a0
func (_m *FullNode) Shutdown(_a0 context.Context) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartTime provides a mock function with given fields: _a0
func (_m *FullNode) StartTime(_a0 context.Context) (time.Time, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for StartTime")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (time.Time, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateAccountKey provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateAccountKey(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateAccountKey")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateActorCodeCIDs provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateActorCodeCIDs(_a0 context.Context, _a1 go_state_typesnetwork.Version) (map[string]cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateActorCodeCIDs")
	}

	var r0 map[string]cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, go_state_typesnetwork.Version) (map[string]cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, go_state_typesnetwork.Version) map[string]cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]cid.Cid)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, go_state_typesnetwork.Version) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateActorManifestCID provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateActorManifestCID(_a0 context.Context, _a1 go_state_typesnetwork.Version) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateActorManifestCID")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, go_state_typesnetwork.Version) (cid.Cid, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, go_state_typesnetwork.Version) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, go_state_typesnetwork.Version) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateAllMinerFaults provides a mock function with given fields: ctx, lookback, ts
func (_m *FullNode) StateAllMinerFaults(ctx context.Context, lookback abi.ChainEpoch, ts types.TipSetKey) ([]*api.Fault, error) {
	ret := _m.Called(ctx, lookback, ts)

	if len(ret) == 0 {
		panic("no return value specified for StateAllMinerFaults")
	}

	var r0 []*api.Fault
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) ([]*api.Fault, error)); ok {
		return rf(ctx, lookback, ts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) []*api.Fault); ok {
		r0 = rf(ctx, lookback, ts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Fault)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(ctx, lookback, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCall provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateCall(_a0 context.Context, _a1 *types.Message, _a2 types.TipSetKey) (*api.InvocResult, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateCall")
	}

	var r0 *api.InvocResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) (*api.InvocResult, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) *api.InvocResult); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateChangedActors provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateChangedActors(_a0 context.Context, _a1 cid.Cid, _a2 cid.Cid) (map[string]types.ActorV5, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateChangedActors")
	}

	var r0 map[string]types.ActorV5
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) (map[string]types.ActorV5, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) map[string]types.ActorV5); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.ActorV5)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCirculatingSupply provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateCirculatingSupply(_a0 context.Context, _a1 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateCirculatingSupply")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCompute provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateCompute(_a0 context.Context, _a1 abi.ChainEpoch, _a2 []*types.Message, _a3 types.TipSetKey) (*api.ComputeStateOutput, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateCompute")
	}

	var r0 *api.ComputeStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) (*api.ComputeStateOutput, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) *api.ComputeStateOutput); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ComputeStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateComputeDataCID provides a mock function with given fields: ctx, maddr, sectorType, deals, tsk
func (_m *FullNode) StateComputeDataCID(ctx context.Context, maddr address.Address, sectorType abi.RegisteredSealProof, deals []abi.DealID, tsk types.TipSetKey) (cid.Cid, error) {
	ret := _m.Called(ctx, maddr, sectorType, deals, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateComputeDataCID")
	}

	var r0 cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) (cid.Cid, error)); ok {
		return rf(ctx, maddr, sectorType, deals, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) cid.Cid); ok {
		r0 = rf(ctx, maddr, sectorType, deals, tsk)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.RegisteredSealProof, []abi.DealID, types.TipSetKey) error); ok {
		r1 = rf(ctx, maddr, sectorType, deals, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateDealProviderCollateralBounds provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateDealProviderCollateralBounds(_a0 context.Context, _a1 abi.PaddedPieceSize, _a2 bool, _a3 types.TipSetKey) (api.DealCollateralBounds, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateDealProviderCollateralBounds")
	}

	var r0 api.DealCollateralBounds
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) (api.DealCollateralBounds, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) api.DealCollateralBounds); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(api.DealCollateralBounds)
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.PaddedPieceSize, bool, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateDecodeParams provides a mock function with given fields: ctx, toAddr, method, params, tsk
func (_m *FullNode) StateDecodeParams(ctx context.Context, toAddr address.Address, method abi.MethodNum, params []byte, tsk types.TipSetKey) (interface{}, error) {
	ret := _m.Called(ctx, toAddr, method, params, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateDecodeParams")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) (interface{}, error)); ok {
		return rf(ctx, toAddr, method, params, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) interface{}); ok {
		r0 = rf(ctx, toAddr, method, params, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.MethodNum, []byte, types.TipSetKey) error); ok {
		r1 = rf(ctx, toAddr, method, params, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateEncodeParams provides a mock function with given fields: ctx, toActCode, method, params
func (_m *FullNode) StateEncodeParams(ctx context.Context, toActCode cid.Cid, method abi.MethodNum, params json.RawMessage) ([]byte, error) {
	ret := _m.Called(ctx, toActCode, method, params)

	if len(ret) == 0 {
		panic("no return value specified for StateEncodeParams")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) ([]byte, error)); ok {
		return rf(ctx, toActCode, method, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) []byte); ok {
		r0 = rf(ctx, toActCode, method, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, abi.MethodNum, json.RawMessage) error); ok {
		r1 = rf(ctx, toActCode, method, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetActor provides a mock function with given fields: ctx, actor, tsk
func (_m *FullNode) StateGetActor(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*types.ActorV5, error) {
	ret := _m.Called(ctx, actor, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetActor")
	}

	var r0 *types.ActorV5
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*types.ActorV5, error)); ok {
		return rf(ctx, actor, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *types.ActorV5); ok {
		r0 = rf(ctx, actor, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ActorV5)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, actor, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllAllocations provides a mock function with given fields: ctx, tsk
func (_m *FullNode) StateGetAllAllocations(ctx context.Context, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllAllocations")
	}

	var r0 map[verifreg.AllocationId]verifreg.Allocation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[verifreg.AllocationId]verifreg.Allocation); ok {
		r0 = rf(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.AllocationId]verifreg.Allocation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllClaims provides a mock function with given fields: ctx, tsk
func (_m *FullNode) StateGetAllClaims(ctx context.Context, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllClaims")
	}

	var r0 map[verifreg.ClaimId]verifreg.Claim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[verifreg.ClaimId]verifreg.Claim); ok {
		r0 = rf(ctx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.ClaimId]verifreg.Claim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllocation provides a mock function with given fields: ctx, clientAddr, allocationId, tsk
func (_m *FullNode) StateGetAllocation(ctx context.Context, clientAddr address.Address, allocationId verifreg.AllocationId, tsk types.TipSetKey) (*verifreg.Allocation, error) {
	ret := _m.Called(ctx, clientAddr, allocationId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocation")
	}

	var r0 *verifreg.Allocation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) (*verifreg.Allocation, error)); ok {
		return rf(ctx, clientAddr, allocationId, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) *verifreg.Allocation); ok {
		r0 = rf(ctx, clientAddr, allocationId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Allocation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, verifreg.AllocationId, types.TipSetKey) error); ok {
		r1 = rf(ctx, clientAddr, allocationId, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllocationForPendingDeal provides a mock function with given fields: ctx, dealId, tsk
func (_m *FullNode) StateGetAllocationForPendingDeal(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (*verifreg.Allocation, error) {
	ret := _m.Called(ctx, dealId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocationForPendingDeal")
	}

	var r0 *verifreg.Allocation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (*verifreg.Allocation, error)); ok {
		return rf(ctx, dealId, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) *verifreg.Allocation); ok {
		r0 = rf(ctx, dealId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Allocation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = rf(ctx, dealId, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllocationIdForPendingDeal provides a mock function with given fields: ctx, dealId, tsk
func (_m *FullNode) StateGetAllocationIdForPendingDeal(ctx context.Context, dealId abi.DealID, tsk types.TipSetKey) (verifreg.AllocationId, error) {
	ret := _m.Called(ctx, dealId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocationIdForPendingDeal")
	}

	var r0 verifreg.AllocationId
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (verifreg.AllocationId, error)); ok {
		return rf(ctx, dealId, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) verifreg.AllocationId); ok {
		r0 = rf(ctx, dealId, tsk)
	} else {
		r0 = ret.Get(0).(verifreg.AllocationId)
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = rf(ctx, dealId, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetAllocations provides a mock function with given fields: ctx, clientAddr, tsk
func (_m *FullNode) StateGetAllocations(ctx context.Context, clientAddr address.Address, tsk types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error) {
	ret := _m.Called(ctx, clientAddr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetAllocations")
	}

	var r0 map[verifreg.AllocationId]verifreg.Allocation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (map[verifreg.AllocationId]verifreg.Allocation, error)); ok {
		return rf(ctx, clientAddr, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) map[verifreg.AllocationId]verifreg.Allocation); ok {
		r0 = rf(ctx, clientAddr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.AllocationId]verifreg.Allocation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, clientAddr, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetBeaconEntry provides a mock function with given fields: ctx, epoch
func (_m *FullNode) StateGetBeaconEntry(ctx context.Context, epoch abi.ChainEpoch) (*types.BeaconEntry, error) {
	ret := _m.Called(ctx, epoch)

	if len(ret) == 0 {
		panic("no return value specified for StateGetBeaconEntry")
	}

	var r0 *types.BeaconEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch) (*types.BeaconEntry, error)); ok {
		return rf(ctx, epoch)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch) *types.BeaconEntry); ok {
		r0 = rf(ctx, epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BeaconEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetClaim provides a mock function with given fields: ctx, providerAddr, claimId, tsk
func (_m *FullNode) StateGetClaim(ctx context.Context, providerAddr address.Address, claimId verifreg.ClaimId, tsk types.TipSetKey) (*verifreg.Claim, error) {
	ret := _m.Called(ctx, providerAddr, claimId, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetClaim")
	}

	var r0 *verifreg.Claim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) (*verifreg.Claim, error)); ok {
		return rf(ctx, providerAddr, claimId, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) *verifreg.Claim); ok {
		r0 = rf(ctx, providerAddr, claimId, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verifreg.Claim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, verifreg.ClaimId, types.TipSetKey) error); ok {
		r1 = rf(ctx, providerAddr, claimId, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetClaims provides a mock function with given fields: ctx, providerAddr, tsk
func (_m *FullNode) StateGetClaims(ctx context.Context, providerAddr address.Address, tsk types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error) {
	ret := _m.Called(ctx, providerAddr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetClaims")
	}

	var r0 map[verifreg.ClaimId]verifreg.Claim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (map[verifreg.ClaimId]verifreg.Claim, error)); ok {
		return rf(ctx, providerAddr, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) map[verifreg.ClaimId]verifreg.Claim); ok {
		r0 = rf(ctx, providerAddr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[verifreg.ClaimId]verifreg.Claim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, providerAddr, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetNetworkParams provides a mock function with given fields: ctx
func (_m *FullNode) StateGetNetworkParams(ctx context.Context) (*api.NetworkParams, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for StateGetNetworkParams")
	}

	var r0 *api.NetworkParams
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*api.NetworkParams, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *api.NetworkParams); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.NetworkParams)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetRandomnessDigestFromBeacon provides a mock function with given fields: ctx, randEpoch, tsk
func (_m *FullNode) StateGetRandomnessDigestFromBeacon(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _m.Called(ctx, randEpoch, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessDigestFromBeacon")
	}

	var r0 abi.Randomness
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (abi.Randomness, error)); ok {
		return rf(ctx, randEpoch, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) abi.Randomness); ok {
		r0 = rf(ctx, randEpoch, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(ctx, randEpoch, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetRandomnessDigestFromTickets provides a mock function with given fields: ctx, randEpoch, tsk
func (_m *FullNode) StateGetRandomnessDigestFromTickets(ctx context.Context, randEpoch abi.ChainEpoch, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _m.Called(ctx, randEpoch, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessDigestFromTickets")
	}

	var r0 abi.Randomness
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) (abi.Randomness, error)); ok {
		return rf(ctx, randEpoch, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) abi.Randomness); ok {
		r0 = rf(ctx, randEpoch, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(ctx, randEpoch, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetRandomnessFromBeacon provides a mock function with given fields: ctx, personalization, randEpoch, entropy, tsk
func (_m *FullNode) StateGetRandomnessFromBeacon(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _m.Called(ctx, personalization, randEpoch, entropy, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessFromBeacon")
	}

	var r0 abi.Randomness
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) (abi.Randomness, error)); ok {
		return rf(ctx, personalization, randEpoch, entropy, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) abi.Randomness); ok {
		r0 = rf(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) error); ok {
		r1 = rf(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetRandomnessFromTickets provides a mock function with given fields: ctx, personalization, randEpoch, entropy, tsk
func (_m *FullNode) StateGetRandomnessFromTickets(ctx context.Context, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte, tsk types.TipSetKey) (abi.Randomness, error) {
	ret := _m.Called(ctx, personalization, randEpoch, entropy, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateGetRandomnessFromTickets")
	}

	var r0 abi.Randomness
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) (abi.Randomness, error)); ok {
		return rf(ctx, personalization, randEpoch, entropy, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) abi.Randomness); ok {
		r0 = rf(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, crypto.DomainSeparationTag, abi.ChainEpoch, []byte, types.TipSetKey) error); ok {
		r1 = rf(ctx, personalization, randEpoch, entropy, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListActors provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListActors(_a0 context.Context, _a1 types.TipSetKey) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateListActors")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListMessages provides a mock function with given fields: ctx, match, tsk, toht
func (_m *FullNode) StateListMessages(ctx context.Context, match *api.MessageMatch, tsk types.TipSetKey, toht abi.ChainEpoch) ([]cid.Cid, error) {
	ret := _m.Called(ctx, match, tsk, toht)

	if len(ret) == 0 {
		panic("no return value specified for StateListMessages")
	}

	var r0 []cid.Cid
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) ([]cid.Cid, error)); ok {
		return rf(ctx, match, tsk, toht)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) []cid.Cid); ok {
		r0 = rf(ctx, match, tsk, toht)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.MessageMatch, types.TipSetKey, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, match, tsk, toht)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListMiners provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListMiners(_a0 context.Context, _a1 types.TipSetKey) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateListMiners")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) ([]address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateLookupID provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateLookupID(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateLookupID")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateLookupRobustAddress provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateLookupRobustAddress(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateLookupRobustAddress")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (address.Address, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MarketBalance, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketBalance")
	}

	var r0 api.MarketBalance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MarketBalance, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MarketBalance); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MarketBalance)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketDeals provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketDeals(_a0 context.Context, _a1 types.TipSetKey) (map[string]*api.MarketDeal, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketDeals")
	}

	var r0 map[string]*api.MarketDeal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[string]*api.MarketDeal, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]*api.MarketDeal); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*api.MarketDeal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketParticipants provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketParticipants(_a0 context.Context, _a1 types.TipSetKey) (map[string]api.MarketBalance, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketParticipants")
	}

	var r0 map[string]api.MarketBalance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (map[string]api.MarketBalance, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]api.MarketBalance); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]api.MarketBalance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketProposalPending provides a mock function with given fields: ctx, proposalCid, tsk
func (_m *FullNode) StateMarketProposalPending(ctx context.Context, proposalCid cid.Cid, tsk types.TipSetKey) (bool, error) {
	ret := _m.Called(ctx, proposalCid, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketProposalPending")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, types.TipSetKey) (bool, error)); ok {
		return rf(ctx, proposalCid, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, types.TipSetKey) bool); ok {
		r0 = rf(ctx, proposalCid, tsk)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, types.TipSetKey) error); ok {
		r1 = rf(ctx, proposalCid, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketStorageDeal provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketStorageDeal(_a0 context.Context, _a1 abi.DealID, _a2 types.TipSetKey) (*api.MarketDeal, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMarketStorageDeal")
	}

	var r0 *api.MarketDeal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) (*api.MarketDeal, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) *api.MarketDeal); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MarketDeal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerActiveSectors provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerActiveSectors(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerActiveSectors")
	}

	var r0 []*miner.SectorOnChainInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]*miner.SectorOnChainInfo, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []*miner.SectorOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*miner.SectorOnChainInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerAllocated provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerAllocated(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*bitfield.BitField, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerAllocated")
	}

	var r0 *bitfield.BitField
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*bitfield.BitField, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *bitfield.BitField); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bitfield.BitField)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerAvailableBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerAvailableBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerAvailableBalance")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerCreationDeposit provides a mock function with given fields: ctx, tsk
func (_m *FullNode) StateMinerCreationDeposit(ctx context.Context, tsk types.TipSetKey) (big.Int, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerCreationDeposit")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (big.Int, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) big.Int); ok {
		r0 = rf(ctx, tsk)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerDeadlines provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerDeadlines(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) ([]api.Deadline, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerDeadlines")
	}

	var r0 []api.Deadline
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) ([]api.Deadline, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []api.Deadline); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Deadline)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerFaults provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerFaults(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (bitfield.BitField, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerFaults")
	}

	var r0 bitfield.BitField
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (bitfield.BitField, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) bitfield.BitField); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(bitfield.BitField)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerInfo provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerInfo(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MinerInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInfo")
	}

	var r0 api.MinerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MinerInfo, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MinerInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerInitialPledgeCollateral provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateMinerInitialPledgeCollateral(_a0 context.Context, _a1 address.Address, _a2 v9miner.SectorPreCommitInfo, _a3 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInitialPledgeCollateral")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerInitialPledgeForSector provides a mock function with given fields: ctx, sectorDuration, sectorSize, verifiedSize, tsk
func (_m *FullNode) StateMinerInitialPledgeForSector(ctx context.Context, sectorDuration abi.ChainEpoch, sectorSize abi.SectorSize, verifiedSize uint64, tsk types.TipSetKey) (big.Int, error) {
	ret := _m.Called(ctx, sectorDuration, sectorSize, verifiedSize, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerInitialPledgeForSector")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) (big.Int, error)); ok {
		return rf(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) big.Int); ok {
		r0 = rf(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, abi.SectorSize, uint64, types.TipSetKey) error); ok {
		r1 = rf(ctx, sectorDuration, sectorSize, verifiedSize, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPartitions provides a mock function with given fields: ctx, m, dlIdx, tsk
func (_m *FullNode) StateMinerPartitions(ctx context.Context, m address.Address, dlIdx uint64, tsk types.TipSetKey) ([]api.Partition, error) {
	ret := _m.Called(ctx, m, dlIdx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPartitions")
	}

	var r0 []api.Partition
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, types.TipSetKey) ([]api.Partition, error)); ok {
		return rf(ctx, m, dlIdx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, types.TipSetKey) []api.Partition); ok {
		r0 = rf(ctx, m, dlIdx, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Partition)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, types.TipSetKey) error); ok {
		r1 = rf(ctx, m, dlIdx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPower provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerPower(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*api.MinerPower, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPower")
	}

	var r0 *api.MinerPower
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*api.MinerPower, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *api.MinerPower); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MinerPower)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPreCommitDepositForPower provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateMinerPreCommitDepositForPower(_a0 context.Context, _a1 address.Address, _a2 v9miner.SectorPreCommitInfo, _a3 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerPreCommitDepositForPower")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) (big.Int, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, v9miner.SectorPreCommitInfo, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerProvingDeadline provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerProvingDeadline(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*dline.Info, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerProvingDeadline")
	}

	var r0 *dline.Info
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*dline.Info, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *dline.Info); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dline.Info)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerRecoveries provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerRecoveries(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (bitfield.BitField, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerRecoveries")
	}

	var r0 bitfield.BitField
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (bitfield.BitField, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) bitfield.BitField); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(bitfield.BitField)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectorAllocated provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateMinerSectorAllocated(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectorAllocated")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (bool, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectorCount provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerSectorCount(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MinerSectors, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectorCount")
	}

	var r0 api.MinerSectors
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (api.MinerSectors, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerSectors); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MinerSectors)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectors provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateMinerSectors(_a0 context.Context, _a1 address.Address, _a2 *bitfield.BitField, _a3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateMinerSectors")
	}

	var r0 []*miner.SectorOnChainInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) ([]*miner.SectorOnChainInfo, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) []*miner.SectorOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*miner.SectorOnChainInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *bitfield.BitField, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateNetworkName provides a mock function with given fields: _a0
func (_m *FullNode) StateNetworkName(_a0 context.Context) (dtypes.NetworkName, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for StateNetworkName")
	}

	var r0 dtypes.NetworkName
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (dtypes.NetworkName, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) dtypes.NetworkName); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(dtypes.NetworkName)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateNetworkVersion provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateNetworkVersion(_a0 context.Context, _a1 types.TipSetKey) (go_state_typesnetwork.Version, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateNetworkVersion")
	}

	var r0 go_state_typesnetwork.Version
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (go_state_typesnetwork.Version, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) go_state_typesnetwork.Version); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(go_state_typesnetwork.Version)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReadState provides a mock function with given fields: ctx, actor, tsk
func (_m *FullNode) StateReadState(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*api.ActorState, error) {
	ret := _m.Called(ctx, actor, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateReadState")
	}

	var r0 *api.ActorState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*api.ActorState, error)); ok {
		return rf(ctx, actor, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *api.ActorState); ok {
		r0 = rf(ctx, actor, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ActorState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, actor, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReplay provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateReplay(_a0 context.Context, _a1 types.TipSetKey, _a2 cid.Cid) (*api.InvocResult, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for StateReplay")
	}

	var r0 *api.InvocResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid) (*api.InvocResult, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid) *api.InvocResult); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSearchMsg provides a mock function with given fields: ctx, from, msg, limit, allowReplaced
func (_m *FullNode) StateSearchMsg(ctx context.Context, from types.TipSetKey, msg cid.Cid, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error) {
	ret := _m.Called(ctx, from, msg, limit, allowReplaced)

	if len(ret) == 0 {
		panic("no return value specified for StateSearchMsg")
	}

	var r0 *api.MsgLookup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) (*api.MsgLookup, error)); ok {
		return rf(ctx, from, msg, limit, allowReplaced)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) *api.MsgLookup); ok {
		r0 = rf(ctx, from, msg, limit, allowReplaced)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, cid.Cid, abi.ChainEpoch, bool) error); ok {
		r1 = rf(ctx, from, msg, limit, allowReplaced)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorExpiration provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateSectorExpiration(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (*builtinminer.SectorExpiration, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorExpiration")
	}

	var r0 *builtinminer.SectorExpiration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*builtinminer.SectorExpiration, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *builtinminer.SectorExpiration); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*builtinminer.SectorExpiration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorGetInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateSectorGetInfo(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorGetInfo")
	}

	var r0 *miner.SectorOnChainInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*miner.SectorOnChainInfo, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorOnChainInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorPartition provides a mock function with given fields: ctx, maddr, sectorNumber, tok
func (_m *FullNode) StateSectorPartition(ctx context.Context, maddr address.Address, sectorNumber abi.SectorNumber, tok types.TipSetKey) (*builtinminer.SectorLocation, error) {
	ret := _m.Called(ctx, maddr, sectorNumber, tok)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorPartition")
	}

	var r0 *builtinminer.SectorLocation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*builtinminer.SectorLocation, error)); ok {
		return rf(ctx, maddr, sectorNumber, tok)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *builtinminer.SectorLocation); ok {
		r0 = rf(ctx, maddr, sectorNumber, tok)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*builtinminer.SectorLocation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(ctx, maddr, sectorNumber, tok)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorPreCommitInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateSectorPreCommitInfo(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (*v9miner.SectorPreCommitOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for StateSectorPreCommitInfo")
	}

	var r0 *v9miner.SectorPreCommitOnChainInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) (*v9miner.SectorPreCommitOnChainInfo, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *v9miner.SectorPreCommitOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v9miner.SectorPreCommitOnChainInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateVMCirculatingSupplyInternal provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateVMCirculatingSupplyInternal(_a0 context.Context, _a1 types.TipSetKey) (api.CirculatingSupply, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StateVMCirculatingSupplyInternal")
	}

	var r0 api.CirculatingSupply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (api.CirculatingSupply, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) api.CirculatingSupply); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(api.CirculatingSupply)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateVerifiedClientStatus provides a mock function with given fields: ctx, addr, tsk
func (_m *FullNode) StateVerifiedClientStatus(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*big.Int, error) {
	ret := _m.Called(ctx, addr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifiedClientStatus")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*big.Int, error)); ok {
		return rf(ctx, addr, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *big.Int); ok {
		r0 = rf(ctx, addr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, addr, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateVerifiedRegistryRootKey provides a mock function with given fields: ctx, tsk
func (_m *FullNode) StateVerifiedRegistryRootKey(ctx context.Context, tsk types.TipSetKey) (address.Address, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifiedRegistryRootKey")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (address.Address, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) address.Address); ok {
		r0 = rf(ctx, tsk)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateVerifierStatus provides a mock function with given fields: ctx, addr, tsk
func (_m *FullNode) StateVerifierStatus(ctx context.Context, addr address.Address, tsk types.TipSetKey) (*big.Int, error) {
	ret := _m.Called(ctx, addr, tsk)

	if len(ret) == 0 {
		panic("no return value specified for StateVerifierStatus")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) (*big.Int, error)); ok {
		return rf(ctx, addr, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *big.Int); ok {
		r0 = rf(ctx, addr, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, addr, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateWaitMsg provides a mock function with given fields: ctx, _a1, confidence, limit, allowReplaced
func (_m *FullNode) StateWaitMsg(ctx context.Context, _a1 cid.Cid, confidence uint64, limit abi.ChainEpoch, allowReplaced bool) (*api.MsgLookup, error) {
	ret := _m.Called(ctx, _a1, confidence, limit, allowReplaced)

	if len(ret) == 0 {
		panic("no return value specified for StateWaitMsg")
	}

	var r0 *api.MsgLookup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) (*api.MsgLookup, error)); ok {
		return rf(ctx, _a1, confidence, limit, allowReplaced)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) *api.MsgLookup); ok {
		r0 = rf(ctx, _a1, confidence, limit, allowReplaced)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, uint64, abi.ChainEpoch, bool) error); ok {
		r1 = rf(ctx, _a1, confidence, limit, allowReplaced)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeActorEventsRaw provides a mock function with given fields: ctx, filter
func (_m *FullNode) SubscribeActorEventsRaw(ctx context.Context, filter *types.ActorEventFilter) (<-chan *types.ActorEvent, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeActorEventsRaw")
	}

	var r0 <-chan *types.ActorEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) (<-chan *types.ActorEvent, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ActorEventFilter) <-chan *types.ActorEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *types.ActorEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ActorEventFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCheckBad provides a mock function with given fields: ctx, bcid
func (_m *FullNode) SyncCheckBad(ctx context.Context, bcid cid.Cid) (string, error) {
	ret := _m.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncCheckBad")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) (string, error)); ok {
		return rf(ctx, bcid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) string); ok {
		r0 = rf(ctx, bcid)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, bcid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCheckpoint provides a mock function with given fields: ctx, tsk
func (_m *FullNode) SyncCheckpoint(ctx context.Context, tsk types.TipSetKey) error {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for SyncCheckpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) error); ok {
		r0 = rf(ctx, tsk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncIncomingBlocks provides a mock function with given fields: ctx
func (_m *FullNode) SyncIncomingBlocks(ctx context.Context) (<-chan *types.BlockHeader, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SyncIncomingBlocks")
	}

	var r0 <-chan *types.BlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (<-chan *types.BlockHeader, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan *types.BlockHeader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *types.BlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncMarkBad provides a mock function with given fields: ctx, bcid
func (_m *FullNode) SyncMarkBad(ctx context.Context, bcid cid.Cid) error {
	ret := _m.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncMarkBad")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = rf(ctx, bcid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncState provides a mock function with given fields: _a0
func (_m *FullNode) SyncState(_a0 context.Context) (*api.SyncState, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SyncState")
	}

	var r0 *api.SyncState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*api.SyncState, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *api.SyncState); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SyncState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncSubmitBlock provides a mock function with given fields: ctx, blk
func (_m *FullNode) SyncSubmitBlock(ctx context.Context, blk *types.BlockMsg) error {
	ret := _m.Called(ctx, blk)

	if len(ret) == 0 {
		panic("no return value specified for SyncSubmitBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.BlockMsg) error); ok {
		r0 = rf(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncUnmarkAllBad provides a mock function with given fields: ctx
func (_m *FullNode) SyncUnmarkAllBad(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SyncUnmarkAllBad")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncUnmarkBad provides a mock function with given fields: ctx, bcid
func (_m *FullNode) SyncUnmarkBad(ctx context.Context, bcid cid.Cid) error {
	ret := _m.Called(ctx, bcid)

	if len(ret) == 0 {
		panic("no return value specified for SyncUnmarkBad")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = rf(ctx, bcid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncValidateTipset provides a mock function with given fields: ctx, tsk
func (_m *FullNode) SyncValidateTipset(ctx context.Context, tsk types.TipSetKey) (bool, error) {
	ret := _m.Called(ctx, tsk)

	if len(ret) == 0 {
		panic("no return value specified for SyncValidateTipset")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) (bool, error)); ok {
		return rf(ctx, tsk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) bool); ok {
		r0 = rf(ctx, tsk)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(ctx, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: _a0
func (_m *FullNode) Version(_a0 context.Context) (api.APIVersion, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 api.APIVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (api.APIVersion, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) api.APIVersion); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(api.APIVersion)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletBalance provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletBalance(_a0 context.Context, _a1 address.Address) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletBalance")
	}

	var r0 big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (big.Int, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletDefaultAddress provides a mock function with given fields: _a0
func (_m *FullNode) WalletDefaultAddress(_a0 context.Context) (address.Address, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for WalletDefaultAddress")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (address.Address, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) address.Address); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletDelete provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletDelete(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletExport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletExport(_a0 context.Context, _a1 address.Address) (*types.KeyInfo, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletExport")
	}

	var r0 *types.KeyInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (*types.KeyInfo, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *types.KeyInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.KeyInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletHas provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletHas(_a0 context.Context, _a1 address.Address) (bool, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletHas")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) (bool, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletImport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletImport(_a0 context.Context, _a1 *types.KeyInfo) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletImport")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) (address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.KeyInfo) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletList provides a mock function with given fields: _a0
func (_m *FullNode) WalletList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for WalletList")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]address.Address, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletNew provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletNew(_a0 context.Context, _a1 types.KeyType) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletNew")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.KeyType) (address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.KeyType) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.KeyType) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSetDefault provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletSetDefault(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletSetDefault")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletSign provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSign(_a0 context.Context, _a1 address.Address, _a2 []byte) (*crypto.Signature, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WalletSign")
	}

	var r0 *crypto.Signature
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte) (*crypto.Signature, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte) *crypto.Signature); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crypto.Signature)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSignMessage provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSignMessage(_a0 context.Context, _a1 address.Address, _a2 *types.Message) (*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WalletSignMessage")
	}

	var r0 *types.SignedMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) (*types.SignedMessage, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) *types.SignedMessage); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.Message) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletValidateAddress provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletValidateAddress(_a0 context.Context, _a1 string) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WalletValidateAddress")
	}

	var r0 address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (address.Address, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletVerify provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) WalletVerify(_a0 context.Context, _a1 address.Address, _a2 []byte, _a3 *crypto.Signature) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for WalletVerify")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte, *crypto.Signature) (bool, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte, *crypto.Signature) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, address.Address, []byte, *crypto.Signature) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Web3ClientVersion provides a mock function with given fields: ctx
func (_m *FullNode) Web3ClientVersion(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Web3ClientVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewFullNode creates a new instance of FullNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFullNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *FullNode {
	mock := &FullNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
